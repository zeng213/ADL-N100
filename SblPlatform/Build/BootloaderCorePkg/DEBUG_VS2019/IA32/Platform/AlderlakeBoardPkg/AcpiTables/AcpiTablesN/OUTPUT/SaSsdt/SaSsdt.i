#undef MIN
#undef MAX
/** @file
  This file contains the SystemAgent SSDT Table ASL code.
  It defines a Global NVS table which exchanges datas between OS
  and SBL.

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/
#include <PcieRpMacroDefinition.h>
#include <AcpiDebug.h>

DefinitionBlock (
  "SaSsdt.aml",
  "SSDT",
  0x02,
  "SaSsdt",
  "SaSsdt ",
  0x3000
  )
{
  //
  // Automatically generated by GenNvs ver 2.4.6
  // Please DO NOT modify !!!
  //
  
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
    //
    // Define SA NVS Area operation region.
    //
  
  
    OperationRegion(SANV, SystemMemory, 0xFFFF0000, 0xAA55)
    Field(SANV,AnyAcc,Lock,Preserve)
    {  Offset(0),      ASLB, 32, // Offset(0),     IGD OpRegion base address
    Offset(4),      IMON, 8,  // Offset(4),     IMON Current Value
    Offset(5),      IGDS, 8,  // Offset(5),     IGD State (Primary Display = 1)
    Offset(6),      IBTT, 8,  // Offset(6),     IGD Boot Display Device
    Offset(7),      IPAT, 8,  // Offset(7),     IGD Panel Type CMOS option
    Offset(8),      IPSC, 8,  // Offset(8),     IGD Panel Scaling
    Offset(9),      IBIA, 8,  // Offset(9),     IGD BIA Configuration
    Offset(10),     ISSC, 8,  // Offset(10),    IGD SSC Configuration
    Offset(11),     IDMS, 8,  // Offset(11),    IGD DVMT Memory Size
    Offset(12),     IF1E, 8,  // Offset(12),    IGD Function 1 Enable
    Offset(13),     HVCO, 8,  // Offset(13),    HPLL VCO
    Offset(14),     GSMI, 8,  // Offset(14),    GMCH SMI/SCI mode (0=SCI)
    Offset(15),     PAVP, 8,  // Offset(15),    IGD PAVP data
    Offset(16),     CADL, 8,  // Offset(16),    Current Attached Device List
    Offset(17),     CSTE, 16, // Offset(17),    Current Display State
    Offset(19),     NSTE, 16, // Offset(19),    Next Display State
    Offset(21),     NDID, 8,  // Offset(21),    Number of Valid Device IDs
    Offset(22),     DID1, 32, // Offset(22),    Device ID 1
    Offset(26),     DID2, 32, // Offset(26),    Device ID 2
    Offset(30),     DID3, 32, // Offset(30),    Device ID 3
    Offset(34),     DID4, 32, // Offset(34),    Device ID 4
    Offset(38),     DID5, 32, // Offset(38),    Device ID 5
    Offset(42),     DID6, 32, // Offset(42),    Device ID 6
    Offset(46),     DID7, 32, // Offset(46),    Device ID 7
    Offset(50),     DID8, 32, // Offset(50),    Device ID 8
    Offset(54),     DID9, 32, // Offset(54),    Device ID 9
    Offset(58),     DIDA, 32, // Offset(58),    Device ID 10
    Offset(62),     DIDB, 32, // Offset(62),    Device ID 11
    Offset(66),     DIDC, 32, // Offset(66),    Device ID 12
    Offset(70),     DIDD, 32, // Offset(70),    Device ID 13
    Offset(74),     DIDE, 32, // Offset(74),    Device ID 14
    Offset(78),     DIDF, 32, // Offset(78),    Device ID 15
    Offset(82),     DIDX, 32, // Offset(82),    Device ID for eDP device
    Offset(86),     NXD1, 32, // Offset(86),    Next state DID1 for _DGS
    Offset(90),     NXD2, 32, // Offset(90),    Next state DID2 for _DGS
    Offset(94),     NXD3, 32, // Offset(94),    Next state DID3 for _DGS
    Offset(98),     NXD4, 32, // Offset(98),    Next state DID4 for _DGS
    Offset(102),    NXD5, 32, // Offset(102),   Next state DID5 for _DGS
    Offset(106),    NXD6, 32, // Offset(106),   Next state DID6 for _DGS
    Offset(110),    NXD7, 32, // Offset(110),   Next state DID7 for _DGS
    Offset(114),    NXD8, 32, // Offset(114),   Next state DID8 for _DGS
    Offset(118),    NXDX, 32, // Offset(118),   Next state DID for eDP
    Offset(122),    LIDS, 8,  // Offset(122),   Lid State (Lid Open = 1)
    Offset(123),    KSV0, 32, // Offset(123),   First four bytes of AKSV (manufacturing mode)
    Offset(127),    KSV1, 8,  // Offset(127),   Fifth byte of AKSV (manufacturing mode)
    Offset(128),    BRTL, 8,  // Offset(128),   Brightness Level Percentage
    Offset(129),    ALSE, 8,  // Offset(129),   Ambient Light Sensor Enable
    Offset(130),    ALAF, 8,  // Offset(130),   Ambient Light Adjusment Factor
    Offset(131),    LLOW, 8,  // Offset(131),   LUX Low Value
    Offset(132),    LHIH, 8,  // Offset(132),   LUX High Value
    Offset(133),    ALFP, 8,  // Offset(133),   Active LFP
    Offset(134),    IPTP, 8,  // Offset(134),   IPU ACPI device type (0=Disabled, 1=AVStream virtual device as child of GFX)
    Offset(135),    EDPV, 8,  // Offset(135),   Check for eDP display device
    Offset(136),    HGMD, 8,  // Offset(136),   SG Mode (0=Disabled, 1=HG Muxed, 2=HG Muxless, 3=DGPU Only)
    Offset(137),    HGFL, 8,  // Offset(137),   HG Feature List
    Offset(138),    SGGP, 8,  // Offset(138),   PCIe0 GPIO Support (0=Disabled, 1=PCH Based, 2=I2C Based)
    Offset(139),    HRE0, 8,  // Offset(139),   PCIe0 HLD RST IO Expander Number
    Offset(140),    HRG0, 32, // Offset(140),   PCIe0 HLD RST GPIO Number
    Offset(144),    HRA0, 8,  // Offset(144),   PCIe0 HLD RST GPIO Active Information
    Offset(145),    PWE0, 8,  // Offset(145),   PCIe0 PWR Enable IO Expander Number
    Offset(146),    PWG0, 32, // Offset(146),   PCIe0 PWR Enable GPIO Number
    Offset(150),    PWA0, 8,  // Offset(150),   PCIe0 PWR Enable GPIO Active Information
    Offset(151),    P1GP, 8,  // Offset(151),   PCIe1 GPIO Support (0=Disabled, 1=PCH Based, 2=I2C Based)
    Offset(152),    HRE1, 8,  // Offset(152),   PCIe1 HLD RST IO Expander Number
    Offset(153),    HRG1, 32, // Offset(153),   PCIe1 HLD RST GPIO Number
    Offset(157),    HRA1, 8,  // Offset(157),   PCIe1 HLD RST GPIO Active Information
    Offset(158),    PWE1, 8,  // Offset(158),   PCIe1 PWR Enable IO Expander Number
    Offset(159),    PWG1, 32, // Offset(159),   PCIe1 PWR Enable GPIO Number
    Offset(163),    PWA1, 8,  // Offset(163),   PCIe1 PWR Enable GPIO Active Information
    Offset(164),    P2GP, 8,  // Offset(164),   PCIe2 GPIO Support (0=Disabled, 1=PCH Based, 2=I2C Based)
    Offset(165),    HRE2, 8,  // Offset(165),   PCIe2 HLD RST IO Expander Number
    Offset(166),    HRG2, 32, // Offset(166),   PCIe2 HLD RST GPIO Number
    Offset(170),    HRA2, 8,  // Offset(170),   PCIe2 HLD RST GPIO Active Information
    Offset(171),    PWE2, 8,  // Offset(171),   PCIe2 PWR Enable IO Expander Number
    Offset(172),    PWG2, 32, // Offset(172),   PCIe2 PWR Enable GPIO Number
    Offset(176),    PWA2, 8,  // Offset(176),   PCIe2 PWR Enable GPIO Active Information
    Offset(177),    P3GP, 8,  // Offset(177),   PCIe3 GPIO Support (0=Disabled, 1=PCH Based, 2=I2C Based)
    Offset(178),    HRE3, 8,  // Offset(178),   PCIe3 HLD RST IO Expander Number
    Offset(179),    HRG3, 32, // Offset(179),   PCIe3 HLD RST GPIO Number
    Offset(183),    HRA3, 8,  // Offset(183),   PCIe3 HLD RST GPIO Active Information
    Offset(184),    PWE3, 8,  // Offset(184),   PCIe3 PWR Enable IO Expander Number
    Offset(185),    PWG3, 32, // Offset(185),   PCIe3 PWR Enable GPIO Number
    Offset(189),    PWA3, 8,  // Offset(189),   PCIe3 PWR Enable GPIO Active Information
    Offset(190),    P3WK, 32, // Offset(190),   PCIe3 RTD3 Device Wake GPIO Number
    Offset(194),    DLPW, 16, // Offset(194),   Delay after power enable for PCIe
    Offset(196),    DLHR, 16, // Offset(196),   Delay after Hold Reset for PCIe
    Offset(198),    EECP, 8,  // Offset(198),   PCIe0 Endpoint Capability Structure Offset
    Offset(199),    XBAS, 32, // Offset(199),   Any Device's PCIe Config Space Base Address
    Offset(203),    GBAS, 16, // Offset(203),   GPIO Base Address
    Offset(205),    NVGA, 32, // Offset(205),   NVIG opregion address
    Offset(209),    NVHA, 32, // Offset(209),   NVHM opregion address
    Offset(213),    AMDA, 32, // Offset(213),   AMDA opregion address
    Offset(217),    LTRX, 8,  // Offset(217),   Latency Tolerance Reporting Enable
    Offset(218),    OBFX, 8,  // Offset(218),   Optimized Buffer Flush and Fill
    Offset(219),    LTRY, 8,  // Offset(219),   Latency Tolerance Reporting Enable
    Offset(220),    OBFY, 8,  // Offset(220),   Optimized Buffer Flush and Fill
    Offset(221),    LTRZ, 8,  // Offset(221),   Latency Tolerance Reporting Enable
    Offset(222),    OBFZ, 8,  // Offset(222),   Optimized Buffer Flush and Fill
    Offset(223),    LTRW, 8,  // Offset(223),   Latency Tolerance Reporting Enable
    Offset(224),    OBFA, 8,  // Offset(224),   Optimized Buffer Flush and Fill
    Offset(225),    SMSL, 16, // Offset(225),   SA Peg Latency Tolerance Reporting Max Snoop Latency
    Offset(227),    SNSL, 16, // Offset(227),   SA Peg Latency Tolerance Reporting Max No Snoop Latency
    Offset(229),    M64B, 64, // Offset(229),   Base of above 4GB MMIO resource
    Offset(237),    M64L, 64, // Offset(237),   Length of above 4GB MMIO resource
    Offset(245),    CPEX, 32, // Offset(245),   CPU ID info to get Family Id or Stepping
    Offset(249),    M32B, 32, // Offset(249),   Base of below 4GB MMIO resource
    Offset(253),    M32L, 32, // Offset(253),   Length of below 4GB MMIO resource
    Offset(257),    P0WK, 32, // Offset(257),   PCIe0 RTD3 Device Wake GPIO Number
    Offset(261),    P1WK, 32, // Offset(261),   PCIe1 RTD3 Device Wake GPIO Number
    Offset(265),    P2WK, 32, // Offset(265),   PCIe2 RTD3 Device Wake GPIO Number
    Offset(269),    VTDS, 8,  // Offset(269),   VT-d Enable/Disable
    Offset(270),    VTB1, 32, // Offset(270),   VT-d Base Address 1
    Offset(274),    VTB2, 32, // Offset(274),   VT-d Base Address 2
    Offset(278),    VTB3, 32, // Offset(278),   VT-d Base Address 3
    Offset(282),    VTB4, 32, // Offset(282),   VT-d Base Address 4 (iTBT PCIE0)
    Offset(286),    VTB5, 32, // Offset(286),   VT-d Base Address 5 (iTBT PCIE1)
    Offset(290),    VTB6, 32, // Offset(290),   VT-d Base Address 6 (iTBT PCIE2)
    Offset(294),    VTB7, 32, // Offset(294),   VT-d Base Address 7 (iTBT PCIE3)
    Offset(298),    VE1V, 16, // Offset(298),   VT-d Engine#1 Vendor ID
    Offset(300),    VE2V, 16, // Offset(300),   VT-d Engine#2 Vendor ID
    Offset(302),    RPIN, 8,  // Offset(302),   RootPort Number
    Offset(303),    RPBA, 32, // Offset(303),   RootPortAddress
    Offset(307),    CTHM, 8,  // Offset(307),   CPU Trace Hub Mode
    Offset(308),    SIME, 8,  // Offset(308),   Simics Environment information
    Offset(309),    THCE, 8,  // Offset(309),   TCSS XHCI Device Enable
    Offset(310),    TDCE, 8,  // Offset(310),   TCSS XDCI Device Enable
    Offset(311),    DME0, 8,  // Offset(311),   TCSS DMA 0 Device Enable
    Offset(312),    DME1, 8,  // Offset(312),   TCSS DMA 1 Device Enable
    Offset(313),    TRE0, 8,  // Offset(313),   TCSS ItbtPcieRp PCIE RP 0 Device Enable
    Offset(314),    TRE1, 8,  // Offset(314),   TCSS ItbtPcieRp PCIE RP 1 Device Enable
    Offset(315),    TRE2, 8,  // Offset(315),   TCSS ItbtPcieRp PCIE RP 2 Device Enable
    Offset(316),    TRE3, 8,  // Offset(316),   TCSS ItbtPcieRp PCIE RP 3 Device Enable
    Offset(317),    TPA0, 32, // Offset(317),   TCSS ItbtPcie Root Port address 0
    Offset(321),    TPA1, 32, // Offset(321),   TCSS ItbtPcie Root Port address 1
    Offset(325),    TPA2, 32, // Offset(325),   TCSS ItbtPcie Root Port address 2
    Offset(329),    TPA3, 32, // Offset(329),   TCSS ItbtPcie Root Port address 3
    Offset(333),    TCDS, 32, // Offset(333),   TCSS xDCI Power Down Scale Value, DWC_USB3_GCTL_INIT[31:19]
    Offset(337),    TCIT, 8,  // Offset(337),   TCSS xDCI Int Pin
    Offset(338),    TCIR, 8,  // Offset(338),   TCSS xDCI Irq Number
    Offset(339),    TRTD, 8,  // Offset(339),   TCSS RTD3
    Offset(340),    ITM0, 32, // Offset(340),   TCSS DMA0 RMRR address
    Offset(344),    ITM1, 32, // Offset(344),   TCSS DMA1 RMRR address
    Offset(348),    LTE0, 8,  // Offset(348),   Latency Tolerance Reporting Mechanism. <b>0: Disable</b>; 1: Enable.
    Offset(349),    LTE1, 8,  // Offset(349),   Latency Tolerance Reporting Mechanism. <b>0: Disable</b>; 1: Enable.
    Offset(350),    LTE2, 8,  // Offset(350),   Latency Tolerance Reporting Mechanism. <b>0: Disable</b>; 1: Enable.
    Offset(351),    LTE3, 8,  // Offset(351),   Latency Tolerance Reporting Mechanism. <b>0: Disable</b>; 1: Enable.
    Offset(352),    PSL0, 16, // Offset(352),   PCIE LTR max snoop Latency 0
    Offset(354),    PSL1, 16, // Offset(354),   PCIE LTR max snoop Latency 1
    Offset(356),    PSL2, 16, // Offset(356),   PCIE LTR max snoop Latency 2
    Offset(358),    PSL3, 16, // Offset(358),   PCIE LTR max snoop Latency 3
    Offset(360),    PNS0, 16, // Offset(360),   PCIE LTR max no snoop Latency 0
    Offset(362),    PNS1, 16, // Offset(362),   PCIE LTR max no snoop Latency 1
    Offset(364),    PNS2, 16, // Offset(364),   PCIE LTR max no snoop Latency 2
    Offset(366),    PNS3, 16, // Offset(366),   PCIE LTR max no snoop Latency 3
    Offset(368),    IMRY, 8,  // Offset(368),   IOM Ready
    Offset(369),    TIVS, 8,  // Offset(369),   TCSS IOM VccSt
    Offset(370),    PG0E, 8,  // Offset(370),   <0:Disabled, 1:Enabled>
    Offset(371),    PG1E, 8,  // Offset(371),   <0:Disabled, 1:Enabled>
    Offset(372),    PG2E, 8,  // Offset(372),   <0:Disabled, 1:Enabled>
    Offset(373),    PG3E, 8,  // Offset(373),   <0:Disabled, 1:Enabled>
    Offset(374),    VMDE, 8,  // Offset(374),   VMD Device Enable
    Offset(375),    DIDY, 32, // Offset(375),   Device ID for second LFP device
    Offset(379),    NXDY, 32, // Offset(379),   Next state DID for Second Display
    Offset(383),    SLTS, 8,  // Offset(383),   PCIe slot selection
    Offset(384),    VMR1, 8,  // Offset(384),   VMD PCH RP 1 to 8 mapped under VMD
    Offset(385),    VMR2, 8,  // Offset(385),   VMD PCH RP 9 to 16 mapped under VMD
    Offset(386),    VMR3, 8,  // Offset(386),   VMD PCH RP 17 to 24 mapped under VMD
    Offset(387),    VMR4, 8,  // Offset(387),   VMD PCH RP 25 to 32 mapped under VMD
    Offset(388),    VMS0, 8,  // Offset(388),   VMD SATA PORT 0 to 7 mapped under VMD
    Offset(389),    VMCP, 8,  // Offset(389),   VMD CPU RP mapped under VMD
    Offset(390),    CPRT, 8,  // Offset(390),   RTD3 Support for CPU PCIE.
    Offset(391),    CSLU, 32, // Offset(391),   Lane Used of each CSI Port <0:Not Configured, 1:x1, 2:x2, 3:x3 4:x4>
    Offset(395),    CSSP, 32, // Offset(395),   Speed of each CSI Port <0:Not configured, 1:<416GMbps, 2:<1.5Gbps, 3:<2.0Gbps, 4:<2.5Gbps, 5:<4Gbps, 6:>4Gbps>
    Offset(399),    MPGN, 8,  // Offset(399),   Max PEG port number
    Offset(400),    CMBM, 8,  // Offset(400),   Current Memory Boot Mode <0: BOOT_MODE_1LM(Default), 1: BOOT_MODE_2LM, 2: BOOT_MODE_PROVISION>
    Offset(401),    DPMS, 8,  // Offset(401),   Dynamic PMem Support <0: Disabled, 1:Enabled>
    Offset(402),    PMSA, 64, // Offset(402),   Private Pmem Starting address
    Offset(410),    PMRL, 64, // Offset(410),   Private Pmem Range Length
    Offset(418),    PBR1, 8,  // Offset(418),   Is bridge device behind Peg1
    Offset(419),    PBR2, 8,  // Offset(419),   Is bridge device behind Peg2
    Offset(420),    PBR3, 8,  // Offset(420),   Is bridge device behind Peg3
    Offset(421),    PPA0, 32, // Offset(421),   CpuPcieRp Address 1
    Offset(425),    PPA1, 32, // Offset(425),   CpuPcieRp address 2
    Offset(429),    PPA2, 32, // Offset(429),   CpuPcieRp address 3
    Offset(433),    PPA3, 32, // Offset(433),   CpuPcieRp Address 4
    Offset(437),    REGO, 16, // Offset(437),   MCH RegBar Offset
    }

  /** @file
    This file contains the device definition of the System Agent
    ACPI reference code.
    Currently defines the device objects for the
    System Agent PCI Express* ports (PEG), iGfx and other devices.
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  External(\_SB.PC00, DeviceObj)
  External(\_SB.PC00.GFX0, DeviceObj)
  External(\_SB.PC00.IPU0, DeviceObj)
  External(\_SB.PC00.B0D3, DeviceObj)
  External(\_SB.PC00.PCIC, MethodObj)
  External(\_SB.PC00.PCID, MethodObj)
  
  ///
  /// CPU PCIe Root Port
  ///
  /** @file
    This file contains the CPU PCIe Root Port configuration
  
    Copyright (c) 2021 - 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  External(LTRX) // CPU PCIe Root Port 0 Latency Tolerance Reporting Enable
  External(LTRY) // CPU PCIe Root Port 1 Latency Tolerance Reporting Enable
  External(LTRZ) // CPU PCIe Root Port 2 Latency Tolerance Reporting Enable
  External(LTRW) // CPU PCIe Root Port 3 Latency Tolerance Reporting Enable
  External(SMSL) // CPU PCIe Root Port Latency Tolerance Reporting Max Snoop Latency
  External(SNSL) // CPU PCIe Root Port Latency Tolerance Reporting Max No Snoop Latency
  External(PG0E) // CpuPcieRp0Enable <b>0: Disable</b>; 1: Enable
  External(PG1E) // CpuPcieRp1Enable <b>0: Disable</b>; 1: Enable
  External(PG2E) // CpuPcieRp2Enable <b>0: Disable</b>; 1: Enable
  External(PG3E) // CpuPcieRp3Enable <b>0: Disable</b>; 1: Enable
  External(\_SB.PC00.PEG0, DeviceObj)
  External(\_SB.PC00.PEG0._ADR, MethodObj)
  External(\_SB.PC00.PEG1, DeviceObj)
  External(\_SB.PC00.PEG1._ADR, MethodObj)
  External(\_SB.PC00.PEG2, DeviceObj)
  External(\_SB.PC00.PEG2._ADR, MethodObj)
  External(\_SB.PC00.PEG3, DeviceObj)
  External(\_SB.PC00.PEG3._ADR, MethodObj)
  External(\_SB.PC00.PEG0.PEGP, DeviceObj)
  External(\_SB.PC00.PEG1.PEGP, DeviceObj)
  External(\_SB.PC00.PEG2.PEGP, DeviceObj)
  External(\_SB.PC00.PEG3.PEGP, DeviceObj)
  External(\AR02)
  External(\PD02)
  External(\AR0A)
  External(\PD0A)
  External(\AR0B)
  External(\PD0B)
  External(\AR0C)
  External(\PD0C)
  External(VMDE)
  External(VMCP)
  //External(MPGN)
  External(PINI, MethodObj) // Platform specific PCIe root port initialization.
  External(PBR1)
  External(PBR2)
  External(PBR3)
  External(\STD3, FieldUnitObj) // 1: D3Cold support for Storage 0: D3Hot support for Storage.
  External(\PPA0, IntObj)
  External(\PPA1, IntObj)
  External(\PPA2, IntObj)
  External(\PPA3, IntObj)
  External(CPID)
  
  Scope (\_SB.PC00.PEG0) {
  
    Name(SLOT, 0) // CPU PCIe root port index 0 corresponds to PEG60 (0/6/0)
  
    Method (CPRA, 0x0, NotSerialized) {
      If(LNotEqual(\PPA0,0)) {
        Return (\PPA0)
      } Else {
        Return (0x00060000)
      }
    }
  
    Method (_STA, 0x0, NotSerialized) {
      if(PG0E == 1) { // If CPU PCIe RP0 enabled?
        Return(0x0F)
      }
      Return(0x00)
    }
  
    Name(LTEN, 0)
    Name(LMSL, 0)
    Name(LNSL, 0)
  
    Method(_INI)
    {
      If(PRES()) {
        Store (LTRX, LTEN)
        Store (SMSL, LMSL)
        Store (SNSL, LNSL)
        If(CondRefOf(PINI)) {PINI()}
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        #define CPU_PCIE_ROOT_PORT  \_SB.PC00.PEG0
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to CPU PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
              External(CPU_PCIE_ROOT_PORT.PEGP.PNVM, MethodObj, IntObj)
              External(CPU_PCIE_ROOT_PORT.PEGP.PAHC, MethodObj, IntObj)
              External(CPU_PCIE_ROOT_PORT.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(CPU_PCIE_ROOT_PORT)) {
                If(LNotEqual(CPU_PCIE_ROOT_PORT.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(CPU_PCIE_ROOT_PORT.PRMV)) {
                      If (LEqual (CPU_PCIE_ROOT_PORT.PRMV, 1)) {
                        Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                      }
                    }
        
                    If(LOr(CPU_PCIE_ROOT_PORT.PEGP.PNVM(),CPU_PCIE_ROOT_PORT.PEGP.PAHC())) {
                      Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                    }
                  }
                }
              }

        #undef CPU_PCIE_ROOT_PORT
      }
    }
  
    Method(_PRT,0) {
      If(PICM) {
        Return(AR02)
      } // APIC mode
      Return (PD02) // PIC Mode
    } // end _PRT
  
    /** @file
      This file contains the PCIe Root Port Common configuration
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External(ECR1)
      External(GPRW, MethodObj)
      External(PICM)
      External(\_SB.PC00.PC2M, MethodObj)
      External(PPBA, MethodObj) // PCIe power budget allocation
      External(UPRD, MethodObj) // PCIe update PERST# assertion delay
      External(ATSC)
      External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
      External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
    
      Name (PRTP, PCIE_RP_TYPE_CPU) // PCIE RP TYPE
    
      OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR ()),0x480)
      Field(PXCS,AnyAcc, NoLock, Preserve)
      {
        Offset(0),
        VDID, 32,
        Offset(0x50),                      // LCTL - Link Control Register
        L0SE, 1,                           // 0, L0s Entry Enabled
        , 3,
        LDIS, 1,
        , 3,
        Offset(0x52),                      // LSTS - Link Status Register
        , 13,
        LASX, 1,                           // 0, Link Active Status
        Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
        ABPX, 1,                           // 0, Attention Button Pressed
        , 2,
        PDCX, 1,                           // 3, Presence Detect Changed
        , 2,
        PDSX, 1,                           // 6, Presence Detect State
        , 1,
        Offset(0x60),                      // RSTS - Root Status Register
        , 16,
        PSPX, 1,                           // 16,  PME Status
        Offset(0xA4),                      // PMCSR
        D3HT, 2,                           // PowerState
        Offset(0xD8), // 0xD8, MPC - Miscellaneous Port Configuration Register
        , 30,
        HPEX, 1,                           // 30,  Hot Plug SCI Enable
        PMEX, 1,                           // 31,  Power Management SCI Enable
        Offset(0xE0), // 0xE0, SPR - Scratch Pad Register
        SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
        , 6,
        NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
        Offset(0xE2), // 0xE2, RPPGEN - Root Port Power Gating Enable
        , 2,
        L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
        L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
        Offset(0x324), // 0x324 - PCIEDBG
        , 3,
        LEDM, 1,       // PCIEDBG.DMIL1EDM
        Offset(0x328),                     // 0x328, PCI Express Status 1
        , 24,
        LTSM, 8,
      }
      Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
      {
        Offset(0xDC), // 0xDC, SMSCS - SMI/SCI Status Register
        , 30,
        HPSX, 1,                           // 30,  Hot Plug SCI Status
        PMSX, 1                            // 31,  Power Management SCI Status
      }
    
      //
      // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
      // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
      // are proprietary and OS drivers don't know about them.
      //
      Method (L23D, 0, Serialized) {
        If(LNotEqual(SCB0,0x1)) {
          Return()
        }
    
        /// Set L23_Rdy to Detect Transition  (L23R2DT)
        Store(1, L23R)
        Store(0, Local0)
        /// Wait for transition to Detect
        While(L23R) {
          If(Lgreater(Local0, 4))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
        Store(0,SCB0)
    
        /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
        /// Worst case per PCIe spec from Detect to Link Active is:
        /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
        Store(0, Local0)
        While(LEqual(LASX,0)) {
          If(Lgreater(Local0, 8))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
      }
    
      //
      // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
      // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
      // are proprietary and OS drivers don't know about them.
      //
      Method (DL23, 0, Serialized) {
        Store(1, L23E)
        Sleep(16)
        Store(0, Local0)
        While(L23E) {
          If(Lgreater(Local0, 4))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
        Store(1,SCB0)
      }
    
      Name(LTRV, Package(){0,0,0,0})
      Name(PRMV, 0) // PCIE Rp Mapped under VMD
      Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
    
      //
      // Check if root port is present.
      // @return 0: root port is disabled, 1: root port is enabled
      //
      Method(PRES) {
        If (LEqual (VDID, 0xFFFFFFFF)) {
          Return(0)
        } Else {
          Return(1)
        }
      }
    
      //
      // _DSM Device Specific Method
      //
      // Arg0: UUID Unique function identifier
      // Arg1: Integer Revision Level
      // Arg2: Integer Function Index (0 = Return Supported Functions)
      // Arg3: Package Parameters
      Method(_DSM, 4, Serialized) {
        //
        // Switch based on which unique function identifier was passed in
        //
        If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
          //
          // _DSM Definitions for Latency Tolerance Reporting
          //
          // Arguments:
          // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
          // Arg1: Revision ID: 3
          // Arg2: Function Index: 0, 6, 8, 9
          // Arg3: Empty Package
          //
          // Switch by function index
          //
          Switch(ToInteger(Arg2)) {
            //
            // Function Index:0
            // Standard query - A bitmask of functions supported
            //
            Case (0) {
              Name(OPTS,Buffer(2){0,0})
              CreateBitField(OPTS,0,FUN0)
              CreateBitField(OPTS,6,FUN6)
              CreateBitField(OPTS,8,FUN8)
              CreateBitField(OPTS,9,FUN9)
              CreateBitField(OPTS,10,FUNA)
              CreateBitField(OPTS,11,FUNB)
    
              if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                Store(1,FUN0)
                if (LNotEqual (LTEN, 0)) {
                  Store(1,FUN6)
                }
    
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                      Store(1,FUN8)
                      Store(1,FUN9)
                    }
                  }
                }
              }
    
              If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                If(CondRefOf(PPBA)) {
                  Store(1,FUNA)
                }
                If(CondRefOf(UPRD)) {
                  Store(1,FUNB)
                }
              }
              Return (OPTS)
            }
    
            //
            // Function Index: 6
            // LTR Extended Capability Structure
            //
            Case(6) {
              if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                Store(And(LMSL,0x3FF), Index(LTRV, 1))
                Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                Store(And(LNSL,0x3FF), Index(LTRV, 3))
                Return (LTRV)
              }
            }
            Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
              If(CondRefOf(ECR1)) {
                if(LEqual(ECR1,1)){
                  if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                    return (1)
                  }
                }
              }
            }
            Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
              If(CondRefOf(ECR1)) {
                if(LEqual(ECR1,1)){
                  if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                    return(Package(5){50000,Ones,Ones,50000,Ones})
                  }
                }
              }
            }
            //
            //  Function index 10 - negotiate device auxilary power consumption.
            //
            Case(10) {
              If(CondRefOf(PPBA)) {
                Return(PPBA(Arg3))
              }
            }
            //
            // Function index 11 update delay between PME_TO_Ack and PERST# assertion
            //
            Case(11) {
              If(CondRefOf(UPRD)) {
                Return(UPRD(Arg3))
              }
            }
          } // End of switch(Arg2)
        } // End of if
        return (Buffer() {0x00})
      } // End of _DSM
    
      Method(_PRW, 0) {
        Return(GPRW(0x69, 4)) // can wakeup from S4 state
      }
    
      Method (_PS0, 0, Serialized)
      {
        If (LEqual (HPEX, 1)) {
          Store (0, HPEX) // Disable Hot Plug SCI
          Store (1, HPSX) // Clear Hot Plug SCI status
        }
        If (LEqual (PMEX, 1)) {
          Store (0, PMEX) // Disable Power Management SCI
          Store (1, PMSX) // Clear Power Management SCI status
        }
        If (CondRefOf (PPS0)) {
          PPS0 ()
        }
      }
      Method (_PS3, 0, Serialized)
      {
        If (CondRefOf (PPS3)) {
          PPS3 ()
        }
        If (LEqual (HPEX, 0)) {
          Store(1, HPEX) // Enable Hot Plug SCI
          Store(1, HPSX) // Clear Hot Plug SCI status
        }
        If (LEqual(PMEX, 0)) {
          Store(1, PMEX) // Enable Power Management SCI
          Store(1, PMSX) // Clear Power Management SCI status
        }
      }
    
      Method (_DSD, 0) {
        If(CondRefOf(PINI)) {
          Return (
            Package () {
              ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
              Package () {
                Package (2) {"HotPlugSupportInD3", 1},
              },
              ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
              Package () {
                Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
              },
              // This _DSD object informs Windows PCIe bus driver that
              // this root ports supports auxilary power budgeting.
              ToUUID("6B4AD420-8FD3-4364-ACF8-EB94876FD9EB"),
              Package () {
              },
              // This informs driver that PTM ART is traceble to TSC
              ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
              Package () {
              }
            }
          ) //End of Return ()
        } else {
          Return (
            Package () {
              ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
              Package () {
                Package (2) {"HotPlugSupportInD3", 1},
              },
              ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
              Package () {
                Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
              },
              // This informs driver that PTM ART is traceble to TSC
              ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
              Package () {
              }
            }
          ) // End of Return ()
        }
      }
    
      //
      // PCI_EXP_STS Handler for PCIE Root Port
      //
      Method(HPME,0,Serialized) {
        If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
          Store(1,PMSX) // clear rootport's PME SCI status
          Store(1,PSPX) // consume one pending PME status to prevent it from blocking the queue
          Return(0x01)
        }
        Return(0x00)
      }
    
      //
      // Sub-Method of _L61 Hot-Plug event
      // _L61 event handler should invoke this method to support HotPlug wake event from PEG RP
      //
      Method(HPEV,0,Serialized) {
        If(LAnd(LNotEqual(VDID,0xFFFFFFFF), HPSX)) {
          // Clear HotPlug SCI event status
          Store(1, HPSX)
    
          If(LEqual(PDCX, 1)) {
            // Clear Presence Detect Changed
            Store(1,PDCX)
    
            If(LEqual(PDSX, 0)) {
              // The PCI Express slot is empty, so disable L0s on hot unplug
              //
              Store(0,L0SE)
            }
            // Perform proper notification
            // to the OS.
            Notify(^,0)
          }
        }
      }

  } // PEG0 scope end
  
  Scope (\_SB.PC00.PEG1) {
  
    Name(SLOT, 1) // CPU PCIe root port index 1 corresponds to PEG10 (0/1/0)
  
    Method (CPRA, 0x0, NotSerialized) {
      If(LNotEqual(\PPA1,0)) {
        Return (\PPA1)
      } Else {
        Return (0x00010000)
      }
    }
  
    Method (_STA, 0x0, NotSerialized) {
      if(PG1E == 1) { // If CPU PCIe RP1 enabled?
        Return(0x0F)
      }
      Return(0x00)
    }
  
    Name(LTEN, 0)
    Name(LMSL, 0)
    Name(LNSL, 0)
  
    Method(_INI)
    {
      If(PRES()) {
        Store (LTRY, LTEN)
        Store (SMSL, LMSL)
        Store (SNSL, LNSL)
        If(CondRefOf(PINI)) {PINI()}
        If(LAnd(CondRefOf(VMCP),CondRefOf(VMDE))) {
          If(LAnd(LEqual(VMDE,1),LNotEqual(And(VMCP,0x1),0))) {
            Store (1, PRMV)
          }
        }
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        #define CPU_PCIE_ROOT_PORT  \_SB.PC00.PEG1
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to CPU PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
              External(CPU_PCIE_ROOT_PORT.PEGP.PNVM, MethodObj, IntObj)
              External(CPU_PCIE_ROOT_PORT.PEGP.PAHC, MethodObj, IntObj)
              External(CPU_PCIE_ROOT_PORT.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(CPU_PCIE_ROOT_PORT)) {
                If(LNotEqual(CPU_PCIE_ROOT_PORT.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(CPU_PCIE_ROOT_PORT.PRMV)) {
                      If (LEqual (CPU_PCIE_ROOT_PORT.PRMV, 1)) {
                        Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                      }
                    }
        
                    If(LOr(CPU_PCIE_ROOT_PORT.PEGP.PNVM(),CPU_PCIE_ROOT_PORT.PEGP.PAHC())) {
                      Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                    }
                  }
                }
              }

        #undef CPU_PCIE_ROOT_PORT
      }
    }
  
    Method(_PRT,0) {
      If(PICM) {
        Return(AR02)
      } // APIC mode
      Return (PD02) // PIC Mode
    } // end _PRT
  
    /** @file
      This file contains the PCIe Root Port Common configuration
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External(ECR1)
      External(GPRW, MethodObj)
      External(PICM)
      External(\_SB.PC00.PC2M, MethodObj)
      External(PPBA, MethodObj) // PCIe power budget allocation
      External(UPRD, MethodObj) // PCIe update PERST# assertion delay
      External(ATSC)
      External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
      External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
    
      Name (PRTP, PCIE_RP_TYPE_CPU) // PCIE RP TYPE
    
      OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR ()),0x480)
      Field(PXCS,AnyAcc, NoLock, Preserve)
      {
        Offset(0),
        VDID, 32,
        Offset(0x50),                      // LCTL - Link Control Register
        L0SE, 1,                           // 0, L0s Entry Enabled
        , 3,
        LDIS, 1,
        , 3,
        Offset(0x52),                      // LSTS - Link Status Register
        , 13,
        LASX, 1,                           // 0, Link Active Status
        Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
        ABPX, 1,                           // 0, Attention Button Pressed
        , 2,
        PDCX, 1,                           // 3, Presence Detect Changed
        , 2,
        PDSX, 1,                           // 6, Presence Detect State
        , 1,
        Offset(0x60),                      // RSTS - Root Status Register
        , 16,
        PSPX, 1,                           // 16,  PME Status
        Offset(0xA4),                      // PMCSR
        D3HT, 2,                           // PowerState
        Offset(0xD8), // 0xD8, MPC - Miscellaneous Port Configuration Register
        , 30,
        HPEX, 1,                           // 30,  Hot Plug SCI Enable
        PMEX, 1,                           // 31,  Power Management SCI Enable
        Offset(0xE0), // 0xE0, SPR - Scratch Pad Register
        SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
        , 6,
        NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
        Offset(0xE2), // 0xE2, RPPGEN - Root Port Power Gating Enable
        , 2,
        L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
        L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
        Offset(0x324), // 0x324 - PCIEDBG
        , 3,
        LEDM, 1,       // PCIEDBG.DMIL1EDM
        Offset(0x328),                     // 0x328, PCI Express Status 1
        , 24,
        LTSM, 8,
      }
      Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
      {
        Offset(0xDC), // 0xDC, SMSCS - SMI/SCI Status Register
        , 30,
        HPSX, 1,                           // 30,  Hot Plug SCI Status
        PMSX, 1                            // 31,  Power Management SCI Status
      }
    
      //
      // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
      // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
      // are proprietary and OS drivers don't know about them.
      //
      Method (L23D, 0, Serialized) {
        If(LNotEqual(SCB0,0x1)) {
          Return()
        }
    
        /// Set L23_Rdy to Detect Transition  (L23R2DT)
        Store(1, L23R)
        Store(0, Local0)
        /// Wait for transition to Detect
        While(L23R) {
          If(Lgreater(Local0, 4))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
        Store(0,SCB0)
    
        /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
        /// Worst case per PCIe spec from Detect to Link Active is:
        /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
        Store(0, Local0)
        While(LEqual(LASX,0)) {
          If(Lgreater(Local0, 8))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
      }
    
      //
      // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
      // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
      // are proprietary and OS drivers don't know about them.
      //
      Method (DL23, 0, Serialized) {
        Store(1, L23E)
        Sleep(16)
        Store(0, Local0)
        While(L23E) {
          If(Lgreater(Local0, 4))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
        Store(1,SCB0)
      }
    
      Name(LTRV, Package(){0,0,0,0})
      Name(PRMV, 0) // PCIE Rp Mapped under VMD
      Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
    
      //
      // Check if root port is present.
      // @return 0: root port is disabled, 1: root port is enabled
      //
      Method(PRES) {
        If (LEqual (VDID, 0xFFFFFFFF)) {
          Return(0)
        } Else {
          Return(1)
        }
      }
    
      //
      // _DSM Device Specific Method
      //
      // Arg0: UUID Unique function identifier
      // Arg1: Integer Revision Level
      // Arg2: Integer Function Index (0 = Return Supported Functions)
      // Arg3: Package Parameters
      Method(_DSM, 4, Serialized) {
        //
        // Switch based on which unique function identifier was passed in
        //
        If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
          //
          // _DSM Definitions for Latency Tolerance Reporting
          //
          // Arguments:
          // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
          // Arg1: Revision ID: 3
          // Arg2: Function Index: 0, 6, 8, 9
          // Arg3: Empty Package
          //
          // Switch by function index
          //
          Switch(ToInteger(Arg2)) {
            //
            // Function Index:0
            // Standard query - A bitmask of functions supported
            //
            Case (0) {
              Name(OPTS,Buffer(2){0,0})
              CreateBitField(OPTS,0,FUN0)
              CreateBitField(OPTS,6,FUN6)
              CreateBitField(OPTS,8,FUN8)
              CreateBitField(OPTS,9,FUN9)
              CreateBitField(OPTS,10,FUNA)
              CreateBitField(OPTS,11,FUNB)
    
              if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                Store(1,FUN0)
                if (LNotEqual (LTEN, 0)) {
                  Store(1,FUN6)
                }
    
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                      Store(1,FUN8)
                      Store(1,FUN9)
                    }
                  }
                }
              }
    
              If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                If(CondRefOf(PPBA)) {
                  Store(1,FUNA)
                }
                If(CondRefOf(UPRD)) {
                  Store(1,FUNB)
                }
              }
              Return (OPTS)
            }
    
            //
            // Function Index: 6
            // LTR Extended Capability Structure
            //
            Case(6) {
              if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                Store(And(LMSL,0x3FF), Index(LTRV, 1))
                Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                Store(And(LNSL,0x3FF), Index(LTRV, 3))
                Return (LTRV)
              }
            }
            Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
              If(CondRefOf(ECR1)) {
                if(LEqual(ECR1,1)){
                  if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                    return (1)
                  }
                }
              }
            }
            Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
              If(CondRefOf(ECR1)) {
                if(LEqual(ECR1,1)){
                  if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                    return(Package(5){50000,Ones,Ones,50000,Ones})
                  }
                }
              }
            }
            //
            //  Function index 10 - negotiate device auxilary power consumption.
            //
            Case(10) {
              If(CondRefOf(PPBA)) {
                Return(PPBA(Arg3))
              }
            }
            //
            // Function index 11 update delay between PME_TO_Ack and PERST# assertion
            //
            Case(11) {
              If(CondRefOf(UPRD)) {
                Return(UPRD(Arg3))
              }
            }
          } // End of switch(Arg2)
        } // End of if
        return (Buffer() {0x00})
      } // End of _DSM
    
      Method(_PRW, 0) {
        Return(GPRW(0x69, 4)) // can wakeup from S4 state
      }
    
      Method (_PS0, 0, Serialized)
      {
        If (LEqual (HPEX, 1)) {
          Store (0, HPEX) // Disable Hot Plug SCI
          Store (1, HPSX) // Clear Hot Plug SCI status
        }
        If (LEqual (PMEX, 1)) {
          Store (0, PMEX) // Disable Power Management SCI
          Store (1, PMSX) // Clear Power Management SCI status
        }
        If (CondRefOf (PPS0)) {
          PPS0 ()
        }
      }
      Method (_PS3, 0, Serialized)
      {
        If (CondRefOf (PPS3)) {
          PPS3 ()
        }
        If (LEqual (HPEX, 0)) {
          Store(1, HPEX) // Enable Hot Plug SCI
          Store(1, HPSX) // Clear Hot Plug SCI status
        }
        If (LEqual(PMEX, 0)) {
          Store(1, PMEX) // Enable Power Management SCI
          Store(1, PMSX) // Clear Power Management SCI status
        }
      }
    
      Method (_DSD, 0) {
        If(CondRefOf(PINI)) {
          Return (
            Package () {
              ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
              Package () {
                Package (2) {"HotPlugSupportInD3", 1},
              },
              ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
              Package () {
                Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
              },
              // This _DSD object informs Windows PCIe bus driver that
              // this root ports supports auxilary power budgeting.
              ToUUID("6B4AD420-8FD3-4364-ACF8-EB94876FD9EB"),
              Package () {
              },
              // This informs driver that PTM ART is traceble to TSC
              ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
              Package () {
              }
            }
          ) //End of Return ()
        } else {
          Return (
            Package () {
              ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
              Package () {
                Package (2) {"HotPlugSupportInD3", 1},
              },
              ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
              Package () {
                Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
              },
              // This informs driver that PTM ART is traceble to TSC
              ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
              Package () {
              }
            }
          ) // End of Return ()
        }
      }
    
      //
      // PCI_EXP_STS Handler for PCIE Root Port
      //
      Method(HPME,0,Serialized) {
        If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
          Store(1,PMSX) // clear rootport's PME SCI status
          Store(1,PSPX) // consume one pending PME status to prevent it from blocking the queue
          Return(0x01)
        }
        Return(0x00)
      }
    
      //
      // Sub-Method of _L61 Hot-Plug event
      // _L61 event handler should invoke this method to support HotPlug wake event from PEG RP
      //
      Method(HPEV,0,Serialized) {
        If(LAnd(LNotEqual(VDID,0xFFFFFFFF), HPSX)) {
          // Clear HotPlug SCI event status
          Store(1, HPSX)
    
          If(LEqual(PDCX, 1)) {
            // Clear Presence Detect Changed
            Store(1,PDCX)
    
            If(LEqual(PDSX, 0)) {
              // The PCI Express slot is empty, so disable L0s on hot unplug
              //
              Store(0,L0SE)
            }
            // Perform proper notification
            // to the OS.
            Notify(^,0)
          }
        }
      }

  } // PEG1 scope end
  
  Scope (\_SB.PC00.PEG2) {
  
    Name(SLOT, 2)
  
    Method (CPRA, 0x0, NotSerialized) {
      If (LNotEqual(\PPA2,0)) {
        Return (\PPA2)
      } Else {
        Return (0x00060002)
      }
    }
  
    Method (_STA, 0x0, NotSerialized) {
      if(PG2E == 1) { // If CPU PCIe RP2 enabled?
        Return(0x0F)
      }
      Return(0x00)
    }
  
    Name(LTEN, 0)
    Name(LMSL, 0)
    Name(LNSL, 0)
  
    Method(_INI)
    {
      If(PRES()) {
        Store (LTRZ, LTEN)
        Store (SMSL, LMSL)
        Store (SNSL, LNSL)
        If(CondRefOf(PINI)) {PINI()}
        If(LAnd(CondRefOf(VMCP),CondRefOf(VMDE))) {
          If(LAnd(LEqual(VMDE,1),LNotEqual(And(VMCP,0x2),0))) {
            Store (1, PRMV)
          }
        }
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        #define CPU_PCIE_ROOT_PORT  \_SB.PC00.PEG2
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to CPU PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
              External(CPU_PCIE_ROOT_PORT.PEGP.PNVM, MethodObj, IntObj)
              External(CPU_PCIE_ROOT_PORT.PEGP.PAHC, MethodObj, IntObj)
              External(CPU_PCIE_ROOT_PORT.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(CPU_PCIE_ROOT_PORT)) {
                If(LNotEqual(CPU_PCIE_ROOT_PORT.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(CPU_PCIE_ROOT_PORT.PRMV)) {
                      If (LEqual (CPU_PCIE_ROOT_PORT.PRMV, 1)) {
                        Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                      }
                    }
        
                    If(LOr(CPU_PCIE_ROOT_PORT.PEGP.PNVM(),CPU_PCIE_ROOT_PORT.PEGP.PAHC())) {
                      Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                    }
                  }
                }
              }

        #undef CPU_PCIE_ROOT_PORT
      }
    }
  
    Method(_PRT,0) {
      If (LEqual (And (CPID, 0xFFFFFFF0), 0x000906A0)) {
        //
        // For SIP based PCIe controllers, INTx swizzle should be based on per controller ports.
        // IRQ mapping should be same for the first root port of all controllers as per HW design.
        // Remaining root ports can have different mapping
        //
        If (PICM) {
          Return (AR02)
        } // APIC mode
        Return (PD02) // PIC Mode
      } Else {
        If(PICM) {
          Return(AR0A)
        } // APIC mode
        Return (PD0A) // PIC Mode
      }
    } // end _PRT
  
    /** @file
      This file contains the PCIe Root Port Common configuration
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External(ECR1)
      External(GPRW, MethodObj)
      External(PICM)
      External(\_SB.PC00.PC2M, MethodObj)
      External(PPBA, MethodObj) // PCIe power budget allocation
      External(UPRD, MethodObj) // PCIe update PERST# assertion delay
      External(ATSC)
      External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
      External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
    
      Name (PRTP, PCIE_RP_TYPE_CPU) // PCIE RP TYPE
    
      OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR ()),0x480)
      Field(PXCS,AnyAcc, NoLock, Preserve)
      {
        Offset(0),
        VDID, 32,
        Offset(0x50),                      // LCTL - Link Control Register
        L0SE, 1,                           // 0, L0s Entry Enabled
        , 3,
        LDIS, 1,
        , 3,
        Offset(0x52),                      // LSTS - Link Status Register
        , 13,
        LASX, 1,                           // 0, Link Active Status
        Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
        ABPX, 1,                           // 0, Attention Button Pressed
        , 2,
        PDCX, 1,                           // 3, Presence Detect Changed
        , 2,
        PDSX, 1,                           // 6, Presence Detect State
        , 1,
        Offset(0x60),                      // RSTS - Root Status Register
        , 16,
        PSPX, 1,                           // 16,  PME Status
        Offset(0xA4),                      // PMCSR
        D3HT, 2,                           // PowerState
        Offset(0xD8), // 0xD8, MPC - Miscellaneous Port Configuration Register
        , 30,
        HPEX, 1,                           // 30,  Hot Plug SCI Enable
        PMEX, 1,                           // 31,  Power Management SCI Enable
        Offset(0xE0), // 0xE0, SPR - Scratch Pad Register
        SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
        , 6,
        NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
        Offset(0xE2), // 0xE2, RPPGEN - Root Port Power Gating Enable
        , 2,
        L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
        L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
        Offset(0x324), // 0x324 - PCIEDBG
        , 3,
        LEDM, 1,       // PCIEDBG.DMIL1EDM
        Offset(0x328),                     // 0x328, PCI Express Status 1
        , 24,
        LTSM, 8,
      }
      Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
      {
        Offset(0xDC), // 0xDC, SMSCS - SMI/SCI Status Register
        , 30,
        HPSX, 1,                           // 30,  Hot Plug SCI Status
        PMSX, 1                            // 31,  Power Management SCI Status
      }
    
      //
      // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
      // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
      // are proprietary and OS drivers don't know about them.
      //
      Method (L23D, 0, Serialized) {
        If(LNotEqual(SCB0,0x1)) {
          Return()
        }
    
        /// Set L23_Rdy to Detect Transition  (L23R2DT)
        Store(1, L23R)
        Store(0, Local0)
        /// Wait for transition to Detect
        While(L23R) {
          If(Lgreater(Local0, 4))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
        Store(0,SCB0)
    
        /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
        /// Worst case per PCIe spec from Detect to Link Active is:
        /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
        Store(0, Local0)
        While(LEqual(LASX,0)) {
          If(Lgreater(Local0, 8))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
      }
    
      //
      // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
      // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
      // are proprietary and OS drivers don't know about them.
      //
      Method (DL23, 0, Serialized) {
        Store(1, L23E)
        Sleep(16)
        Store(0, Local0)
        While(L23E) {
          If(Lgreater(Local0, 4))
          {
            Break
          }
          Sleep(16)
          Increment(Local0)
        }
        Store(1,SCB0)
      }
    
      Name(LTRV, Package(){0,0,0,0})
      Name(PRMV, 0) // PCIE Rp Mapped under VMD
      Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
    
      //
      // Check if root port is present.
      // @return 0: root port is disabled, 1: root port is enabled
      //
      Method(PRES) {
        If (LEqual (VDID, 0xFFFFFFFF)) {
          Return(0)
        } Else {
          Return(1)
        }
      }
    
      //
      // _DSM Device Specific Method
      //
      // Arg0: UUID Unique function identifier
      // Arg1: Integer Revision Level
      // Arg2: Integer Function Index (0 = Return Supported Functions)
      // Arg3: Package Parameters
      Method(_DSM, 4, Serialized) {
        //
        // Switch based on which unique function identifier was passed in
        //
        If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
          //
          // _DSM Definitions for Latency Tolerance Reporting
          //
          // Arguments:
          // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
          // Arg1: Revision ID: 3
          // Arg2: Function Index: 0, 6, 8, 9
          // Arg3: Empty Package
          //
          // Switch by function index
          //
          Switch(ToInteger(Arg2)) {
            //
            // Function Index:0
            // Standard query - A bitmask of functions supported
            //
            Case (0) {
              Name(OPTS,Buffer(2){0,0})
              CreateBitField(OPTS,0,FUN0)
              CreateBitField(OPTS,6,FUN6)
              CreateBitField(OPTS,8,FUN8)
              CreateBitField(OPTS,9,FUN9)
              CreateBitField(OPTS,10,FUNA)
              CreateBitField(OPTS,11,FUNB)
    
              if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                Store(1,FUN0)
                if (LNotEqual (LTEN, 0)) {
                  Store(1,FUN6)
                }
    
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                      Store(1,FUN8)
                      Store(1,FUN9)
                    }
                  }
                }
              }
    
              If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                If(CondRefOf(PPBA)) {
                  Store(1,FUNA)
                }
                If(CondRefOf(UPRD)) {
                  Store(1,FUNB)
                }
              }
              Return (OPTS)
            }
    
            //
            // Function Index: 6
            // LTR Extended Capability Structure
            //
            Case(6) {
              if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                Store(And(LMSL,0x3FF), Index(LTRV, 1))
                Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                Store(And(LNSL,0x3FF), Index(LTRV, 3))
                Return (LTRV)
              }
            }
            Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
              If(CondRefOf(ECR1)) {
                if(LEqual(ECR1,1)){
                  if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                    return (1)
                  }
                }
              }
            }
            Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
              If(CondRefOf(ECR1)) {
                if(LEqual(ECR1,1)){
                  if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                    return(Package(5){50000,Ones,Ones,50000,Ones})
                  }
                }
              }
            }
            //
            //  Function index 10 - negotiate device auxilary power consumption.
            //
            Case(10) {
              If(CondRefOf(PPBA)) {
                Return(PPBA(Arg3))
              }
            }
            //
            // Function index 11 update delay between PME_TO_Ack and PERST# assertion
            //
            Case(11) {
              If(CondRefOf(UPRD)) {
                Return(UPRD(Arg3))
              }
            }
          } // End of switch(Arg2)
        } // End of if
        return (Buffer() {0x00})
      } // End of _DSM
    
      Method(_PRW, 0) {
        Return(GPRW(0x69, 4)) // can wakeup from S4 state
      }
    
      Method (_PS0, 0, Serialized)
      {
        If (LEqual (HPEX, 1)) {
          Store (0, HPEX) // Disable Hot Plug SCI
          Store (1, HPSX) // Clear Hot Plug SCI status
        }
        If (LEqual (PMEX, 1)) {
          Store (0, PMEX) // Disable Power Management SCI
          Store (1, PMSX) // Clear Power Management SCI status
        }
        If (CondRefOf (PPS0)) {
          PPS0 ()
        }
      }
      Method (_PS3, 0, Serialized)
      {
        If (CondRefOf (PPS3)) {
          PPS3 ()
        }
        If (LEqual (HPEX, 0)) {
          Store(1, HPEX) // Enable Hot Plug SCI
          Store(1, HPSX) // Clear Hot Plug SCI status
        }
        If (LEqual(PMEX, 0)) {
          Store(1, PMEX) // Enable Power Management SCI
          Store(1, PMSX) // Clear Power Management SCI status
        }
      }
    
      Method (_DSD, 0) {
        If(CondRefOf(PINI)) {
          Return (
            Package () {
              ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
              Package () {
                Package (2) {"HotPlugSupportInD3", 1},
              },
              ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
              Package () {
                Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
              },
              // This _DSD object informs Windows PCIe bus driver that
              // this root ports supports auxilary power budgeting.
              ToUUID("6B4AD420-8FD3-4364-ACF8-EB94876FD9EB"),
              Package () {
              },
              // This informs driver that PTM ART is traceble to TSC
              ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
              Package () {
              }
            }
          ) //End of Return ()
        } else {
          Return (
            Package () {
              ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
              Package () {
                Package (2) {"HotPlugSupportInD3", 1},
              },
              ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
              Package () {
                Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
              },
              // This informs driver that PTM ART is traceble to TSC
              ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
              Package () {
              }
            }
          ) // End of Return ()
        }
      }
    
      //
      // PCI_EXP_STS Handler for PCIE Root Port
      //
      Method(HPME,0,Serialized) {
        If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
          Store(1,PMSX) // clear rootport's PME SCI status
          Store(1,PSPX) // consume one pending PME status to prevent it from blocking the queue
          Return(0x01)
        }
        Return(0x00)
      }
    
      //
      // Sub-Method of _L61 Hot-Plug event
      // _L61 event handler should invoke this method to support HotPlug wake event from PEG RP
      //
      Method(HPEV,0,Serialized) {
        If(LAnd(LNotEqual(VDID,0xFFFFFFFF), HPSX)) {
          // Clear HotPlug SCI event status
          Store(1, HPSX)
    
          If(LEqual(PDCX, 1)) {
            // Clear Presence Detect Changed
            Store(1,PDCX)
    
            If(LEqual(PDSX, 0)) {
              // The PCI Express slot is empty, so disable L0s on hot unplug
              //
              Store(0,L0SE)
            }
            // Perform proper notification
            // to the OS.
            Notify(^,0)
          }
        }
      }

  } // PEG2 scope end
  
  If (CondRefOf(\_SB.PC00.PEG3)) {
    Scope (\_SB.PC00.PEG3) {
  
      Name(SLOT, 3) // CPU PCIe root port index 3 corresponds to PEG12 (0/1/2)
  
      Method (CPRA, 0x0, NotSerialized) {
        If(LNotEqual(\PPA3,0)) {
          Return (\PPA3)
        } Else {
          Return (0x00010002)
        }
      }
  
      Method (_STA, 0x0, NotSerialized) {
        if(PG3E == 1) { // If CPU PCIe RP3 enabled?
          Return(0x0F)
        }
        Return(0x00)
      }
  
      Name(LTEN, 0)
      Name(LMSL, 0)
      Name(LNSL, 0)
  
      Method(_INI)
      {
        If(PRES()) {
          Store (LTRW, LTEN)
          Store (SMSL, LMSL)
          Store (SNSL, LNSL)
          If(CondRefOf(PINI)) {PINI()}
          If(LAnd(CondRefOf(VMCP),CondRefOf(VMDE))) {
            If(LAnd(LEqual(VMDE,1),LNotEqual(And(VMCP,0x4),0))) {
              Store (1, PRMV)
            }
          }
          //
          // RP D3Cold/D3hot support status for Storage devices
          //
          #define CPU_PCIE_ROOT_PORT  \_SB.PC00.PEG3
          /**@file
          
            ACPI D3Cold/D3hot support for Storage device connected to CPU PCIE Root Port
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
                External(CPU_PCIE_ROOT_PORT.PEGP.PNVM, MethodObj, IntObj)
                External(CPU_PCIE_ROOT_PORT.PEGP.PAHC, MethodObj, IntObj)
                External(CPU_PCIE_ROOT_PORT.VDID, FieldUnitObj)
          
                //
                // 1. Check if Root Port exists.
                // 2. Check if Root Port is mapped under VMD.
                // 2. Check for a storage device.
                //
                If (CondRefOf(CPU_PCIE_ROOT_PORT)) {
                  If(LNotEqual(CPU_PCIE_ROOT_PORT.VDID,0xFFFFFFFF)) {
                    If (CondRefOf(\STD3)) {
                      If (CondRefOf(CPU_PCIE_ROOT_PORT.PRMV)) {
                        If (LEqual (CPU_PCIE_ROOT_PORT.PRMV, 1)) {
                          Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                        }
                      }
          
                      If(LOr(CPU_PCIE_ROOT_PORT.PEGP.PNVM(),CPU_PCIE_ROOT_PORT.PEGP.PAHC())) {
                        Store(\STD3, CPU_PCIE_ROOT_PORT.RD3C)
                      }
                    }
                  }
                }

          #undef CPU_PCIE_ROOT_PORT
        }
      }
  
      Method(_PRT,0) {
        If(PICM) {
          Return(AR0B)
        } // APIC mode
        Return (PD0B) // PIC Mode
      } // end _PRT
  
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
        External(ECR1)
        External(GPRW, MethodObj)
        External(PICM)
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(ATSC)
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, PCIE_RP_TYPE_CPU) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR ()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8), // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0), // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2), // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x324), // 0x324 - PCIEDBG
          , 3,
          LEDM, 1,       // PCIEDBG.DMIL1EDM
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 24,
          LTSM, 8,
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC), // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If(LNotEqual(SCB0,0x1)) {
            Return()
          }
      
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          Store(0,SCB0)
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          Store(1,SCB0)
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 3
            // Arg2: Function Index: 0, 6, 8, 9
            // Arg3: Empty Package
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Method(_PRW, 0) {
          Return(GPRW(0x69, 4)) // can wakeup from S4 state
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (LEqual (HPEX, 1)) {
            Store (0, HPEX) // Disable Hot Plug SCI
            Store (1, HPSX) // Clear Hot Plug SCI status
          }
          If (LEqual (PMEX, 1)) {
            Store (0, PMEX) // Disable Power Management SCI
            Store (1, PMSX) // Clear Power Management SCI status
          }
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
          If (LEqual (HPEX, 0)) {
            Store(1, HPEX) // Enable Hot Plug SCI
            Store(1, HPSX) // Clear Hot Plug SCI status
          }
          If (LEqual(PMEX, 0)) {
            Store(1, PMEX) // Enable Power Management SCI
            Store(1, PMSX) // Clear Power Management SCI status
          }
        }
      
        Method (_DSD, 0) {
          If(CondRefOf(PINI)) {
            Return (
              Package () {
                ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
                Package () {
                  Package (2) {"HotPlugSupportInD3", 1},
                },
                ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
                Package () {
                  Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
                },
                // This _DSD object informs Windows PCIe bus driver that
                // this root ports supports auxilary power budgeting.
                ToUUID("6B4AD420-8FD3-4364-ACF8-EB94876FD9EB"),
                Package () {
                },
                // This informs driver that PTM ART is traceble to TSC
                ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
                Package () {
                }
              }
            ) //End of Return ()
          } else {
            Return (
              Package () {
                ToUUID ("6211E2C0-58A3-4AF3-90E1-927A4E0C55A4"),
                Package () {
                  Package (2) {"HotPlugSupportInD3", 1},
                },
                ToUUID("FDF06FAD-F744-4451-BB64-ECD792215B10"),
                Package () {
                  Package (2) {"FundamentalDeviceResetTriggeredOnD3ToD0", 1},
                },
                // This informs driver that PTM ART is traceble to TSC
                ToUUID("E995B7C2-BD1F-45F5-A911-5BCD9269CCEB"),
                Package () {
                }
              }
            ) // End of Return ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME status to prevent it from blocking the queue
            Return(0x01)
          }
          Return(0x00)
        }
      
        //
        // Sub-Method of _L61 Hot-Plug event
        // _L61 event handler should invoke this method to support HotPlug wake event from PEG RP
        //
        Method(HPEV,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), HPSX)) {
            // Clear HotPlug SCI event status
            Store(1, HPSX)
      
            If(LEqual(PDCX, 1)) {
              // Clear Presence Detect Changed
              Store(1,PDCX)
      
              If(LEqual(PDSX, 0)) {
                // The PCI Express slot is empty, so disable L0s on hot unplug
                //
                Store(0,L0SE)
              }
              // Perform proper notification
              // to the OS.
              Notify(^,0)
            }
          }
        }

    } // PEG3 scope end
  }
  
  Scope(\_SB.PC00.PEG0.PEGP) {
    /** @file
      ACPI Support for PCIe SSD
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
      // Include PciEpSel.asl for PCIe SSD support
      // Input parameters:
      OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
      Field(PCCX, ByteAcc, NoLock, Preserve) {
        DVID, 32, // Vendor&Device ID,
        Offset(9),
        PIXX, 8, // Programming Interface
        SCCX, 8, // Sub Class Code
        BCCX, 8, // Base Class Code
      }
    
      Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
      {
        If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
          If(LEqual(SCCX, 0x06)){
            If(LEqual(PIXX, 0x01)){
              Return(0x01)
            }
          }
        }
        Return(0x00)
      }
    
      Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
      {
        If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
          If(LEqual(SCCX, 0x08)){
            If(LEqual(PIXX, 0x02)){
              Return(0x01)
            }
          }
        }
        Return(0x00)
      }
    
      //
      // Check if  EP(End Point) is present.
      // Arguments: (0)
      // Return: EP presence status
      //     0->EP is absent; 1->EP is present
      //
      Method(PRES, Zero, Serialized) {
        If(LEqual (DVID, 0xFFFFFFFF)) {
          Return(0)
        } Else {
          Return(1)
        }
      }
    
      //
      // Check if EP (End Point) is GFX.
      // Arguments: (0)
      // Return:
      //     0->EP is not Gfx; 1->EP is GFX
      //
      Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
      {
        If (LEqual (BCCX, 0x03)){ // Check Base Class Code
          Return (0x01)
        }
        Return (0x00)
      }
    
      Method (_DSD, 0)
      {
        If (LOr (PAHC (), PNVM ())) {
          Return (
            Package () {
              ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
              // Enable D3 Support for NVMe Storage
              Package () {
                Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
              }
            }
          )
        } Else {
          Return (
            Package () {
              ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
              Package () {
                Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
              }
            }
          )
        }
      }
    

    Method(_PRW, 0) {
      Return(GPRW(0x69, 4)) // can wakeup from S4 state
    }
  }
  
  If (PBR1) {
    Scope(\_SB.PC00.PEG1.PEGP) {
      Method(_S0W, 0) { Return(4)} //D3cold is supported
  
      Device (PEGD) {
        Method(_S0W, 0) { Return(4)} //D3cold is supported
        Name(_ADR, 0x00000000)
        Method(_PRW, 0) { Return(GPRW(0x69, 4)) } // can wakeup from S4 state
      }
    } // end "P.E.G. Port Slot x16"
  }
  
  Scope(\_SB.PC00.PEG1.PEGP) {
    /** @file
      ACPI Support for PCIe SSD
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
      // Include PciEpSel.asl for PCIe SSD support
      // Input parameters:
      OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
      Field(PCCX, ByteAcc, NoLock, Preserve) {
        DVID, 32, // Vendor&Device ID,
        Offset(9),
        PIXX, 8, // Programming Interface
        SCCX, 8, // Sub Class Code
        BCCX, 8, // Base Class Code
      }
    
      Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
      {
        If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
          If(LEqual(SCCX, 0x06)){
            If(LEqual(PIXX, 0x01)){
              Return(0x01)
            }
          }
        }
        Return(0x00)
      }
    
      Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
      {
        If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
          If(LEqual(SCCX, 0x08)){
            If(LEqual(PIXX, 0x02)){
              Return(0x01)
            }
          }
        }
        Return(0x00)
      }
    
      //
      // Check if  EP(End Point) is present.
      // Arguments: (0)
      // Return: EP presence status
      //     0->EP is absent; 1->EP is present
      //
      Method(PRES, Zero, Serialized) {
        If(LEqual (DVID, 0xFFFFFFFF)) {
          Return(0)
        } Else {
          Return(1)
        }
      }
    
      //
      // Check if EP (End Point) is GFX.
      // Arguments: (0)
      // Return:
      //     0->EP is not Gfx; 1->EP is GFX
      //
      Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
      {
        If (LEqual (BCCX, 0x03)){ // Check Base Class Code
          Return (0x01)
        }
        Return (0x00)
      }
    
      Method (_DSD, 0)
      {
        If (LOr (PAHC (), PNVM ())) {
          Return (
            Package () {
              ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
              // Enable D3 Support for NVMe Storage
              Package () {
                Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
              }
            }
          )
        } Else {
          Return (
            Package () {
              ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
              Package () {
                Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
              }
            }
          )
        }
      }
    

    Method(_PRW, 0) {
      Return(GPRW(0x69, 4)) // can wakeup from S4 state
    }
  }
  
  If (PBR2) {
    Scope(\_SB.PC00.PEG2.PEGP) {
      Method(_S0W, 0) { Return(4)} //D3cold is supported
  
      Device (PEGD) {
        Method(_S0W, 0) { Return(4)} //D3cold is supported
        Name(_ADR, 0x00000000)
        Method(_PRW, 0) { Return(GPRW(0x69, 4)) } // can wakeup from S4 state
      }
    } // end "P.E.G. Port Slot 2x8"
  }
  
  Scope(\_SB.PC00.PEG2.PEGP) {
    /** @file
      ACPI Support for PCIe SSD
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
      // Include PciEpSel.asl for PCIe SSD support
      // Input parameters:
      OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
      Field(PCCX, ByteAcc, NoLock, Preserve) {
        DVID, 32, // Vendor&Device ID,
        Offset(9),
        PIXX, 8, // Programming Interface
        SCCX, 8, // Sub Class Code
        BCCX, 8, // Base Class Code
      }
    
      Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
      {
        If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
          If(LEqual(SCCX, 0x06)){
            If(LEqual(PIXX, 0x01)){
              Return(0x01)
            }
          }
        }
        Return(0x00)
      }
    
      Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
      {
        If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
          If(LEqual(SCCX, 0x08)){
            If(LEqual(PIXX, 0x02)){
              Return(0x01)
            }
          }
        }
        Return(0x00)
      }
    
      //
      // Check if  EP(End Point) is present.
      // Arguments: (0)
      // Return: EP presence status
      //     0->EP is absent; 1->EP is present
      //
      Method(PRES, Zero, Serialized) {
        If(LEqual (DVID, 0xFFFFFFFF)) {
          Return(0)
        } Else {
          Return(1)
        }
      }
    
      //
      // Check if EP (End Point) is GFX.
      // Arguments: (0)
      // Return:
      //     0->EP is not Gfx; 1->EP is GFX
      //
      Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
      {
        If (LEqual (BCCX, 0x03)){ // Check Base Class Code
          Return (0x01)
        }
        Return (0x00)
      }
    
      Method (_DSD, 0)
      {
        If (LOr (PAHC (), PNVM ())) {
          Return (
            Package () {
              ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
              // Enable D3 Support for NVMe Storage
              Package () {
                Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
              }
            }
          )
        } Else {
          Return (
            Package () {
              ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
              Package () {
                Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
              }
            }
          )
        }
      }
    

    Method(_PRW, 0) {
      Return(GPRW(0x69, 4)) // can wakeup from S4 state
    }
  }
  
  If (PBR3) {
    Scope(\_SB.PC00.PEG3.PEGP) {
      Method(_S0W, 0) { Return(4)} //D3cold is supported
  
      Device (PEGD) {
        Method(_S0W, 0) { Return(4)} //D3cold is supported
        Name(_ADR, 0x00000000)
        Method(_PRW, 0) { Return(GPRW(0x69, 4)) } // can wakeup from S4 state
      }
    } // end "P.E.G. Port Slot 1x8 - 2x4"
  }
  
  If (CondRefOf(\_SB.PC00.PEG3)) {
    Scope(\_SB.PC00.PEG3.PEGP) {
      /** @file
        ACPI Support for PCIe SSD
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        // Include PciEpSel.asl for PCIe SSD support
        // Input parameters:
        OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
        Field(PCCX, ByteAcc, NoLock, Preserve) {
          DVID, 32, // Vendor&Device ID,
          Offset(9),
          PIXX, 8, // Programming Interface
          SCCX, 8, // Sub Class Code
          BCCX, 8, // Base Class Code
        }
      
        Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
        {
          If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
            If(LEqual(SCCX, 0x06)){
              If(LEqual(PIXX, 0x01)){
                Return(0x01)
              }
            }
          }
          Return(0x00)
        }
      
        Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
        {
          If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
            If(LEqual(SCCX, 0x08)){
              If(LEqual(PIXX, 0x02)){
                Return(0x01)
              }
            }
          }
          Return(0x00)
        }
      
        //
        // Check if  EP(End Point) is present.
        // Arguments: (0)
        // Return: EP presence status
        //     0->EP is absent; 1->EP is present
        //
        Method(PRES, Zero, Serialized) {
          If(LEqual (DVID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // Check if EP (End Point) is GFX.
        // Arguments: (0)
        // Return:
        //     0->EP is not Gfx; 1->EP is GFX
        //
        Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
        {
          If (LEqual (BCCX, 0x03)){ // Check Base Class Code
            Return (0x01)
          }
          Return (0x00)
        }
      
        Method (_DSD, 0)
        {
          If (LOr (PAHC (), PNVM ())) {
            Return (
              Package () {
                ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                // Enable D3 Support for NVMe Storage
                Package () {
                  Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                }
              }
            )
          } Else {
            Return (
              Package () {
                ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                Package () {
                  Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                }
              }
            )
          }
        }
      

      Method(_PRW, 0) {
        Return(GPRW(0x69, 4)) // can wakeup from S4 state
      }
    }
  }

  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  External(\_SB.ISME, MethodObj)
  External(\_SB.SHPO, MethodObj)
  External(\_SB.CAGS, MethodObj)
  External(\_SB.PC00.PEG0, DeviceObj)
  External(\_SB.PC00.PEG1, DeviceObj)
  External(\_SB.PC00.PEG2, DeviceObj)
  External(\_SB.PC00.PEG3, DeviceObj)
  External(\_SB.PC00.PEG1.DHDW, MethodObj)
  External(\P0WK)
  External(\P1WK)
  External(\P2WK)
  External(\P3WK)
  
  //GPE Event handling - Start
  Scope(\_GPE) {
    //
    // _L6F Method call for PEG0/1/2/3 ports to handle 2-tier RTD3 GPE events
    //
    Method(P0L6,0)
    {
      // PEG0 Device Wake Event
      If (\_SB.ISME(P0WK))
      {
        \_SB.SHPO(P0WK, 1)             // set gpio ownership to driver(0=ACPI mode, 1=GPIO mode)
        Notify(\_SB.PC00.PEG0, 0x02)   // device wake
        \_SB.CAGS(P0WK)                // Clear GPE status bit for PEG0 WAKE
      }
    }
  
    Method(P1L6,0)
    {
      // PEG1 Device Wake Event
      If (\_SB.ISME(P1WK))
      {
        If (CondRefOf (\_SB.PC00.PEG1.DHDW)) { // DG support HPD as D3 Wake GPIO and DHDW exists
          \_SB.PC00.PEG1.DHDW () // Disable Discrete Graphics HPD SCI implementated As D3 Wake GPIO
          Notify(\_SB.PC00.PEG1, 0x00)   // Bus Check
        } Else {
          \_SB.SHPO(P1WK, 1)             // set gpio ownership to driver(0=ACPI mode, 1=GPIO mode)
          Notify(\_SB.PC00.PEG1, 0x02)   // device wake
        }
        \_SB.CAGS(P1WK)                // Clear GPE status bit for PEG1 WAKE
      }
    }
  
    Method(P2L6,0)
    {
      // PEG2 Device Wake Event
      If (\_SB.ISME(P2WK))
      {
        \_SB.SHPO(P2WK, 1)             // set gpio ownership to driver(0=ACPI mode, 1=GPIO mode)
        Notify(\_SB.PC00.PEG2, 0x02)   // device wake
        \_SB.CAGS(P2WK)                // Clear GPE status bit for PEG2 WAKE
      }
    }
  
    If (CondRefOf(\_SB.PC00.PEG3)) {
      Method(P3L6,0)
      {
        // PEG2 Device Wake Event
        If (\_SB.ISME(P3WK))
        {
          \_SB.SHPO(P3WK, 1)             // set gpio ownership to driver(0=ACPI mode, 1=GPIO mode)
          Notify(\_SB.PC00.PEG3, 0x02)   // device wake
          \_SB.CAGS(P3WK)                // Clear GPE status bit for PEG2 WAKE
        }
      }
    }
  } //Scope(\_GPE)
  


}
