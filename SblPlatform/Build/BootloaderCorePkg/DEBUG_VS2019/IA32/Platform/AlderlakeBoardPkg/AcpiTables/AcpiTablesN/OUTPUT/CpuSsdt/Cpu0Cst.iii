#line 1 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\CpuSsdt\\Cpu0Cst.i"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"
/**
  DO NOT EDIT
  FILE auto-generated
  Module name:
    AutoGen.h
  Abstract:       Auto-generated AutoGen.h for building module or library.
**/








#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
/** @file
  Root include file for Mde Package Base type modules

  This is the include file for any module of type base. Base modules only use
  types defined via this include file and can be ported easily to any
  environment. There are a set of base libraries in the Mde Package that can
  be used to implement base modules.

Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/





//
// Include processor specific binding
//
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"
/** @file
  Processor or Compiler specific defines and types for IA-32 architecture.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




///
/// Define the processor type so other code can make processor based choices.
///


//
// Make sure we are using the correct packing rules per EFI specification
//

#pragma pack()
#line 23 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"


























#line 50 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"




//
// Disable warning that make it impossible to compile at /W4
// This only works for Microsoft* tools
//

//
// Disabling bitfield type checking warnings.
//
#pragma warning ( disable : 4214 )

//
// Disabling the unreferenced formal parameter warnings.
//
#pragma warning ( disable : 4100 )

//
// Disable slightly different base types warning as CHAR8 * can not be set
// to a constant string.
//
#pragma warning ( disable : 4057 )

//
// ASSERT(FALSE) or while (TRUE) are legal constructs so suppress this warning
//
#pragma warning ( disable : 4127 )

//
// This warning is caused by functions defined but not used. For precompiled header only.
//
#pragma warning ( disable : 4505 )

//
// This warning is caused by empty (after preprocessing) source file. For precompiled header only.
//
#pragma warning ( disable : 4206 )



//
// Disable these warnings for VS2013.
//

//
// This warning is for potentially uninitialized local variable, and it may cause false
// positive issues in VS2013 and VS2015 build
//
#pragma warning ( disable : 4701 )

//
// This warning is for potentially uninitialized local pointer variable, and it may cause
// false positive issues in VS2013 and VS2015 build
//
#pragma warning ( disable : 4703 )

#line 109 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

#line 111 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"




  //
  // use Microsoft C compiler dependent integer width types
  //

  ///
  /// 8-byte unsigned value.
  ///
  typedef unsigned __int64    UINT64;
  ///
  /// 8-byte signed value.
  ///
  typedef __int64             INT64;
  ///
  /// 4-byte unsigned value.
  ///
  typedef unsigned __int32    UINT32;
  ///
  /// 4-byte signed value.
  ///
  typedef __int32             INT32;
  ///
  /// 2-byte unsigned value.
  ///
  typedef unsigned short      UINT16;
  ///
  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
  ///
  typedef unsigned short      CHAR16;
  ///
  /// 2-byte signed value.
  ///
  typedef short               INT16;
  ///
  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
  /// values are undefined.
  ///
  typedef unsigned char       BOOLEAN;
  ///
  /// 1-byte unsigned value.
  ///
  typedef unsigned char       UINT8;
  ///
  /// 1-byte Character.
  ///
  typedef char                CHAR8;
  ///
  /// 1-byte signed value.
  ///
  typedef signed char         INT8;















































#line 213 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

///
/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions;
/// 8 bytes on supported 64-bit processor instructions.)
///
typedef UINT32  UINTN;
///
/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions;
/// 8 bytes on supported 64-bit processor instructions.)
///
typedef INT32   INTN;

//
// Processor specific defines
//

///
/// A value of native width with the highest bit set.
///

///
/// A value of native width with the two highest bits set.
///


///
/// Maximum legal IA-32 address.
///


///
/// Maximum usable address at boot time
///


///
/// Maximum legal IA-32 INTN and UINTN values.
///



///
/// Minimum legal IA-32 INTN value.
///


///
/// The stack alignment required for IA-32.
///


///
/// Page allocation granularity for IA-32.
///



//
// Modifier to ensure that all protocol member functions and EFI intrinsics
// use the correct C calling convention. All protocol member functions and
// EFI intrinsics are required to modify their member functions with EFIAPI.
//





  ///
  /// Microsoft* compiler specific method for EFIAPI calling convention.
  ///
  











#line 296 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"







#line 304 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

/**
  Return the pointer to the first instruction of a function given a function pointer.
  On IA-32 CPU architectures, these two pointer values are the same,
  so the implementation of this macro is very simple.

  @param  FunctionPointer   A pointer to a function.

  @return The pointer to the first instruction of a function given a function pointer.

**/




#line 320 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

#line 322 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

#line 23 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"


//
// Disable warning when last field of data structure is a zero sized array.
//
#pragma warning ( disable : 4200 )
#line 30 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// The Microsoft* C compiler can removed references to unreferenced data items
//  if the /OPT:REF linker option is used. We defined a macro as this is a
//  a non standard extension
//







#line 44 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
  ///
  /// Remove the global variable from the linked image if there are no references
  ///  to it after all compiler and linker optimizations have been performed.
  ///
  ///
  
#line 51 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Should be used in combination with NORETURN to avoid 'noreturn' returns
// warnings.
//

  













#line 72 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

  
    ///
    /// Signal compilers and analyzers that this call is not reachable.  It is
    /// up to the compiler to remove any code past that point.
    ///
    
  #line 80 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 81 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Signaling compilers and analyzers that a certain function cannot return may
// remove all following code and thus lead to better optimization and less
// false positives.
//

  






#line 96 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
    ///
    /// Signal compilers and analyzers that the function cannot return.
    /// It is up to the compiler to remove any code past a call to functions
    /// flagged with this attribute.
    ///
    
  






#line 110 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 111 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Should be used in combination with ANALYZER_NORETURN to avoid 'noreturn'
// returns warnings.
//

  









  
    ///
    /// Signal the analyzer that this call is not reachable.
    /// This excludes compilers.
    ///
    
  #line 134 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 135 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Static Analyzers may issue errors about potential NULL-dereferences when
// dereferencing a pointer, that has been checked before, outside of a
// NULL-check.  This may lead to false positives, such as when using ASSERT()
// for verification.
//

  









  
    ///
    /// Signal the analyzer that the function cannot return.
    /// This excludes compilers.
    ///
    
  #line 160 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 161 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

///
/// Tell the code optimizer that the function will return twice.
/// This prevents wrong optimizations which can cause bugs.
///

  





#line 174 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
    ///
    /// Tell the code optimizer that the function will return twice.
    /// This prevents wrong optimizations which can cause bugs.
    ///
    
  #line 180 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 181 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// For symbol name in assembly code, an extra "_" is sometimes necessary
//

///
/// Private worker functions for ASM_PFX()
///



///
/// The __USER_LABEL_PREFIX__ macro predefined by GNUC represents the prefix
/// on symbols in assembly language.
///









  
#line 207 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"








  
#line 217 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

///
/// 128 bit buffer containing a unique identifier value.
/// Unless otherwise specified, aligned on a 64 bit boundary.
///
typedef struct {
  UINT32  Data1;
  UINT16  Data2;
  UINT16  Data3;
  UINT8   Data4[8];
} GUID;

///
/// 4-byte buffer. An IPv4 internet protocol address.
///
typedef struct {
  UINT8 Addr[4];
} IPv4_ADDRESS;

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
typedef struct {
  UINT8 Addr[16];
} IPv6_ADDRESS;

//
// 8-bytes unsigned value that represents a physical system address.
//
typedef UINT64 PHYSICAL_ADDRESS;

///
/// LIST_ENTRY structure definition.
///
typedef struct _LIST_ENTRY LIST_ENTRY;

///
/// _LIST_ENTRY structure definition.
///
struct _LIST_ENTRY {
  LIST_ENTRY  *ForwardLink;
  LIST_ENTRY  *BackLink;
};

//
// Modifiers to abstract standard types to aid in debug of problems
//

///
/// Datum is read-only.
///


///
/// Datum is scoped to the current file or function.
///


///
/// Undeclared type.
///


//
// Modifiers for Data Types used to self document code.
// This concept is borrowed for UEFI specification.
//

///
/// Datum is passed to the function.
///


///
/// Datum is returned from the function.
///


///
/// Passing the datum to the function is optional, and a NULL
/// is passed if the value is not supplied.
///


//
//  UEFI specification claims 1 and 0. We are concerned about the
//  compiler portability so we did it this way.
//

///
/// Boolean true value.  UEFI Specification defines this value to be 1,
/// but this form is more portable.
///


///
/// Boolean false value.  UEFI Specification defines this value to be 0,
/// but this form is more portable.
///


///
/// NULL pointer (VOID *)
///


//
// Null character
//


///
/// Maximum values for common UEFI Data Types
///









///
/// Minimum values for the signed UEFI Data Types
///




















































































































































































//
//  Support for variable argument lists in freestanding edk2 modules.
//
//  For modules that use the ISO C library interfaces for variable
//  argument lists, refer to "StdLib/Include/stdarg.h".
//
//  VA_LIST  - typedef for argument list.
//  VA_START (VA_LIST Marker, argument before the ...) - Init Marker for use.
//  VA_END (VA_LIST Marker) - Clear Marker
//  VA_ARG (VA_LIST Marker, var arg type) - Use Marker to get an argument from
//    the ... list. You must know the type and pass it in this macro.  Type
//    must be compatible with the type of the actual next argument (as promoted
//    according to the default argument promotions.)
//  VA_COPY (VA_LIST Dest, VA_LIST Start) - Initialize Dest as a copy of Start.
//
//  Example:
//
//  UINTN
//  EFIAPI
//  ExampleVarArg (
//    IN UINTN  NumberOfArgs,
//    ...
//    )
//  {
//    VA_LIST Marker;
//    UINTN   Index;
//    UINTN   Result;
//
//    //
//    // Initialize the Marker
//    //
//    VA_START (Marker, NumberOfArgs);
//    for (Index = 0, Result = 0; Index < NumberOfArgs; Index++) {
//      //
//      // The ... list is a series of UINTN values, so sum them up.
//      //
//      Result += VA_ARG (Marker, UINTN);
//    }
//
//    VA_END (Marker);
//    return Result;
//  }
//
//  Notes:
//  - Functions that call VA_START() / VA_END() must have a variable
//    argument list and must be declared EFIAPI.
//  - Functions that call VA_COPY() / VA_END() must be declared EFIAPI.
//  - Functions that only use VA_LIST and VA_ARG() need not be EFIAPI.
//

/**
  Return the size of argument that has been aligned to sizeof (UINTN).

  @param  n    The parameter size to be aligned.

  @return The aligned size.
**/
































#line 613 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"











#line 625 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"












































#line 670 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
///
/// Variable used to traverse the list of arguments. This type can vary by
/// implementation and could be an array or structure.
///
typedef CHAR8 *VA_LIST;

/**
  Retrieves a pointer to the beginning of a variable argument list, based on
  the name of the parameter that immediately precedes the variable argument list.

  This function initializes Marker to point to the beginning of the variable
  argument list that immediately follows Parameter.  The method for computing the
  pointer to the next argument in the argument list is CPU-specific following the
  EFIAPI ABI.

  @param   Marker       The VA_LIST used to traverse the list of arguments.
  @param   Parameter    The name of the parameter that immediately precedes
                        the variable argument list.

  @return  A pointer to the beginning of a variable argument list.

**/


/**
  Returns an argument of a specified type from a variable argument list and updates
  the pointer to the variable argument list to point to the next argument.

  This function returns an argument of the type specified by TYPE from the beginning
  of the variable argument list specified by Marker.  Marker is then updated to point
  to the next argument in the variable argument list.  The method for computing the
  pointer to the next argument in the argument list is CPU-specific following the EFIAPI ABI.

  @param   Marker   VA_LIST used to traverse the list of arguments.
  @param   TYPE     The type of argument to retrieve from the beginning
                    of the variable argument list.

  @return  An argument of the type specified by TYPE.

**/


/**
  Terminates the use of a variable argument list.

  This function initializes Marker so it can no longer be used with VA_ARG().
  After this macro is used, the only way to access the variable argument list is
  by using VA_START() again.

  @param   Marker   VA_LIST used to traverse the list of arguments.

**/


/**
  Initializes a VA_LIST as a copy of an existing VA_LIST.

  This macro initializes Dest as a copy of Start, as if the VA_START macro had been applied to Dest
  followed by the same sequence of uses of the VA_ARG macro as had previously been used to reach
  the present state of Start.

  @param   Dest   VA_LIST used to traverse the list of arguments.
  @param   Start  VA_LIST used to traverse the list of arguments.

**/


#line 738 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

///
/// Pointer to the start of a variable argument list stored in a memory buffer. Same as UINT8 *.
///
typedef UINTN  *BASE_LIST;

/**
  Returns the size of a data type in sizeof(UINTN) units rounded up to the nearest UINTN boundary.

  @param  TYPE  The date type to determine the size of.

  @return The size of TYPE in sizeof (UINTN) units rounded up to the nearest UINTN boundary.
**/


/**
  Returns an argument of a specified type from a variable argument list and updates
  the pointer to the variable argument list to point to the next argument.

  This function returns an argument of the type specified by TYPE from the beginning
  of the variable argument list specified by Marker.  Marker is then updated to point
  to the next argument in the variable argument list.  The method for computing the
  pointer to the next argument in the argument list is CPU specific following the EFIAPI ABI.

  @param   Marker   The pointer to the beginning of a variable argument list.
  @param   TYPE     The type of argument to retrieve from the beginning
                    of the variable argument list.

  @return  An argument of the type specified by TYPE.

**/


/**
  The macro that returns the byte offset of a field in a data structure.

  This function returns the offset, in bytes, of field specified by Field from the
  beginning of the  data structure specified by TYPE. If TYPE does not contain Field,
  the module will not compile.

  @param   TYPE     The name of the data structure that contains the field specified by Field.
  @param   Field    The name of the field in the data structure.

  @return  Offset, in bytes, of field.

**/


#line 787 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"



#line 791 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

/**
  Portable definition for compile time assertions.
  Equivalent to C11 static_assert macro from assert.h.

  @param  Expression  Boolean expression.
  @param  Message     Raised compiler diagnostic message when expression is false.

**/



  


#line 807 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Verify that ProcessorBind.h produced UEFI Data Types that are compliant with
// Section 2.3.1 of the UEFI 2.3 Specification.
//

static_assert (sizeof (BOOLEAN) == 1, "sizeof (BOOLEAN) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT8)    == 1, "sizeof (INT8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT8)   == 1, "sizeof (UINT8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT16)   == 2, "sizeof (INT16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT16)  == 2, "sizeof (UINT16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT32)   == 4, "sizeof (INT32) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT32)  == 4, "sizeof (UINT32) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT64)   == 8, "sizeof (INT64) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT64)  == 8, "sizeof (UINT64) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (CHAR8)   == 1, "sizeof (CHAR8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (CHAR16)  == 2, "sizeof (CHAR16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (L'A')    == 2, "sizeof (L'A') does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (L"A")    == 4, "sizeof (L\"A\") does not meet UEFI Specification Data Type requirements");

//
// The following three enum types are used to verify that the compiler
// configuration for enum types is compliant with Section 2.3.1 of the
// UEFI 2.3 Specification. These enum types and enum values are not
// intended to be used. A prefix of '__' is used avoid conflicts with
// other types.
//
typedef enum {
  __VerifyUint8EnumValue = 0xff
} __VERIFY_UINT8_ENUM_SIZE;

typedef enum {
  __VerifyUint16EnumValue = 0xffff
} __VERIFY_UINT16_ENUM_SIZE;

typedef enum {
  __VerifyUint32EnumValue = 0xffffffff
} __VERIFY_UINT32_ENUM_SIZE;

static_assert (sizeof (__VERIFY_UINT8_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (__VERIFY_UINT16_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (__VERIFY_UINT32_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");

/**
  Macro that returns a pointer to the data structure that contains a specified field of
  that data structure.  This is a lightweight method to hide information by placing a
  public data structure inside a larger private data structure and using a pointer to
  the public data structure to retrieve a pointer to the private data structure.

  This function computes the offset, in bytes, of field specified by Field from the beginning
  of the  data structure specified by TYPE.  This offset is subtracted from Record, and is
  used to return a pointer to a data structure of the type specified by TYPE. If the data type
  specified by TYPE does not contain the field specified by Field, then the module will not compile.

  @param   Record   Pointer to the field specified by Field within a data structure of type TYPE.
  @param   TYPE     The name of the data structure type to return.  This data structure must
                    contain the field specified by Field.
  @param   Field    The name of the field in the data structure specified by TYPE to which Record points.

  @return  A pointer to the structure from one of it's elements.

**/


/**
  Rounds a value up to the next boundary using a specified alignment.

  This function rounds Value up to the next boundary using the specified Alignment.
  This aligned value is returned.

  @param   Value      The value to round up.
  @param   Alignment  The alignment boundary used to return the aligned value.

  @return  A value up to the next boundary.

**/


/**
  Adjust a pointer by adding the minimum offset required for it to be aligned on
  a specified alignment boundary.

  This function rounds the pointer specified by Pointer to the next alignment boundary
  specified by Alignment. The pointer to the aligned address is returned.

  @param   Pointer    The pointer to round up.
  @param   Alignment  The alignment boundary to use to return an aligned pointer.

  @return  Pointer to the aligned address.

**/


/**
  Rounds a value up to the next natural boundary for the current CPU.
  This is 4-bytes for 32-bit CPUs and 8-bytes for 64-bit CPUs.

  This function rounds the value specified by Value up to the next natural boundary for the
  current CPU. This rounded value is returned.

  @param   Value      The value to round up.

  @return  Rounded value specified by Value.

**/



/**
  Return the maximum of two operands.

  This macro returns the maximum of two operand specified by a and b.
  Both a and b must be the same numerical types, signed or unsigned.

  @param   a        The first operand with any numerical type.
  @param   b        The second operand. Can be any numerical type as long as is
                    the same type as a.

  @return  Maximum of two operands.

**/



/**
  Return the minimum of two operands.

  This macro returns the minimal of two operand specified by a and b.
  Both a and b must be the same numerical types, signed or unsigned.

  @param   a        The first operand with any numerical type.
  @param   b        The second operand. It should be the same any numerical type with a.

  @return  Minimum of two operands.

**/



/**
  Return the absolute value of a signed operand.

  This macro returns the absolute value of the signed operand specified by a.

  @param   a        The signed operand.

  @return  The absolute value of the signed operand.

**/



//
// Status codes common to all execution phases
//
typedef UINTN RETURN_STATUS;

/**
  Produces a RETURN_STATUS code with the highest bit set.

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.

  @return The value specified by StatusCode with the highest bit set.

**/


/**
  Produces a RETURN_STATUS code with the highest bit clear.

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.

  @return The value specified by StatusCode with the highest bit clear.

**/


/**
  Returns TRUE if a specified RETURN_STATUS code is an error code.

  This function returns TRUE if StatusCode has the high bit set.  Otherwise, FALSE is returned.

  @param  StatusCode    The status code value to evaluate.

  @retval TRUE          The high bit of StatusCode is set.
  @retval FALSE         The high bit of StatusCode is clear.

**/


///
/// The operation completed successfully.
///


///
/// The image failed to load.
///


///
/// The parameter was incorrect.
///


///
/// The operation is not supported.
///


///
/// The buffer was not the proper size for the request.
///


///
/// The buffer was not large enough to hold the requested data.
/// The required buffer size is returned in the appropriate
/// parameter when this error occurs.
///


///
/// There is no data pending upon return.
///


///
/// The physical device reported an error while attempting the
/// operation.
///


///
/// The device can not be written to.
///


///
/// The resource has run out.
///


///
/// An inconsistency was detected on the file system causing the
/// operation to fail.
///


///
/// There is no more space on the file system.
///


///
/// The device does not contain any medium to perform the
/// operation.
///


///
/// The medium in the device has changed since the last
/// access.
///


///
/// The item was not found.
///


///
/// Access was denied.
///


///
/// The server was not found or did not respond to the request.
///


///
/// A mapping to the device does not exist.
///


///
/// A timeout time expired.
///


///
/// The protocol has not been started.
///


///
/// The protocol has already been started.
///


///
/// The operation was aborted.
///


///
/// An ICMP error occurred during the network operation.
///


///
/// A TFTP error occurred during the network operation.
///


///
/// A protocol error occurred during the network operation.
///


///
/// A function encountered an internal version that was
/// incompatible with a version requested by the caller.
///


///
/// The function was not performed due to a security violation.
///


///
/// A CRC error was detected.
///


///
/// The beginning or end of media was reached.
///


///
/// The end of the file was reached.
///


///
/// The language specified was invalid.
///


///
/// The security status of the data is unknown or compromised
/// and the data must be updated or replaced to restore a valid
/// security status.
///


///
/// A HTTP error occurred during the network operation.
///


///
/// The string contained one or more characters that
/// the device could not render and were skipped.
///


///
/// The handle was closed, but the file was not deleted.
///


///
/// The handle was closed, but the data to the file was not
/// flushed properly.
///


///
/// The resulting buffer was too small, and the data was
/// truncated to the buffer size.
///


///
/// The data has not been updated within the timeframe set by
/// local policy for this type of data.
///


///
/// The resulting buffer contains UEFI-compliant file system.
///



/**
  Returns a 16-bit signature built from 2 ASCII characters.

  This macro returns a 16-bit value built from the two ASCII characters specified
  by A and B.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.

  @return A 16-bit value built from the two ASCII characters specified by A and B.

**/


/**
  Returns a 32-bit signature built from 4 ASCII characters.

  This macro returns a 32-bit value built from the four ASCII characters specified
  by A, B, C, and D.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.
  @param  C    The third ASCII character.
  @param  D    The fourth ASCII character.

  @return A 32-bit value built from the two ASCII characters specified by A, B,
          C and D.

**/


/**
  Returns a 64-bit signature built from 8 ASCII characters.

  This macro returns a 64-bit value built from the eight ASCII characters specified
  by A, B, C, D, E, F, G,and H.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.
  @param  C    The third ASCII character.
  @param  D    The fourth ASCII character.
  @param  E    The fifth ASCII character.
  @param  F    The sixth ASCII character.
  @param  G    The seventh ASCII character.
  @param  H    The eighth ASCII character.

  @return A 64-bit value built from the two ASCII characters specified by A, B,
          C, D, E, F, G and H.

**/




  void * _ReturnAddress(void);
  #pragma intrinsic(_ReturnAddress)
  /**
    Get the return address of the calling function.

    Based on intrinsic function _ReturnAddress that provides the address of
    the instruction in the calling function that will be executed after
    control returns to the caller.

    @param L    Return Level.

    @return The return address of the calling function or 0 if L != 0.

  **/
  























#line 1301 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

/**
  Return the number of elements in an array.

  @param  Array  An object of array type. Array is only used as an argument to
                 the sizeof operator, therefore Array is never evaluated. The
                 caller is responsible for ensuring that Array's type is not
                 incomplete; that is, Array must have known constant size.

  @return The number of elements in Array. The result has type UINTN.

**/


#line 1316 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

#line 17 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Library/PcdLib.h"
/** @file
  Provides library services to get and set Platform Configuration Database entries.

  PCD Library Class provides a PCD usage macro interface for all PCD types.
  It should be included in any module that uses PCD. If a module uses dynamic/dynamicex
  PCD, module should be linked to a PEIM/DXE library instance to access that PCD.
  If a module uses PatchableInModule type PCD, it also needs the library instance to produce
  LibPatchPcdSetPtr() interface. For FeatureFlag/Fixed PCD, the macro interface is
  translated to a variable or macro that is auto-generated by build tool in
  module's autogen.h/autogen.c.
  The PcdGetXX(), PcdSetXX(), PcdToken(), and PcdGetNextTokenSpace() operations are
  only available prior to ExitBootServices().  If access to PCD values are required
  at runtime, then their values must be collected prior to ExitBootServices().
  There are no restrictions on the use of FeaturePcd(), FixedPcdGetXX(),
  PatchPcdGetXX(), and PatchPcdSetXX().

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/





/**
  Retrieves a token number based on a token name.

  Returns the token number associated with the PCD token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve the token number for.

  @return  The token number associated with the PCD.

**/



/**
  Retrieves a Boolean PCD feature flag based on a token name.

  Returns the Boolean value for the PCD feature flag specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a feature flag PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  Boolean value for the PCD feature flag.

**/



/**
  Retrieves an 8-bit fixed PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  8-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 16-bit fixed PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  16-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 32-bit fixed PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  32-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 64-bit fixed PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  64-bit value for the token specified by TokenName.

**/



/**
  Retrieves a Boolean fixed PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  The Boolean value for the token.

**/



/**
  Retrieves a pointer to a fixed PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer.

**/



/**
  Retrieves an 8-bit binary patchable PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  An 8-bit binary patchable PCD token value.

**/


/**
  Retrieves a 16-bit binary patchable PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 16-bit binary patchable PCD token value.

**/



/**
  Retrieves a 32-bit binary patchable PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 32-bit binary patchable PCD token value.

**/



/**
  Retrieves a 64-bit binary patchable PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 64-bit binary patchable PCD token value.

**/



/**
  Retrieves a Boolean binary patchable PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  The Boolean value for the token.

**/



/**
  Retrieves a pointer to a binary patchable PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer for the token.

**/



/**
  Sets an 8-bit binary patchable PCD token value based on a token name.

  Sets the 8-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 8-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a 16-bit binary patchable PCD token value based on a token name.

  Sets the 16-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 16-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a 32-bit binary patchable PCD token value based on a token name.

  Sets the 32-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 32-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a 64-bit binary patchable PCD token value based on a token name.

  Sets the 64-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 64-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a Boolean binary patchable PCD token value based on a token name.

  Sets the Boolean value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The boolean value to set.

  @return Return the Value that was set.

**/



/**
  Sets a pointer to a binary patchable PCD token buffer based on a token name.

  Sets the buffer for the token specified by TokenName.  Buffer is returned.
  If SizeOfBuffer is greater than the maximum size supported by TokenName, then set SizeOfBuffer
  to the maximum size supported by TokenName and return NULL to indicate that the set operation
  was not actually performed.  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be
  set to the maximum size supported by TokenName and NULL must be returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param   TokenName      The name of the binary patchable PCD token to set the current value for.
  @param   SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param   Buffer         Pointer to the value to set.

  @return Return the pointer to the Buffer that was set.

**/








/**
  Retrieves an 8-bit PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  8-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 16-bit PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  16-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 32-bit PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  32-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 64-bit PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  64-bit value for the token specified by TokenName.

**/



/**
  Retrieves a pointer to a PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer.

**/



/**
  Retrieves a Boolean PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A Boolean PCD token value.

**/



/**
  Retrieves the size of a fixed PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.

  @return     Return the size

**/



/**
  Retrieves the size of a binary patchable PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.

  @return     Return the size

**/



/**
  Retrieves the size of the PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]   TokenName  The name of the PCD token to retrieve a current value size for.

  @return      Return the size

**/



/**
  Retrieve the size of a given PCD token.

  Returns the size of the token specified by TokenNumber and Guid.
  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value size for.

  @return     Return the size.

**/


/**
  Sets a 8-bit PCD token value based on a token name.

  Sets the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 8-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 16-bit PCD token value based on a token name.

  Sets the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 16-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 32-bit PCD token value based on a token name.

  Sets the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 32-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 64-bit PCD token value based on a token name.

  Sets the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 64-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a pointer to a PCD token buffer based on a token name.

  Sets the buffer for the token specified by TokenName.
  If SizeOfBuffer is greater than the maximum size supported by TokenName,
  then set SizeOfBuffer to the maximum size supported by TokenName and return
  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
  supported by TokenName and RETURN_INVALID_PARAMETER must be returned.
  If TokenName is not a valid token in the token space, then the module will not build.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param TokenName      The name of the PCD token to set the current value for.
  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param Buffer         A pointer to the buffer to set.

  @return The status of the set operation.

**/





/**
  Sets a boolean PCD token value based on a token name.

  Sets the boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The boolean value to set.

  @return The status of the set operation.

**/


/**
  Retrieves a token number based on a GUID and a token name.

  Returns the token number for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  Return the token number.

**/


/**
  Retrieves an 8-bit PCD token value based on a GUID and a token name.

  Returns the 8-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  An 8-bit PCD token value.

**/


/**
  Retrieves a 16-bit PCD token value based on a GUID and a token name.

  Returns the 16-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 16-bit PCD token value.

**/



/**
  Retrieves a 32-bit PCD token value based on a GUID and a token name.

  Returns the 32-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 32-bit PCD token value.

**/



/**
  Retrieves a 64-bit PCD token value based on a GUID and a token name.

  Returns the 64-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 64-bit PCD token value.

**/



/**
  Retrieves a pointer to a PCD token buffer based on a GUID and a token name.

  Returns a pointer to the buffer for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A pointer to a PCD token buffer.

**/



/**
  Retrieves a Boolean PCD token value based on a GUID and a token name.

  Returns the Boolean value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A Boolean PCD token value.

**/




/**
  Sets an 8-bit PCD token value based on a GUID and a token name.

  Sets the 8-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 8-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 16-bit PCD token value based on a GUID and a token name.

  Sets the 16-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 16-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 32-bit PCD token value based on a GUID and a token name.

  Sets the 32-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 32-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 64-bit PCD token value based on a GUID and a token name.

  Sets the 64-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 64-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a pointer to a PCD token buffer based on a GUID and a token name.

  Sets the buffer for the token specified by Guid and TokenName.
  If SizeOfBuffer is greater than the maximum size supported by Guid and TokenName,
  then set SizeOfBuffer to the maximum size supported by Guid and TokenName and return
  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
  supported by Guid and TokenName and RETURN_INVALID_PARAMETER must be returned.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param Guid           Pointer to a 128-bit unique value that designates
                        which namespace to retrieve a value from.
  @param TokenName      The name of the PCD token to set the current value for.
  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param Buffer         Pointer to the buffer to set.

  @return The status of the set operation.

**/




/**
  Sets an boolean PCD token value based on a GUID and a token name.

  Sets the boolean value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The boolean value to set.

  @return The status of the set operation.

**/



/**
  This function provides a means by which SKU support can be established in the PCD infrastructure.

  Sets the current SKU in the PCD database to the value specified by SkuId.  SkuId is returned.

  @param  SkuId   The SKU value that will be used when the PCD service retrieves and sets values
                  associated with a PCD token.

  @return  Return the SKU ID that was set.

**/
UINTN
__cdecl
LibPcdSetSku (
   UINTN   SkuId
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 8-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 8-bit value for the token specified by TokenNumber.

**/
UINT8
__cdecl
LibPcdGet8 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 16-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 16-bit value for the token specified by TokenNumber.

**/
UINT16
__cdecl
LibPcdGet16 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 32-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 32-bit value for the token specified by TokenNumber.

**/
UINT32
__cdecl
LibPcdGet32 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 64-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 64-bit value for the token specified by TokenNumber.

**/
UINT64
__cdecl
LibPcdGet64 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the pointer to the buffer of the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the pointer to the token specified by TokenNumber.

**/
void *
__cdecl
LibPcdGetPtr (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the Boolean value of the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the Boolean value of the token specified by TokenNumber.

**/
BOOLEAN
__cdecl
LibPcdGetBool (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve the size of a given PCD token.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the size of the token specified by TokenNumber.

**/
UINTN
__cdecl
LibPcdGetSize (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 8-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT8.

**/
UINT8
__cdecl
LibPcdGetEx8 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 16-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT16.

**/
UINT16
__cdecl
LibPcdGetEx16 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  Returns the 32-bit value for the token specified by TokenNumber and Guid.
  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT32.

**/
UINT32
__cdecl
LibPcdGetEx32 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 64-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the UINT64.

**/
UINT64
__cdecl
LibPcdGetEx64 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the pointer to the buffer of token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the VOID* pointer.

**/
void *
__cdecl
LibPcdGetExPtr (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the Boolean value of the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the BOOLEAN.

**/
BOOLEAN
__cdecl
LibPcdGetExBool (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve the size of a given PCD token.

  Returns the size of the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the size.

**/
UINTN
__cdecl
LibPcdGetExSize (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 8-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 8-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet8S (
   UINTN          TokenNumber,
   UINT8          Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 16-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 16-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet16S (
   UINTN          TokenNumber,
   UINT16         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 32-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 32-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet32S (
   UINTN          TokenNumber,
   UINT32         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 64-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 64-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet64S (
   UINTN          TokenNumber,
   UINT64         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets a buffer for the token specified by TokenNumber to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
  was not actually performed.

  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the
  maximum size supported by TokenName and RETURN_INVALID_PARAMETER must be returned.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[in]      TokenNumber   The PCD token number to set a current value for.
  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
  @param[in]      Buffer        A pointer to the buffer to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetPtrS (
         UINTN    TokenNumber,
      UINTN    *SizeOfBuffer,
   const void     *Buffer
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the boolean value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The boolean value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetBoolS (
   UINTN          TokenNumber,
   BOOLEAN        Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 8-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 8-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx8S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT8          Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 16-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 16-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx16S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT16         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 32-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 32-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx32S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT32         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 64-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 64-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx64S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT64         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets a buffer for the token specified by TokenNumber to the value specified by
  Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
  was not actually performed.

  If Guid is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[in]      Guid          Pointer to a 128-bit unique value that
                                designates which namespace to set a value from.
  @param[in]      TokenNumber   The PCD token number to set a current value for.
  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
  @param[in]      Buffer        A pointer to the buffer to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetExPtrS (
   const GUID     *Guid,
         UINTN    TokenNumber,
      UINTN    *SizeOfBuffer,
         void     *Buffer
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the boolean value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The boolean value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetExBoolS (
   const GUID     *Guid,
   UINTN          TokenNumber,
   BOOLEAN        Value
  );

/**
  This notification function serves two purposes.

  Firstly, it notifies the module that did the registration that the value of this
  PCD token has been set.
  Secondly, it provides a mechanism for the module that did the registration to intercept
  the set operation and override the value been set if necessary. After the invocation of
  the callback function, TokenData will be used by PCD service PEIM or driver to modify th
  internal data in PCD database.

  @param[in]      CallBackGuid    The PCD token GUID being set.
  @param[in]      CallBackToken   The PCD token number being set.
  @param[in, out] TokenData       A pointer to the token data being set.
  @param[in]      TokenDataSize   The size, in bytes, of the data being set.

**/
typedef
void
(__cdecl *PCD_CALLBACK)(
          const GUID        *CallBackGuid, 
          UINTN             CallBackToken,
       void              *TokenData,
          UINTN             TokenDataSize
  );


/**
  Set up a notification function that is called when a specified token is set.

  When the token specified by TokenNumber and Guid is set,
  then notification function specified by NotificationFunction is called.
  If Guid is NULL, then the default token space is used.
  If NotificationFunction is NULL, then ASSERT().

  @param[in]  Guid                  Pointer to a 128-bit unique value that designates which
                                    namespace to set a value from.  If NULL, then the default
                                    token space is used.
  @param[in]  TokenNumber           The PCD token number to monitor.
  @param[in]  NotificationFunction  The function to call when the token
                                    specified by Guid and TokenNumber is set.

**/
void
__cdecl
LibPcdCallbackOnSet (
   const GUID               *Guid,       
   UINTN                    TokenNumber,
   PCD_CALLBACK             NotificationFunction
  );


/**
  Disable a notification function that was established with LibPcdCallbackonSet().

  Disable a notification function that was previously established with LibPcdCallbackOnSet().
  If NotificationFunction is NULL, then ASSERT().
  If LibPcdCallbackOnSet() was not previously called with Guid, TokenNumber,
  and NotificationFunction, then ASSERT().

  @param[in]  Guid                 Specify the GUID token space.
  @param[in]  TokenNumber          Specify the token number.
  @param[in]  NotificationFunction The callback function to be unregistered.

**/
void
__cdecl
LibPcdCancelCallback (
   const GUID               *Guid,       
   UINTN                    TokenNumber,
   PCD_CALLBACK             NotificationFunction
  );


/**
  Retrieves the next token in a token space.

  Retrieves the next PCD token number from the token space specified by Guid.
  If Guid is NULL, then the default token space is used.  If TokenNumber is 0,
  then the first token number is returned.  Otherwise, the token number that
  follows TokenNumber in the token space is returned.  If TokenNumber is the last
  token number in the token space, then 0 is returned.

  If TokenNumber is not 0 and is not in the token space specified by Guid, then ASSERT().

  @param[in]  Guid        Pointer to a 128-bit unique value that designates which namespace
                          to set a value from.  If NULL, then the default token space is used.
  @param[in]  TokenNumber The previous PCD token number.  If 0, then retrieves the first PCD
                          token number.

  @return The next valid token number.

**/
UINTN
__cdecl
LibPcdGetNextToken (
   const GUID               *Guid,       
   UINTN                    TokenNumber
  );



/**
  Used to retrieve the list of available PCD token space GUIDs.

  Returns the PCD token space GUID that follows TokenSpaceGuid in the list of token spaces
  in the platform.
  If TokenSpaceGuid is NULL, then a pointer to the first PCD token spaces returned.
  If TokenSpaceGuid is the last PCD token space GUID in the list, then NULL is returned.

  @param  TokenSpaceGuid  Pointer to the a PCD token space GUID

  @return The next valid token namespace.

**/
GUID *
__cdecl
LibPcdGetNextTokenSpace (
   const GUID  *TokenSpaceGuid
  );


/**
  Sets a value of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
  and SizeOfBuffer.  Buffer is returned.  If SizeOfBuffer is greater than
  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
  NULL to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and NULL must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return Return the pointer to the Buffer that was set.

**/
void *
__cdecl
LibPatchPcdSetPtr (
          void       *PatchVariable,
          UINTN       MaximumDatumSize,
       UINTN       *SizeOfBuffer,
   const  void        *Buffer
  );

/**
  Sets a value of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
  to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPatchPcdSetPtrS (
        void     *PatchVariable,
         UINTN    MaximumDatumSize,
      UINTN    *SizeOfBuffer,
   const void     *Buffer
  );

/**
  Sets a value and size of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
  and SizeOfBuffer. Buffer is returned.  If SizeOfBuffer is greater than
  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
  NULL to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and NULL must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfPatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return Return the pointer to the Buffer that was set.

**/
void *
__cdecl
LibPatchPcdSetPtrAndSize (
         void        *PatchVariable,
         UINTN       *SizeOfPatchVariable,
          UINTN       MaximumDatumSize,
       UINTN       *SizeOfBuffer,
   const  void        *Buffer
  );

/**
  Sets a value and size of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
  to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfPatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPatchPcdSetPtrAndSizeS (
        void     *PatchVariable,
        UINTN    *SizeOfPatchVariable,
         UINTN    MaximumDatumSize,
      UINTN    *SizeOfBuffer,
   const void     *Buffer
  );

typedef enum {
  PCD_TYPE_8,
  PCD_TYPE_16,
  PCD_TYPE_32,
  PCD_TYPE_64,
  PCD_TYPE_BOOL,
  PCD_TYPE_PTR
} PCD_TYPE;

typedef struct {
  ///
  /// The returned information associated with the requested TokenNumber. If
  /// TokenNumber is 0, then PcdType is set to PCD_TYPE_8.
  ///
  PCD_TYPE          PcdType;
  ///
  /// The size of the data in bytes associated with the TokenNumber specified. If
  /// TokenNumber is 0, then PcdSize is set 0.
  ///
  UINTN             PcdSize;
  ///
  /// The null-terminated ASCII string associated with a given token. If the
  /// TokenNumber specified was 0, then this field corresponds to the null-terminated
  /// ASCII string associated with the token's namespace Guid. If NULL, there is no
  /// name associated with this request.
  ///
  CHAR8             *PcdName;
} PCD_INFO;


/**
  Retrieve additional information associated with a PCD token.

  This includes information such as the type of value the TokenNumber is associated with as well as possible
  human readable name that is associated with the token.

  If TokenNumber is not in the default token space specified, then ASSERT().

  @param[in]    TokenNumber The PCD token number.
  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
**/
void
__cdecl
LibPcdGetInfo (
          UINTN           TokenNumber,
         PCD_INFO        *PcdInfo
  );

/**
  Retrieve additional information associated with a PCD token.

  This includes information such as the type of value the TokenNumber is associated with as well as possible
  human readable name that is associated with the token.

  If TokenNumber is not in the token space specified by Guid, then ASSERT().

  @param[in]    Guid        The 128-bit unique value that designates the namespace from which to extract the value.
  @param[in]    TokenNumber The PCD token number.
  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
**/
void
__cdecl
LibPcdGetInfoEx (
   const  GUID            *Guid,
          UINTN           TokenNumber,
         PCD_INFO        *PcdInfo
  );

/**
  Retrieve the currently set SKU Id.

  @return   The currently set SKU Id. If the platform has not set at a SKU Id, then the
            default SKU Id value of 0 is returned. If the platform has set a SKU Id, then the currently set SKU
            Id is returned.
**/
UINTN
__cdecl
LibPcdGetSku (
  void
  );

#line 1735 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Library/PcdLib.h"
#line 18 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"

extern GUID  gEfiCallerIdGuid;
extern GUID  gEdkiiDscPlatformGuid;
extern CHAR8 *gEfiCallerBaseName;






// Guids
extern GUID gPlatformAlderLakeTokenSpaceGuid;

// Definition of SkuId Array
extern UINT64 _gPcd_SkuId_Array[];

// Definition of PCDs used in this module





extern const  BOOLEAN  _gPcd_FixedAtBuild_PcdAdlNSupport;

//#define _PCD_SET_MODE_BOOL_PcdAdlNSupport  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD






#line 50 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\CpuSsdt\\Cpu0Cst.i"


/** @file

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\CpuPowerMgmt.h"
/** @file
  This file contains define definitions specific to processor


  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/



//
// Voltage offset definitions
//


//
// Platform Power Management Flags Bit Definitions:
//   These defines are also used in CPU0CST.ASL to check platform configuration
//   and build C-state table accordingly.
//





















































#line 76 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\CpuPowerMgmt.h"




//
// The following definitions are based on assumed location for the  ACPI
// Base Address.  Modify as necessary base on platform-specific requirements.
//







//
// C-State Latency (us):
//  Though _CST object is core level, it is recommended that System BIOS report the
//  Package level C state latencies, so that Operating System can account for worst case
//  latency before using a specific C state. Unlike legacy platforms,
//  BIOS is no longer required to program the C_STATE_LATENCYCONTROL_n MSRs (0x60B, 0x60C, 0x633, 0x634, 0x635).
//







//
// C-State Power (mW)
//









#line 118 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\CpuPowerMgmt.h"



///
/// Limit the number of P-states for different generation OS.
///









#line 134 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\CpuPowerMgmt.h"
#line 11 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\CpuSsdt\\Cpu0Cst.i"

DefinitionBlock (
  "CPU0CST.aml",
  "SSDT",
  2,
  "PmRef",
  "Cpu0Cst",
  0x3001
  )
{
External(\_SB.PR00, DeviceObj)
External(PWRS)
External(CFGD)
External(PF00)
External(FMBL)
External(FEMD)
External(PFLV)
External(C6MW)       // Mwait Hint value for C6
External(C7MW)       // Mwait Hint value for C7
External(CDMW)       // Mwait Hint value for C8/C9/C10
External(C6LT)       // Latency Value for C6
External(C7LT)       // Latency Value for C7
External(CDLT)       // Latency Value for C8/C9/C10
External(CDLV)       // IO Level value for C8/C9/C10
External(CDPW)       // Power value for  C8/C9/C10

Scope(\_SB.PR00)
{
  //
  // Create Temp packages for each C-state and Initialize them to default IO_LVL
  //
  // C1  Temp Package (C1 - HLT)
  //
  Name ( C1TM, Package()
  {
    ResourceTemplate () {Register(FFixedHW, 0, 0, 0)},
    1,
    1,
    0x3E8
  })

  //
  // C6 Temp Package
  //
  Name ( C6TM, Package()
  {
     ResourceTemplate () {Register(SystemIO, 8, 0, 0x1815)},
     2,
     0,
     0x15E
   })

  //
  // C7 Temp Package
  //
  Name ( C7TM, Package()
  {
     ResourceTemplate () {Register(SystemIO, 8, 0, 0x1816)},
     2,
     0,
     0xC8
   })

  //
  // CD Temp Package - Deep C-states - covers C8/C9/C10
  //
  Name ( CDTM, Package()
  {
     ResourceTemplate () {Register(SystemIO, 8, 0, 0x1816)},
     3,
     0,
     0
   })
  //
  // ResourceTemplate for MWait Extentions Supported.
  //
  Name ( MWES, ResourceTemplate(){Register(FFixedHW, 1, 2, 0x00, 1)})
  //
  // Valid/Invalid Flags for ACPI C2 and C3
  //
  Name (AC2V, 0)
  Name (AC3V, 0)
  //
  // Package for reporting 3 C-states
  //
  Name ( C3ST, Package()
  {
    3,
    Package() {},
    Package() {},
    Package() {}
  })
  //
  // Package for reporting 2 C-states
  //
  Name ( C2ST, Package()
  {
    2,
    Package() {},
    Package() {}
  })
  //
  // Package for reporting 1 C-state
  //
  Name ( C1ST, Package()
  {
    1,
    Package() {}
  })
  //
  // C-state initialization flag
  //
  Name(CSTF, 0)
  //
  // Returns the C-state table based on platform configuration.
  // This method is serialized since it uses various global packages and updates them in run time to return the current C-state table.
  //
  Method (_CST, 0, Serialized)
  {
    If(LNot(CSTF))
    {
     //
     // First call to _CST.
     // Update Latency Values for C6/C7/CD based on the Latency values passed through PPM NVS
     //
     Store (C6LT, Index(C6TM, 2))
     Store (C7LT, Index(C7TM, 2))
     Store (CDLT, Index(CDTM, 2))
     //
     // Update the IO_LVL and Power values in CD temp package
     //
     Store (CDPW, Index(CDTM, 3))
     Store (CDLV, Index (DerefOf (Index (CDTM, 0)),7))
     //
     //   CFGD[11] = 1 - MWAIT extensions supported
     //   PDCx[9]  = 1 - OS supports MWAIT extensions
     //   PDCx[8]  = 1 - OS supports MWAIT for C1 (Inferred from PDCx[9] = 1.)
     //

     If(LAnd(And(CFGD, 0x00000800), And(PF00,0x200)))
     {
      //
      // Processor MWAIT extensions supported and OS supports MWAIT extensions
      // 1. Replace the IO LVL ResourceTemplate of C1TM, C6TM, C7TM, CDTM with MWAIT EXT ResourceTemplate (FFixedHW)
      // 2. Update the Mwait Hint Values for C6/C7/CD based on the Latency values passed through PPM NVS
      //

      Store (MWES, Index (C1TM, 0))
      Store (MWES, Index (C6TM, 0))
      Store (MWES, Index (C7TM, 0))
      Store (MWES, Index (CDTM, 0))

      Store (C6MW, Index (DerefOf (Index (C6TM, 0)),7))
      Store (C7MW, Index (DerefOf (Index (C7TM, 0)),7))
      Store (CDMW, Index (DerefOf (Index (CDTM, 0)),7))
     }
     ElseIf (LAnd(And(CFGD, 0x00000800), And(PF00,0x100)))
     {
      //
      // Update C1 temp package ResourceTemplate if OS supports Mwait for C1
      //
      Store (MWES, Index (C1TM, 0))
     }

     Store (Ones, CSTF)
    }
    //
    // Initialize the ACPI C2, C3 Valid/Invalid flags to Invalid (0)
    //
    Store(Zero, AC2V)
    Store(Zero, AC3V)
    //
    // Create C state Package with Acpi C1= C1,ACPI C2=MaxSupported(C6,C3,C7),ACPI C3=MaxSupported(C8,C9,C10).
    // It is safe to assume C1 always supported if we enable C-states.
    //
    Store (C1TM, Index (C3ST,1))

    If(And(CFGD,0x00000020))
    {
      Store (C7TM, Index (C3ST,2))
      Store (Ones, AC2V)
    }ElseIf(And(CFGD,0x00000010))
    {
      Store (C6TM, Index (C3ST,2))
      Store (Ones, AC2V)
    }
    If(And(CFGD,0x00004000)) {
      Store (CDTM, Index (C3ST,3))
      Store (Ones, AC3V)
    }

    //
    // Filter and return the final C-state package
    //
    If(LAnd(AC2V, AC3V))
    {
    Return (C3ST)
    }
    ElseIf(AC2V)
    {
     Store (DerefOf (Index (C3ST,1)), Index (C2ST,1))
     Store (DerefOf (Index (C3ST,2)), Index (C2ST,2))
     Return (C2ST)
    }
    ElseIf(AC3V)
    {
    Store (DerefOf (Index (C3ST,1)), Index (C2ST,1))
    Store (DerefOf (Index (C3ST,3)), Index (C2ST,2))
    Store (2, Index (DerefOf (Index (C2ST, 2)),1))
    Return (C2ST)
    }
    Else
    {
    Store (DerefOf (Index (C3ST,1)), Index (C1ST,1))
    Return (C1ST)
    }
  }
}
}
