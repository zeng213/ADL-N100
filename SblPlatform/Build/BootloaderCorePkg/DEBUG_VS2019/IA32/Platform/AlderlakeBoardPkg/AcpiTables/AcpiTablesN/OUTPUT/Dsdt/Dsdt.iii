#line 1 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"
/**
  DO NOT EDIT
  FILE auto-generated
  Module name:
    AutoGen.h
  Abstract:       Auto-generated AutoGen.h for building module or library.
**/








#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
/** @file
  Root include file for Mde Package Base type modules

  This is the include file for any module of type base. Base modules only use
  types defined via this include file and can be ported easily to any
  environment. There are a set of base libraries in the Mde Package that can
  be used to implement base modules.

Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/





//
// Include processor specific binding
//
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"
/** @file
  Processor or Compiler specific defines and types for IA-32 architecture.

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/




///
/// Define the processor type so other code can make processor based choices.
///


//
// Make sure we are using the correct packing rules per EFI specification
//

#pragma pack()
#line 23 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"


























#line 50 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"




//
// Disable warning that make it impossible to compile at /W4
// This only works for Microsoft* tools
//

//
// Disabling bitfield type checking warnings.
//
#pragma warning ( disable : 4214 )

//
// Disabling the unreferenced formal parameter warnings.
//
#pragma warning ( disable : 4100 )

//
// Disable slightly different base types warning as CHAR8 * can not be set
// to a constant string.
//
#pragma warning ( disable : 4057 )

//
// ASSERT(FALSE) or while (TRUE) are legal constructs so suppress this warning
//
#pragma warning ( disable : 4127 )

//
// This warning is caused by functions defined but not used. For precompiled header only.
//
#pragma warning ( disable : 4505 )

//
// This warning is caused by empty (after preprocessing) source file. For precompiled header only.
//
#pragma warning ( disable : 4206 )



//
// Disable these warnings for VS2013.
//

//
// This warning is for potentially uninitialized local variable, and it may cause false
// positive issues in VS2013 and VS2015 build
//
#pragma warning ( disable : 4701 )

//
// This warning is for potentially uninitialized local pointer variable, and it may cause
// false positive issues in VS2013 and VS2015 build
//
#pragma warning ( disable : 4703 )

#line 109 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

#line 111 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"




  //
  // use Microsoft C compiler dependent integer width types
  //

  ///
  /// 8-byte unsigned value.
  ///
  typedef unsigned __int64    UINT64;
  ///
  /// 8-byte signed value.
  ///
  typedef __int64             INT64;
  ///
  /// 4-byte unsigned value.
  ///
  typedef unsigned __int32    UINT32;
  ///
  /// 4-byte signed value.
  ///
  typedef __int32             INT32;
  ///
  /// 2-byte unsigned value.
  ///
  typedef unsigned short      UINT16;
  ///
  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
  ///
  typedef unsigned short      CHAR16;
  ///
  /// 2-byte signed value.
  ///
  typedef short               INT16;
  ///
  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
  /// values are undefined.
  ///
  typedef unsigned char       BOOLEAN;
  ///
  /// 1-byte unsigned value.
  ///
  typedef unsigned char       UINT8;
  ///
  /// 1-byte Character.
  ///
  typedef char                CHAR8;
  ///
  /// 1-byte signed value.
  ///
  typedef signed char         INT8;















































#line 213 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

///
/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions;
/// 8 bytes on supported 64-bit processor instructions.)
///
typedef UINT32  UINTN;
///
/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions;
/// 8 bytes on supported 64-bit processor instructions.)
///
typedef INT32   INTN;

//
// Processor specific defines
//

///
/// A value of native width with the highest bit set.
///

///
/// A value of native width with the two highest bits set.
///


///
/// Maximum legal IA-32 address.
///


///
/// Maximum usable address at boot time
///


///
/// Maximum legal IA-32 INTN and UINTN values.
///



///
/// Minimum legal IA-32 INTN value.
///


///
/// The stack alignment required for IA-32.
///


///
/// Page allocation granularity for IA-32.
///



//
// Modifier to ensure that all protocol member functions and EFI intrinsics
// use the correct C calling convention. All protocol member functions and
// EFI intrinsics are required to modify their member functions with EFIAPI.
//





  ///
  /// Microsoft* compiler specific method for EFIAPI calling convention.
  ///
  











#line 296 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"







#line 304 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

/**
  Return the pointer to the first instruction of a function given a function pointer.
  On IA-32 CPU architectures, these two pointer values are the same,
  so the implementation of this macro is very simple.

  @param  FunctionPointer   A pointer to a function.

  @return The pointer to the first instruction of a function given a function pointer.

**/




#line 320 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

#line 322 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Ia32\\ProcessorBind.h"

#line 23 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"


//
// Disable warning when last field of data structure is a zero sized array.
//
#pragma warning ( disable : 4200 )
#line 30 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// The Microsoft* C compiler can removed references to unreferenced data items
//  if the /OPT:REF linker option is used. We defined a macro as this is a
//  a non standard extension
//







#line 44 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
  ///
  /// Remove the global variable from the linked image if there are no references
  ///  to it after all compiler and linker optimizations have been performed.
  ///
  ///
  
#line 51 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Should be used in combination with NORETURN to avoid 'noreturn' returns
// warnings.
//

  













#line 72 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

  
    ///
    /// Signal compilers and analyzers that this call is not reachable.  It is
    /// up to the compiler to remove any code past that point.
    ///
    
  #line 80 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 81 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Signaling compilers and analyzers that a certain function cannot return may
// remove all following code and thus lead to better optimization and less
// false positives.
//

  






#line 96 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
    ///
    /// Signal compilers and analyzers that the function cannot return.
    /// It is up to the compiler to remove any code past a call to functions
    /// flagged with this attribute.
    ///
    
  






#line 110 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 111 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Should be used in combination with ANALYZER_NORETURN to avoid 'noreturn'
// returns warnings.
//

  









  
    ///
    /// Signal the analyzer that this call is not reachable.
    /// This excludes compilers.
    ///
    
  #line 134 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 135 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Static Analyzers may issue errors about potential NULL-dereferences when
// dereferencing a pointer, that has been checked before, outside of a
// NULL-check.  This may lead to false positives, such as when using ASSERT()
// for verification.
//

  









  
    ///
    /// Signal the analyzer that the function cannot return.
    /// This excludes compilers.
    ///
    
  #line 160 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 161 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

///
/// Tell the code optimizer that the function will return twice.
/// This prevents wrong optimizations which can cause bugs.
///

  





#line 174 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
    ///
    /// Tell the code optimizer that the function will return twice.
    /// This prevents wrong optimizations which can cause bugs.
    ///
    
  #line 180 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
#line 181 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// For symbol name in assembly code, an extra "_" is sometimes necessary
//

///
/// Private worker functions for ASM_PFX()
///



///
/// The __USER_LABEL_PREFIX__ macro predefined by GNUC represents the prefix
/// on symbols in assembly language.
///









  
#line 207 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"








  
#line 217 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

///
/// 128 bit buffer containing a unique identifier value.
/// Unless otherwise specified, aligned on a 64 bit boundary.
///
typedef struct {
  UINT32  Data1;
  UINT16  Data2;
  UINT16  Data3;
  UINT8   Data4[8];
} GUID;

///
/// 4-byte buffer. An IPv4 internet protocol address.
///
typedef struct {
  UINT8 Addr[4];
} IPv4_ADDRESS;

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
typedef struct {
  UINT8 Addr[16];
} IPv6_ADDRESS;

//
// 8-bytes unsigned value that represents a physical system address.
//
typedef UINT64 PHYSICAL_ADDRESS;

///
/// LIST_ENTRY structure definition.
///
typedef struct _LIST_ENTRY LIST_ENTRY;

///
/// _LIST_ENTRY structure definition.
///
struct _LIST_ENTRY {
  LIST_ENTRY  *ForwardLink;
  LIST_ENTRY  *BackLink;
};

//
// Modifiers to abstract standard types to aid in debug of problems
//

///
/// Datum is read-only.
///


///
/// Datum is scoped to the current file or function.
///


///
/// Undeclared type.
///


//
// Modifiers for Data Types used to self document code.
// This concept is borrowed for UEFI specification.
//

///
/// Datum is passed to the function.
///


///
/// Datum is returned from the function.
///


///
/// Passing the datum to the function is optional, and a NULL
/// is passed if the value is not supplied.
///


//
//  UEFI specification claims 1 and 0. We are concerned about the
//  compiler portability so we did it this way.
//

///
/// Boolean true value.  UEFI Specification defines this value to be 1,
/// but this form is more portable.
///


///
/// Boolean false value.  UEFI Specification defines this value to be 0,
/// but this form is more portable.
///


///
/// NULL pointer (VOID *)
///


//
// Null character
//


///
/// Maximum values for common UEFI Data Types
///









///
/// Minimum values for the signed UEFI Data Types
///




















































































































































































//
//  Support for variable argument lists in freestanding edk2 modules.
//
//  For modules that use the ISO C library interfaces for variable
//  argument lists, refer to "StdLib/Include/stdarg.h".
//
//  VA_LIST  - typedef for argument list.
//  VA_START (VA_LIST Marker, argument before the ...) - Init Marker for use.
//  VA_END (VA_LIST Marker) - Clear Marker
//  VA_ARG (VA_LIST Marker, var arg type) - Use Marker to get an argument from
//    the ... list. You must know the type and pass it in this macro.  Type
//    must be compatible with the type of the actual next argument (as promoted
//    according to the default argument promotions.)
//  VA_COPY (VA_LIST Dest, VA_LIST Start) - Initialize Dest as a copy of Start.
//
//  Example:
//
//  UINTN
//  EFIAPI
//  ExampleVarArg (
//    IN UINTN  NumberOfArgs,
//    ...
//    )
//  {
//    VA_LIST Marker;
//    UINTN   Index;
//    UINTN   Result;
//
//    //
//    // Initialize the Marker
//    //
//    VA_START (Marker, NumberOfArgs);
//    for (Index = 0, Result = 0; Index < NumberOfArgs; Index++) {
//      //
//      // The ... list is a series of UINTN values, so sum them up.
//      //
//      Result += VA_ARG (Marker, UINTN);
//    }
//
//    VA_END (Marker);
//    return Result;
//  }
//
//  Notes:
//  - Functions that call VA_START() / VA_END() must have a variable
//    argument list and must be declared EFIAPI.
//  - Functions that call VA_COPY() / VA_END() must be declared EFIAPI.
//  - Functions that only use VA_LIST and VA_ARG() need not be EFIAPI.
//

/**
  Return the size of argument that has been aligned to sizeof (UINTN).

  @param  n    The parameter size to be aligned.

  @return The aligned size.
**/
































#line 613 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"











#line 625 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"












































#line 670 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"
///
/// Variable used to traverse the list of arguments. This type can vary by
/// implementation and could be an array or structure.
///
typedef CHAR8 *VA_LIST;

/**
  Retrieves a pointer to the beginning of a variable argument list, based on
  the name of the parameter that immediately precedes the variable argument list.

  This function initializes Marker to point to the beginning of the variable
  argument list that immediately follows Parameter.  The method for computing the
  pointer to the next argument in the argument list is CPU-specific following the
  EFIAPI ABI.

  @param   Marker       The VA_LIST used to traverse the list of arguments.
  @param   Parameter    The name of the parameter that immediately precedes
                        the variable argument list.

  @return  A pointer to the beginning of a variable argument list.

**/


/**
  Returns an argument of a specified type from a variable argument list and updates
  the pointer to the variable argument list to point to the next argument.

  This function returns an argument of the type specified by TYPE from the beginning
  of the variable argument list specified by Marker.  Marker is then updated to point
  to the next argument in the variable argument list.  The method for computing the
  pointer to the next argument in the argument list is CPU-specific following the EFIAPI ABI.

  @param   Marker   VA_LIST used to traverse the list of arguments.
  @param   TYPE     The type of argument to retrieve from the beginning
                    of the variable argument list.

  @return  An argument of the type specified by TYPE.

**/


/**
  Terminates the use of a variable argument list.

  This function initializes Marker so it can no longer be used with VA_ARG().
  After this macro is used, the only way to access the variable argument list is
  by using VA_START() again.

  @param   Marker   VA_LIST used to traverse the list of arguments.

**/


/**
  Initializes a VA_LIST as a copy of an existing VA_LIST.

  This macro initializes Dest as a copy of Start, as if the VA_START macro had been applied to Dest
  followed by the same sequence of uses of the VA_ARG macro as had previously been used to reach
  the present state of Start.

  @param   Dest   VA_LIST used to traverse the list of arguments.
  @param   Start  VA_LIST used to traverse the list of arguments.

**/


#line 738 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

///
/// Pointer to the start of a variable argument list stored in a memory buffer. Same as UINT8 *.
///
typedef UINTN  *BASE_LIST;

/**
  Returns the size of a data type in sizeof(UINTN) units rounded up to the nearest UINTN boundary.

  @param  TYPE  The date type to determine the size of.

  @return The size of TYPE in sizeof (UINTN) units rounded up to the nearest UINTN boundary.
**/


/**
  Returns an argument of a specified type from a variable argument list and updates
  the pointer to the variable argument list to point to the next argument.

  This function returns an argument of the type specified by TYPE from the beginning
  of the variable argument list specified by Marker.  Marker is then updated to point
  to the next argument in the variable argument list.  The method for computing the
  pointer to the next argument in the argument list is CPU specific following the EFIAPI ABI.

  @param   Marker   The pointer to the beginning of a variable argument list.
  @param   TYPE     The type of argument to retrieve from the beginning
                    of the variable argument list.

  @return  An argument of the type specified by TYPE.

**/


/**
  The macro that returns the byte offset of a field in a data structure.

  This function returns the offset, in bytes, of field specified by Field from the
  beginning of the  data structure specified by TYPE. If TYPE does not contain Field,
  the module will not compile.

  @param   TYPE     The name of the data structure that contains the field specified by Field.
  @param   Field    The name of the field in the data structure.

  @return  Offset, in bytes, of field.

**/


#line 787 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"



#line 791 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

/**
  Portable definition for compile time assertions.
  Equivalent to C11 static_assert macro from assert.h.

  @param  Expression  Boolean expression.
  @param  Message     Raised compiler diagnostic message when expression is false.

**/



  


#line 807 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

//
// Verify that ProcessorBind.h produced UEFI Data Types that are compliant with
// Section 2.3.1 of the UEFI 2.3 Specification.
//

static_assert (sizeof (BOOLEAN) == 1, "sizeof (BOOLEAN) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT8)    == 1, "sizeof (INT8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT8)   == 1, "sizeof (UINT8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT16)   == 2, "sizeof (INT16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT16)  == 2, "sizeof (UINT16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT32)   == 4, "sizeof (INT32) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT32)  == 4, "sizeof (UINT32) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (INT64)   == 8, "sizeof (INT64) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (UINT64)  == 8, "sizeof (UINT64) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (CHAR8)   == 1, "sizeof (CHAR8) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (CHAR16)  == 2, "sizeof (CHAR16) does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (L'A')    == 2, "sizeof (L'A') does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (L"A")    == 4, "sizeof (L\"A\") does not meet UEFI Specification Data Type requirements");

//
// The following three enum types are used to verify that the compiler
// configuration for enum types is compliant with Section 2.3.1 of the
// UEFI 2.3 Specification. These enum types and enum values are not
// intended to be used. A prefix of '__' is used avoid conflicts with
// other types.
//
typedef enum {
  __VerifyUint8EnumValue = 0xff
} __VERIFY_UINT8_ENUM_SIZE;

typedef enum {
  __VerifyUint16EnumValue = 0xffff
} __VERIFY_UINT16_ENUM_SIZE;

typedef enum {
  __VerifyUint32EnumValue = 0xffffffff
} __VERIFY_UINT32_ENUM_SIZE;

static_assert (sizeof (__VERIFY_UINT8_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (__VERIFY_UINT16_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
static_assert (sizeof (__VERIFY_UINT32_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");

/**
  Macro that returns a pointer to the data structure that contains a specified field of
  that data structure.  This is a lightweight method to hide information by placing a
  public data structure inside a larger private data structure and using a pointer to
  the public data structure to retrieve a pointer to the private data structure.

  This function computes the offset, in bytes, of field specified by Field from the beginning
  of the  data structure specified by TYPE.  This offset is subtracted from Record, and is
  used to return a pointer to a data structure of the type specified by TYPE. If the data type
  specified by TYPE does not contain the field specified by Field, then the module will not compile.

  @param   Record   Pointer to the field specified by Field within a data structure of type TYPE.
  @param   TYPE     The name of the data structure type to return.  This data structure must
                    contain the field specified by Field.
  @param   Field    The name of the field in the data structure specified by TYPE to which Record points.

  @return  A pointer to the structure from one of it's elements.

**/


/**
  Rounds a value up to the next boundary using a specified alignment.

  This function rounds Value up to the next boundary using the specified Alignment.
  This aligned value is returned.

  @param   Value      The value to round up.
  @param   Alignment  The alignment boundary used to return the aligned value.

  @return  A value up to the next boundary.

**/


/**
  Adjust a pointer by adding the minimum offset required for it to be aligned on
  a specified alignment boundary.

  This function rounds the pointer specified by Pointer to the next alignment boundary
  specified by Alignment. The pointer to the aligned address is returned.

  @param   Pointer    The pointer to round up.
  @param   Alignment  The alignment boundary to use to return an aligned pointer.

  @return  Pointer to the aligned address.

**/


/**
  Rounds a value up to the next natural boundary for the current CPU.
  This is 4-bytes for 32-bit CPUs and 8-bytes for 64-bit CPUs.

  This function rounds the value specified by Value up to the next natural boundary for the
  current CPU. This rounded value is returned.

  @param   Value      The value to round up.

  @return  Rounded value specified by Value.

**/



/**
  Return the maximum of two operands.

  This macro returns the maximum of two operand specified by a and b.
  Both a and b must be the same numerical types, signed or unsigned.

  @param   a        The first operand with any numerical type.
  @param   b        The second operand. Can be any numerical type as long as is
                    the same type as a.

  @return  Maximum of two operands.

**/



/**
  Return the minimum of two operands.

  This macro returns the minimal of two operand specified by a and b.
  Both a and b must be the same numerical types, signed or unsigned.

  @param   a        The first operand with any numerical type.
  @param   b        The second operand. It should be the same any numerical type with a.

  @return  Minimum of two operands.

**/



/**
  Return the absolute value of a signed operand.

  This macro returns the absolute value of the signed operand specified by a.

  @param   a        The signed operand.

  @return  The absolute value of the signed operand.

**/



//
// Status codes common to all execution phases
//
typedef UINTN RETURN_STATUS;

/**
  Produces a RETURN_STATUS code with the highest bit set.

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.

  @return The value specified by StatusCode with the highest bit set.

**/


/**
  Produces a RETURN_STATUS code with the highest bit clear.

  @param  StatusCode    The status code value to convert into a warning code.
                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.

  @return The value specified by StatusCode with the highest bit clear.

**/


/**
  Returns TRUE if a specified RETURN_STATUS code is an error code.

  This function returns TRUE if StatusCode has the high bit set.  Otherwise, FALSE is returned.

  @param  StatusCode    The status code value to evaluate.

  @retval TRUE          The high bit of StatusCode is set.
  @retval FALSE         The high bit of StatusCode is clear.

**/


///
/// The operation completed successfully.
///


///
/// The image failed to load.
///


///
/// The parameter was incorrect.
///


///
/// The operation is not supported.
///


///
/// The buffer was not the proper size for the request.
///


///
/// The buffer was not large enough to hold the requested data.
/// The required buffer size is returned in the appropriate
/// parameter when this error occurs.
///


///
/// There is no data pending upon return.
///


///
/// The physical device reported an error while attempting the
/// operation.
///


///
/// The device can not be written to.
///


///
/// The resource has run out.
///


///
/// An inconsistency was detected on the file system causing the
/// operation to fail.
///


///
/// There is no more space on the file system.
///


///
/// The device does not contain any medium to perform the
/// operation.
///


///
/// The medium in the device has changed since the last
/// access.
///


///
/// The item was not found.
///


///
/// Access was denied.
///


///
/// The server was not found or did not respond to the request.
///


///
/// A mapping to the device does not exist.
///


///
/// A timeout time expired.
///


///
/// The protocol has not been started.
///


///
/// The protocol has already been started.
///


///
/// The operation was aborted.
///


///
/// An ICMP error occurred during the network operation.
///


///
/// A TFTP error occurred during the network operation.
///


///
/// A protocol error occurred during the network operation.
///


///
/// A function encountered an internal version that was
/// incompatible with a version requested by the caller.
///


///
/// The function was not performed due to a security violation.
///


///
/// A CRC error was detected.
///


///
/// The beginning or end of media was reached.
///


///
/// The end of the file was reached.
///


///
/// The language specified was invalid.
///


///
/// The security status of the data is unknown or compromised
/// and the data must be updated or replaced to restore a valid
/// security status.
///


///
/// A HTTP error occurred during the network operation.
///


///
/// The string contained one or more characters that
/// the device could not render and were skipped.
///


///
/// The handle was closed, but the file was not deleted.
///


///
/// The handle was closed, but the data to the file was not
/// flushed properly.
///


///
/// The resulting buffer was too small, and the data was
/// truncated to the buffer size.
///


///
/// The data has not been updated within the timeframe set by
/// local policy for this type of data.
///


///
/// The resulting buffer contains UEFI-compliant file system.
///



/**
  Returns a 16-bit signature built from 2 ASCII characters.

  This macro returns a 16-bit value built from the two ASCII characters specified
  by A and B.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.

  @return A 16-bit value built from the two ASCII characters specified by A and B.

**/


/**
  Returns a 32-bit signature built from 4 ASCII characters.

  This macro returns a 32-bit value built from the four ASCII characters specified
  by A, B, C, and D.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.
  @param  C    The third ASCII character.
  @param  D    The fourth ASCII character.

  @return A 32-bit value built from the two ASCII characters specified by A, B,
          C and D.

**/


/**
  Returns a 64-bit signature built from 8 ASCII characters.

  This macro returns a 64-bit value built from the eight ASCII characters specified
  by A, B, C, D, E, F, G,and H.

  @param  A    The first ASCII character.
  @param  B    The second ASCII character.
  @param  C    The third ASCII character.
  @param  D    The fourth ASCII character.
  @param  E    The fifth ASCII character.
  @param  F    The sixth ASCII character.
  @param  G    The seventh ASCII character.
  @param  H    The eighth ASCII character.

  @return A 64-bit value built from the two ASCII characters specified by A, B,
          C, D, E, F, G and H.

**/




  void * _ReturnAddress(void);
  #pragma intrinsic(_ReturnAddress)
  /**
    Get the return address of the calling function.

    Based on intrinsic function _ReturnAddress that provides the address of
    the instruction in the calling function that will be executed after
    control returns to the caller.

    @param L    Return Level.

    @return The return address of the calling function or 0 if L != 0.

  **/
  























#line 1301 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

/**
  Return the number of elements in an array.

  @param  Array  An object of array type. Array is only used as an argument to
                 the sizeof operator, therefore Array is never evaluated. The
                 caller is responsible for ensuring that Array's type is not
                 incomplete; that is, Array must have known constant size.

  @return The number of elements in Array. The result has type UINTN.

**/


#line 1316 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Base.h"

#line 17 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Library/PcdLib.h"
/** @file
  Provides library services to get and set Platform Configuration Database entries.

  PCD Library Class provides a PCD usage macro interface for all PCD types.
  It should be included in any module that uses PCD. If a module uses dynamic/dynamicex
  PCD, module should be linked to a PEIM/DXE library instance to access that PCD.
  If a module uses PatchableInModule type PCD, it also needs the library instance to produce
  LibPatchPcdSetPtr() interface. For FeatureFlag/Fixed PCD, the macro interface is
  translated to a variable or macro that is auto-generated by build tool in
  module's autogen.h/autogen.c.
  The PcdGetXX(), PcdSetXX(), PcdToken(), and PcdGetNextTokenSpace() operations are
  only available prior to ExitBootServices().  If access to PCD values are required
  at runtime, then their values must be collected prior to ExitBootServices().
  There are no restrictions on the use of FeaturePcd(), FixedPcdGetXX(),
  PatchPcdGetXX(), and PatchPcdSetXX().

Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
SPDX-License-Identifier: BSD-2-Clause-Patent

**/





/**
  Retrieves a token number based on a token name.

  Returns the token number associated with the PCD token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve the token number for.

  @return  The token number associated with the PCD.

**/



/**
  Retrieves a Boolean PCD feature flag based on a token name.

  Returns the Boolean value for the PCD feature flag specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a feature flag PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  Boolean value for the PCD feature flag.

**/



/**
  Retrieves an 8-bit fixed PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  8-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 16-bit fixed PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  16-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 32-bit fixed PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  32-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 64-bit fixed PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  64-bit value for the token specified by TokenName.

**/



/**
  Retrieves a Boolean fixed PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  The Boolean value for the token.

**/



/**
  Retrieves a pointer to a fixed PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a fixed at build PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer.

**/



/**
  Retrieves an 8-bit binary patchable PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  An 8-bit binary patchable PCD token value.

**/


/**
  Retrieves a 16-bit binary patchable PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 16-bit binary patchable PCD token value.

**/



/**
  Retrieves a 32-bit binary patchable PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 32-bit binary patchable PCD token value.

**/



/**
  Retrieves a 64-bit binary patchable PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A 64-bit binary patchable PCD token value.

**/



/**
  Retrieves a Boolean binary patchable PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  The Boolean value for the token.

**/



/**
  Retrieves a pointer to a binary patchable PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer for the token.

**/



/**
  Sets an 8-bit binary patchable PCD token value based on a token name.

  Sets the 8-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 8-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a 16-bit binary patchable PCD token value based on a token name.

  Sets the 16-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 16-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a 32-bit binary patchable PCD token value based on a token name.

  Sets the 32-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 32-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a 64-bit binary patchable PCD token value based on a token name.

  Sets the 64-bit value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The 64-bit value to set.

  @return Return the Value that was set.

**/



/**
  Sets a Boolean binary patchable PCD token value based on a token name.

  Sets the Boolean value for the token specified by TokenName. Value is returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
  @param   Value      The boolean value to set.

  @return Return the Value that was set.

**/



/**
  Sets a pointer to a binary patchable PCD token buffer based on a token name.

  Sets the buffer for the token specified by TokenName.  Buffer is returned.
  If SizeOfBuffer is greater than the maximum size supported by TokenName, then set SizeOfBuffer
  to the maximum size supported by TokenName and return NULL to indicate that the set operation
  was not actually performed.  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be
  set to the maximum size supported by TokenName and NULL must be returned.
  If TokenName is not a valid token in the token space, then the module will not build.
  If TokenName is not a patchable in module PCD, then the module will not build.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param   TokenName      The name of the binary patchable PCD token to set the current value for.
  @param   SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param   Buffer         Pointer to the value to set.

  @return Return the pointer to the Buffer that was set.

**/








/**
  Retrieves an 8-bit PCD token value based on a token name.

  Returns the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  8-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 16-bit PCD token value based on a token name.

  Returns the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  16-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 32-bit PCD token value based on a token name.

  Returns the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  32-bit value for the token specified by TokenName.

**/



/**
  Retrieves a 64-bit PCD token value based on a token name.

  Returns the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  64-bit value for the token specified by TokenName.

**/



/**
  Retrieves a pointer to a PCD token buffer based on a token name.

  Returns a pointer to the buffer for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A pointer to the buffer.

**/



/**
  Retrieves a Boolean PCD token value based on a token name.

  Returns the Boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   TokenName  The name of the PCD token to retrieve a current value for.

  @return  A Boolean PCD token value.

**/



/**
  Retrieves the size of a fixed PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.

  @return     Return the size

**/



/**
  Retrieves the size of a binary patchable PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.

  @return     Return the size

**/



/**
  Retrieves the size of the PCD token based on a token name.

  Returns the size of the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param[in]   TokenName  The name of the PCD token to retrieve a current value size for.

  @return      Return the size

**/



/**
  Retrieve the size of a given PCD token.

  Returns the size of the token specified by TokenNumber and Guid.
  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value size for.

  @return     Return the size.

**/


/**
  Sets a 8-bit PCD token value based on a token name.

  Sets the 8-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 8-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 16-bit PCD token value based on a token name.

  Sets the 16-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 16-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 32-bit PCD token value based on a token name.

  Sets the 32-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 32-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a 64-bit PCD token value based on a token name.

  Sets the 64-bit value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The 64-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a pointer to a PCD token buffer based on a token name.

  Sets the buffer for the token specified by TokenName.
  If SizeOfBuffer is greater than the maximum size supported by TokenName,
  then set SizeOfBuffer to the maximum size supported by TokenName and return
  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
  supported by TokenName and RETURN_INVALID_PARAMETER must be returned.
  If TokenName is not a valid token in the token space, then the module will not build.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param TokenName      The name of the PCD token to set the current value for.
  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param Buffer         A pointer to the buffer to set.

  @return The status of the set operation.

**/





/**
  Sets a boolean PCD token value based on a token name.

  Sets the boolean value for the token specified by TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param TokenName  The name of the PCD token to retrieve a current value for.
  @param Value      The boolean value to set.

  @return The status of the set operation.

**/


/**
  Retrieves a token number based on a GUID and a token name.

  Returns the token number for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space, then the module will not build.

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  Return the token number.

**/


/**
  Retrieves an 8-bit PCD token value based on a GUID and a token name.

  Returns the 8-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  An 8-bit PCD token value.

**/


/**
  Retrieves a 16-bit PCD token value based on a GUID and a token name.

  Returns the 16-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 16-bit PCD token value.

**/



/**
  Retrieves a 32-bit PCD token value based on a GUID and a token name.

  Returns the 32-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 32-bit PCD token value.

**/



/**
  Retrieves a 64-bit PCD token value based on a GUID and a token name.

  Returns the 64-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A 64-bit PCD token value.

**/



/**
  Retrieves a pointer to a PCD token buffer based on a GUID and a token name.

  Returns a pointer to the buffer for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A pointer to a PCD token buffer.

**/



/**
  Retrieves a Boolean PCD token value based on a GUID and a token name.

  Returns the Boolean value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param   Guid        Pointer to a 128-bit unique value that designates
                       which namespace to retrieve a value from.
  @param   TokenName   The name of the PCD token to retrieve a current value for.

  @return  A Boolean PCD token value.

**/




/**
  Sets an 8-bit PCD token value based on a GUID and a token name.

  Sets the 8-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 8-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 16-bit PCD token value based on a GUID and a token name.

  Sets the 16-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 16-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 32-bit PCD token value based on a GUID and a token name.

  Sets the 32-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 32-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets an 64-bit PCD token value based on a GUID and a token name.

  Sets the 64-bit value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The 64-bit value to set.

  @return The status of the set operation.

**/


/**
  Sets a pointer to a PCD token buffer based on a GUID and a token name.

  Sets the buffer for the token specified by Guid and TokenName.
  If SizeOfBuffer is greater than the maximum size supported by Guid and TokenName,
  then set SizeOfBuffer to the maximum size supported by Guid and TokenName and return
  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
  supported by Guid and TokenName and RETURN_INVALID_PARAMETER must be returned.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param Guid           Pointer to a 128-bit unique value that designates
                        which namespace to retrieve a value from.
  @param TokenName      The name of the PCD token to set the current value for.
  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
  @param Buffer         Pointer to the buffer to set.

  @return The status of the set operation.

**/




/**
  Sets an boolean PCD token value based on a GUID and a token name.

  Sets the boolean value for the token specified by Guid and TokenName.
  If TokenName is not a valid token in the token space specified by Guid,
  then the module will not build.

  If Guid is NULL, then ASSERT().

  @param Guid       Pointer to a 128-bit unique value that designates
                    which namespace to retrieve a value from.
  @param TokenName  The name of the PCD token to set the current value for.
  @param Value      The boolean value to set.

  @return The status of the set operation.

**/



/**
  This function provides a means by which SKU support can be established in the PCD infrastructure.

  Sets the current SKU in the PCD database to the value specified by SkuId.  SkuId is returned.

  @param  SkuId   The SKU value that will be used when the PCD service retrieves and sets values
                  associated with a PCD token.

  @return  Return the SKU ID that was set.

**/
UINTN
__cdecl
LibPcdSetSku (
   UINTN   SkuId
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 8-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 8-bit value for the token specified by TokenNumber.

**/
UINT8
__cdecl
LibPcdGet8 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 16-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 16-bit value for the token specified by TokenNumber.

**/
UINT16
__cdecl
LibPcdGet16 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 32-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 32-bit value for the token specified by TokenNumber.

**/
UINT32
__cdecl
LibPcdGet32 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 64-bit value for the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the 64-bit value for the token specified by TokenNumber.

**/
UINT64
__cdecl
LibPcdGet64 (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the pointer to the buffer of the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the pointer to the token specified by TokenNumber.

**/
void *
__cdecl
LibPcdGetPtr (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the Boolean value of the token specified by TokenNumber.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the Boolean value of the token specified by TokenNumber.

**/
BOOLEAN
__cdecl
LibPcdGetBool (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve the size of a given PCD token.

  @param[in]  TokenNumber The PCD token number to retrieve a current value for.

  @return Returns the size of the token specified by TokenNumber.

**/
UINTN
__cdecl
LibPcdGetSize (
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 8-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT8.

**/
UINT8
__cdecl
LibPcdGetEx8 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 16-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT16.

**/
UINT16
__cdecl
LibPcdGetEx16 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  Returns the 32-bit value for the token specified by TokenNumber and Guid.
  If Guid is NULL, then ASSERT().

  @param[in]  Guid         Pointer to a 128-bit unique value that designates
                           which namespace to retrieve a value from.
  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.

  @return Return the UINT32.

**/
UINT32
__cdecl
LibPcdGetEx32 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the 64-bit value for the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the UINT64.

**/
UINT64
__cdecl
LibPcdGetEx64 (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the pointer to the buffer of token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the VOID* pointer.

**/
void *
__cdecl
LibPcdGetExPtr (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve a value for a given PCD token.

  Returns the Boolean value of the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the BOOLEAN.

**/
BOOLEAN
__cdecl
LibPcdGetExBool (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to retrieve the size of a given PCD token.

  Returns the size of the token specified by TokenNumber and Guid.

  If Guid is NULL, then ASSERT().

  @param[in]  Guid          Pointer to a 128-bit unique value that designates
                            which namespace to retrieve a value from.
  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.

  @return Return the size.

**/
UINTN
__cdecl
LibPcdGetExSize (
   const GUID        *Guid,
   UINTN             TokenNumber
  );


/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 8-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 8-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet8S (
   UINTN          TokenNumber,
   UINT8          Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 16-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 16-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet16S (
   UINTN          TokenNumber,
   UINT16         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 32-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 32-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet32S (
   UINTN          TokenNumber,
   UINT32         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 64-bit value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 64-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSet64S (
   UINTN          TokenNumber,
   UINT64         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets a buffer for the token specified by TokenNumber to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
  was not actually performed.

  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the
  maximum size supported by TokenName and RETURN_INVALID_PARAMETER must be returned.

  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[in]      TokenNumber   The PCD token number to set a current value for.
  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
  @param[in]      Buffer        A pointer to the buffer to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetPtrS (
         UINTN    TokenNumber,
      UINTN    *SizeOfBuffer,
   const void     *Buffer
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the boolean value for the token specified by TokenNumber
  to the value specified by Value.

  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The boolean value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetBoolS (
   UINTN          TokenNumber,
   BOOLEAN        Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 8-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 8-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx8S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT8          Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 16-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 16-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx16S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT16         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 32-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 32-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx32S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT32         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the 64-bit value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The 64-bit value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetEx64S (
   const GUID     *Guid,
   UINTN          TokenNumber,
   UINT64         Value
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets a buffer for the token specified by TokenNumber to the value specified by
  Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
  was not actually performed.

  If Guid is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[in]      Guid          Pointer to a 128-bit unique value that
                                designates which namespace to set a value from.
  @param[in]      TokenNumber   The PCD token number to set a current value for.
  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
  @param[in]      Buffer        A pointer to the buffer to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetExPtrS (
   const GUID     *Guid,
         UINTN    TokenNumber,
      UINTN    *SizeOfBuffer,
         void     *Buffer
  );

/**
  This function provides a means by which to set a value for a given PCD token.

  Sets the boolean value for the token specified by TokenNumber
  to the value specified by Value.

  If Guid is NULL, then ASSERT().

  @param[in] Guid           The pointer to a 128-bit unique value that
                            designates which namespace to set a value from.
  @param[in] TokenNumber    The PCD token number to set a current value for.
  @param[in] Value          The boolean value to set.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPcdSetExBoolS (
   const GUID     *Guid,
   UINTN          TokenNumber,
   BOOLEAN        Value
  );

/**
  This notification function serves two purposes.

  Firstly, it notifies the module that did the registration that the value of this
  PCD token has been set.
  Secondly, it provides a mechanism for the module that did the registration to intercept
  the set operation and override the value been set if necessary. After the invocation of
  the callback function, TokenData will be used by PCD service PEIM or driver to modify th
  internal data in PCD database.

  @param[in]      CallBackGuid    The PCD token GUID being set.
  @param[in]      CallBackToken   The PCD token number being set.
  @param[in, out] TokenData       A pointer to the token data being set.
  @param[in]      TokenDataSize   The size, in bytes, of the data being set.

**/
typedef
void
(__cdecl *PCD_CALLBACK)(
          const GUID        *CallBackGuid, 
          UINTN             CallBackToken,
       void              *TokenData,
          UINTN             TokenDataSize
  );


/**
  Set up a notification function that is called when a specified token is set.

  When the token specified by TokenNumber and Guid is set,
  then notification function specified by NotificationFunction is called.
  If Guid is NULL, then the default token space is used.
  If NotificationFunction is NULL, then ASSERT().

  @param[in]  Guid                  Pointer to a 128-bit unique value that designates which
                                    namespace to set a value from.  If NULL, then the default
                                    token space is used.
  @param[in]  TokenNumber           The PCD token number to monitor.
  @param[in]  NotificationFunction  The function to call when the token
                                    specified by Guid and TokenNumber is set.

**/
void
__cdecl
LibPcdCallbackOnSet (
   const GUID               *Guid,       
   UINTN                    TokenNumber,
   PCD_CALLBACK             NotificationFunction
  );


/**
  Disable a notification function that was established with LibPcdCallbackonSet().

  Disable a notification function that was previously established with LibPcdCallbackOnSet().
  If NotificationFunction is NULL, then ASSERT().
  If LibPcdCallbackOnSet() was not previously called with Guid, TokenNumber,
  and NotificationFunction, then ASSERT().

  @param[in]  Guid                 Specify the GUID token space.
  @param[in]  TokenNumber          Specify the token number.
  @param[in]  NotificationFunction The callback function to be unregistered.

**/
void
__cdecl
LibPcdCancelCallback (
   const GUID               *Guid,       
   UINTN                    TokenNumber,
   PCD_CALLBACK             NotificationFunction
  );


/**
  Retrieves the next token in a token space.

  Retrieves the next PCD token number from the token space specified by Guid.
  If Guid is NULL, then the default token space is used.  If TokenNumber is 0,
  then the first token number is returned.  Otherwise, the token number that
  follows TokenNumber in the token space is returned.  If TokenNumber is the last
  token number in the token space, then 0 is returned.

  If TokenNumber is not 0 and is not in the token space specified by Guid, then ASSERT().

  @param[in]  Guid        Pointer to a 128-bit unique value that designates which namespace
                          to set a value from.  If NULL, then the default token space is used.
  @param[in]  TokenNumber The previous PCD token number.  If 0, then retrieves the first PCD
                          token number.

  @return The next valid token number.

**/
UINTN
__cdecl
LibPcdGetNextToken (
   const GUID               *Guid,       
   UINTN                    TokenNumber
  );



/**
  Used to retrieve the list of available PCD token space GUIDs.

  Returns the PCD token space GUID that follows TokenSpaceGuid in the list of token spaces
  in the platform.
  If TokenSpaceGuid is NULL, then a pointer to the first PCD token spaces returned.
  If TokenSpaceGuid is the last PCD token space GUID in the list, then NULL is returned.

  @param  TokenSpaceGuid  Pointer to the a PCD token space GUID

  @return The next valid token namespace.

**/
GUID *
__cdecl
LibPcdGetNextTokenSpace (
   const GUID  *TokenSpaceGuid
  );


/**
  Sets a value of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
  and SizeOfBuffer.  Buffer is returned.  If SizeOfBuffer is greater than
  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
  NULL to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and NULL must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return Return the pointer to the Buffer that was set.

**/
void *
__cdecl
LibPatchPcdSetPtr (
          void       *PatchVariable,
          UINTN       MaximumDatumSize,
       UINTN       *SizeOfBuffer,
   const  void        *Buffer
  );

/**
  Sets a value of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
  to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPatchPcdSetPtrS (
        void     *PatchVariable,
         UINTN    MaximumDatumSize,
      UINTN    *SizeOfBuffer,
   const void     *Buffer
  );

/**
  Sets a value and size of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
  and SizeOfBuffer. Buffer is returned.  If SizeOfBuffer is greater than
  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
  NULL to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and NULL must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfPatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return Return the pointer to the Buffer that was set.

**/
void *
__cdecl
LibPatchPcdSetPtrAndSize (
         void        *PatchVariable,
         UINTN       *SizeOfPatchVariable,
          UINTN       MaximumDatumSize,
       UINTN       *SizeOfBuffer,
   const  void        *Buffer
  );

/**
  Sets a value and size of a patchable PCD entry that is type pointer.

  Sets the PCD entry specified by PatchVariable to the value specified
  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
  to indicate that the set operation was not actually performed.
  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.

  If PatchVariable is NULL, then ASSERT().
  If SizeOfPatchVariable is NULL, then ASSERT().
  If SizeOfBuffer is NULL, then ASSERT().
  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().

  @param[out] PatchVariable     A pointer to the global variable in a module that is
                                the target of the set operation.
  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
  @param[in] Buffer             A pointer to the buffer to used to set the target variable.

  @return The status of the set operation.

**/
RETURN_STATUS
__cdecl
LibPatchPcdSetPtrAndSizeS (
        void     *PatchVariable,
        UINTN    *SizeOfPatchVariable,
         UINTN    MaximumDatumSize,
      UINTN    *SizeOfBuffer,
   const void     *Buffer
  );

typedef enum {
  PCD_TYPE_8,
  PCD_TYPE_16,
  PCD_TYPE_32,
  PCD_TYPE_64,
  PCD_TYPE_BOOL,
  PCD_TYPE_PTR
} PCD_TYPE;

typedef struct {
  ///
  /// The returned information associated with the requested TokenNumber. If
  /// TokenNumber is 0, then PcdType is set to PCD_TYPE_8.
  ///
  PCD_TYPE          PcdType;
  ///
  /// The size of the data in bytes associated with the TokenNumber specified. If
  /// TokenNumber is 0, then PcdSize is set 0.
  ///
  UINTN             PcdSize;
  ///
  /// The null-terminated ASCII string associated with a given token. If the
  /// TokenNumber specified was 0, then this field corresponds to the null-terminated
  /// ASCII string associated with the token's namespace Guid. If NULL, there is no
  /// name associated with this request.
  ///
  CHAR8             *PcdName;
} PCD_INFO;


/**
  Retrieve additional information associated with a PCD token.

  This includes information such as the type of value the TokenNumber is associated with as well as possible
  human readable name that is associated with the token.

  If TokenNumber is not in the default token space specified, then ASSERT().

  @param[in]    TokenNumber The PCD token number.
  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
**/
void
__cdecl
LibPcdGetInfo (
          UINTN           TokenNumber,
         PCD_INFO        *PcdInfo
  );

/**
  Retrieve additional information associated with a PCD token.

  This includes information such as the type of value the TokenNumber is associated with as well as possible
  human readable name that is associated with the token.

  If TokenNumber is not in the token space specified by Guid, then ASSERT().

  @param[in]    Guid        The 128-bit unique value that designates the namespace from which to extract the value.
  @param[in]    TokenNumber The PCD token number.
  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
**/
void
__cdecl
LibPcdGetInfoEx (
   const  GUID            *Guid,
          UINTN           TokenNumber,
         PCD_INFO        *PcdInfo
  );

/**
  Retrieve the currently set SKU Id.

  @return   The currently set SKU Id. If the platform has not set at a SKU Id, then the
            default SKU Id value of 0 is returned. If the platform has set a SKU Id, then the currently set SKU
            Id is returned.
**/
UINTN
__cdecl
LibPcdGetSku (
  void
  );

#line 1735 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Library/PcdLib.h"
#line 18 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"

extern GUID  gEfiCallerIdGuid;
extern GUID  gEdkiiDscPlatformGuid;
extern CHAR8 *gEfiCallerBaseName;






// Guids
extern GUID gPlatformAlderLakeTokenSpaceGuid;

// Definition of SkuId Array
extern UINT64 _gPcd_SkuId_Array[];

// Definition of PCDs used in this module





extern const  BOOLEAN  _gPcd_FixedAtBuild_PcdAdlNSupport;

//#define _PCD_SET_MODE_BOOL_PcdAdlNSupport  ASSERT(FALSE)  // It is not allowed to set value for a FIXED_AT_BUILD PCD






#line 50 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\DEBUG\\AutoGen.h"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"


/** @file
  ACPI DSDT table

  Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/

#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Platform\\AlderlakeBoardPkg\\Include\\PlatformBoardId.h"
/** @file
Defines Platform BoardIds

  Copyright (c) 2020 - 2023, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

  This file is automatically generated. Please do NOT modify !!!

**/







// AlderLake-N Boards






// Added for ADL-PS Board IDs






// AlderLake P Board IDs












// AlderLake-S & ADP-S Boards












// Test boards











#line 70 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Platform\\AlderlakeBoardPkg\\Include\\PlatformBoardId.h"
#line 11 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PmcRegs.h"
/** @file
  Register names for PCH PMC device

  Copyright (c) 2021-2022, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/






//
// PCIe config space registers
//



//
// ACPI and legacy I/O register offsets from ACPIBASE
//










































































































































//
// PWRM Registers for IPC interface
//


























//
// PWRM Registers
//
























































































































































































































//
// Low Power Mode requirements - 1st  register
//
//
// Low Power Mode requirements - End register
//
//
// Low Power Mode requirements - data length (byte)
//

//
// Low Power Mode requirements - data length (bit)
//



//
// GPE interrupts definitons
//



//
// PWRM Registers for IPC interface
//

































#line 468 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PmcRegs.h"
#line 12 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\AcpiDebug.h"
/** @file
  Header file for ACPI ADBG enable/disable.

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




// todo: add a PCD to control ACPI debug print
  
  
#line 15 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\AcpiDebug.h"
#line 13 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"

// Definitions for INTB (Interrupt descriptor buffer method)






DefinitionBlock (
  "DSDT.aml",
  "DSDT",
  0x02, // DSDT revision.
        // A Revision field value greater than or equal to 2 signifies that integers
        // declared within the Definition Block are to be evaluated as 64-bit values
  "INTEL",   // OEM ID (6 byte string)
  "ADL     ",// OEM table ID  (8 byte string)
  0x0 // OEM version of DSDT table (4 byte Integer)
)

// BEGIN OF ASL SCOPE
{
  External(\_SB.PC00.GFX0.ALSI)
  External(\_SB.PC00.GFX0.CLID)
  External(\_SB.PC00.GFX0.CDCK)
  External(\_SB.PC00.GFX0.CBLV)
  External(\_SB.PC00.GFX0.GSSE)
  External(\_SB.PC00.GFX0.DD1F, DeviceObj)
  External(\_SB.PC00.GFX0.DD2F, DeviceObj)
  External(\_SB.PC00.SAT0.PRT0, DeviceObj)
  External(\_SB.PC00.SAT0.PRT1, DeviceObj)
  External(\_SB.PC00.SAT0.PRT2, DeviceObj)
  External(\_SB.PC00.SAT0.PRT3, DeviceObj)
  External(\_SB.PC00.SAT0.PRT4, DeviceObj)
  External(\_SB.PC00.SAT0.PRT5, DeviceObj)
  External(\_SB.PC00.SAT0.PRT6, DeviceObj)
  External(\_SB.PC00.SAT0.PRT7, DeviceObj)
  External(\_SB.PC00.GFX0.GDCK, MethodObj)
  External(\_SB.PC00.GFX0.GHDS, MethodObj)
  External(\_SB.PC00.GFX0.AINT, MethodObj)
  External(\_SB.PC00.GFX0.GLID, MethodObj)
  External(\_SB.PC00.GFX0.GSCI, MethodObj)
  External(\_SB.PC00.RP01, DeviceObj)
  External(\_SB.PC00.RP02, DeviceObj)
  External(\_SB.PC00.RP03, DeviceObj)
  External(\_SB.PC00.RP04, DeviceObj)
  External(\_SB.PC00.RP05, DeviceObj)
  External(\_SB.PC00.RP06, DeviceObj)
  External(\_SB.PC00.RP07, DeviceObj)
  External(\_SB.PC00.RP08, DeviceObj)
  External(\_SB.PC00.RP09, DeviceObj)
  External(\_SB.PC00.RP10, DeviceObj)
  External(\_SB.PC00.RP11, DeviceObj)
  External(\_SB.PC00.RP12, DeviceObj)
  External(\_SB.PC00.RP13, DeviceObj)
  External(\_SB.PC00.RP14, DeviceObj)
  External(\_SB.PC00.RP15, DeviceObj)
  External(\_SB.PC00.RP16, DeviceObj)
  External(\_SB.PC00.RP17, DeviceObj)
  External(\_SB.PC00.RP18, DeviceObj)
  External(\_SB.PC00.RP19, DeviceObj)
  External(\_SB.PC00.RP20, DeviceObj)
  External(\_SB.PC00.RP21, DeviceObj)
  External(\_SB.PC00.RP22, DeviceObj)
  External(\_SB.PC00.RP23, DeviceObj)
  External(\_SB.PC00.RP24, DeviceObj)
  External(\_SB.PC00.RP25, DeviceObj)
  External(\_SB.PC00.RP26, DeviceObj)
  External(\_SB.PC00.RP27, DeviceObj)
  External(\_SB.PC00.RP28, DeviceObj)
  External(\_SB.PR00._PSS, MethodObj)
  External(\_SB.PR00.LPSS, PkgObj)
  External(\_SB.PR00.TPSS, PkgObj)
  External(\_SB.PR00._PPC, MethodObj)
  External(\_SB.CPPC, IntObj)
  External(\_TZ.TZ00, DeviceObj)
  External(\_TZ.ETMD, IntObj)
  External(\_TZ.FN00._OFF, MethodObj)
  External(\_SB.PC00.TXHC, DeviceObj) // CPU XHCI object of TCSS, it is a must existed object for CPU TCSS

  // Miscellaneous services enabled in Project

  /** @file
    ACPI Common Include File for PCIE RP ACPI Objects.
  
  @copyright
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"
/** @file
  This file contains definitions of PCIE RP MACRO.

@copyright
  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/




//
// Note:- Macro Value 0 and 1 are treated as Boolean variable by ASL compiler.
// So avoiding using 0,1 as value in C Code. It will be helpful in avoiding
// the confusion during Runtime AML Patching.
//


#line 20 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"



#line 24 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

// Defining MACRO Value for PCH PCIE RP Type.


#line 29 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

// Defining MACRO Value for CPU PCIE RP Type.


#line 34 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

// Defining MACRO Value for ITBT PCIE RP Type.


#line 39 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"


//
// Note:- Macro Value 0 and 1 are treated as Boolean variable by ASL compiler.
// So avoiding using 0,1 as value in C Code. It will be helpful in avoiding
// the confusion during Runtime AML Patching.
//


#line 49 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"



#line 53 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

// Defining MACRO Value for Generic PCIE EP Type.


#line 58 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

// Defining MACRO Value for Discrete Thunderbolt EP Type.


#line 63 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

// Defining MACRO Value for Invalid EP Type.


#line 68 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"

#line 70 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PcieRpMacroDefinition.h"
#line 103 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  
  //
  // MACRO Definations for Printing PCIE RP Info: Start
  // Note: These below MACRO will only work under PCIE RP Scope.
  //
  
  
  
  
  //
  // Note: These above MACRO will only work under PCIE RP Scope.
  // MACRO Definations for Printing PCIE RP Info: End
  //
  
  External (\_SB.PC00,DeviceObj)
  // External Variable for PCIE Rp Device Objects
  External (\_SB.PC00.RP01, DeviceObj)
  External (\_SB.PC00.RP02, DeviceObj)
  External (\_SB.PC00.RP03, DeviceObj)
  External (\_SB.PC00.RP04, DeviceObj)
  External (\_SB.PC00.RP05, DeviceObj)
  External (\_SB.PC00.RP06, DeviceObj)
  External (\_SB.PC00.RP07, DeviceObj)
  External (\_SB.PC00.RP08, DeviceObj)
  External (\_SB.PC00.RP09, DeviceObj)
  External (\_SB.PC00.RP10, DeviceObj)
  External (\_SB.PC00.RP11, DeviceObj)
  External (\_SB.PC00.RP12, DeviceObj)
  External (\_SB.PC00.RP13, DeviceObj)
  External (\_SB.PC00.RP14, DeviceObj)
  External (\_SB.PC00.RP15, DeviceObj)
  External (\_SB.PC00.RP16, DeviceObj)
  External (\_SB.PC00.RP17, DeviceObj)
  External (\_SB.PC00.RP18, DeviceObj)
  External (\_SB.PC00.RP19, DeviceObj)
  External (\_SB.PC00.RP20, DeviceObj)
  External (\_SB.PC00.RP21, DeviceObj)
  External (\_SB.PC00.RP22, DeviceObj)
  External (\_SB.PC00.RP23, DeviceObj)
  External (\_SB.PC00.RP24, DeviceObj)
  External (\_SB.PC00.RP25, DeviceObj)
  External (\_SB.PC00.RP26, DeviceObj)
  External (\_SB.PC00.RP27, DeviceObj)
  External (\_SB.PC00.RP28, DeviceObj)
  
  External (\_SB.PC00.PEG0, DeviceObj)
  External (\_SB.PC00.PEG1, DeviceObj)
  External (\_SB.PC00.PEG2, DeviceObj)
  
  // External Variable holding PCIE Rp Mapped under VMD status
  External (\_SB.PC00.RP01.PRMV, IntObj)
  External (\_SB.PC00.RP02.PRMV, IntObj)
  External (\_SB.PC00.RP03.PRMV, IntObj)
  External (\_SB.PC00.RP04.PRMV, IntObj)
  External (\_SB.PC00.RP05.PRMV, IntObj)
  External (\_SB.PC00.RP06.PRMV, IntObj)
  External (\_SB.PC00.RP07.PRMV, IntObj)
  External (\_SB.PC00.RP08.PRMV, IntObj)
  External (\_SB.PC00.RP09.PRMV, IntObj)
  External (\_SB.PC00.RP10.PRMV, IntObj)
  External (\_SB.PC00.RP11.PRMV, IntObj)
  External (\_SB.PC00.RP12.PRMV, IntObj)
  External (\_SB.PC00.RP13.PRMV, IntObj)
  External (\_SB.PC00.RP14.PRMV, IntObj)
  External (\_SB.PC00.RP15.PRMV, IntObj)
  External (\_SB.PC00.RP16.PRMV, IntObj)
  External (\_SB.PC00.RP17.PRMV, IntObj)
  External (\_SB.PC00.RP18.PRMV, IntObj)
  External (\_SB.PC00.RP19.PRMV, IntObj)
  External (\_SB.PC00.RP20.PRMV, IntObj)
  External (\_SB.PC00.RP21.PRMV, IntObj)
  External (\_SB.PC00.RP22.PRMV, IntObj)
  External (\_SB.PC00.RP23.PRMV, IntObj)
  External (\_SB.PC00.RP24.PRMV, IntObj)
  External (\_SB.PC00.RP25.PRMV, IntObj)
  External (\_SB.PC00.RP26.PRMV, IntObj)
  External (\_SB.PC00.RP27.PRMV, IntObj)
  External (\_SB.PC00.RP28.PRMV, IntObj)
  
  External (\_SB.PC00.PEG0.PRMV, IntObj)
  External (\_SB.PC00.PEG1.PRMV, IntObj)
  External (\_SB.PC00.PEG2.PRMV, IntObj)
  
  
  // External Variable holding PCIE Rp Index Number
  External (\_SB.PC00.RP01.SLOT, IntObj)
  External (\_SB.PC00.RP02.SLOT, IntObj)
  External (\_SB.PC00.RP03.SLOT, IntObj)
  External (\_SB.PC00.RP04.SLOT, IntObj)
  External (\_SB.PC00.RP05.SLOT, IntObj)
  External (\_SB.PC00.RP06.SLOT, IntObj)
  External (\_SB.PC00.RP07.SLOT, IntObj)
  External (\_SB.PC00.RP08.SLOT, IntObj)
  External (\_SB.PC00.RP09.SLOT, IntObj)
  External (\_SB.PC00.RP10.SLOT, IntObj)
  External (\_SB.PC00.RP11.SLOT, IntObj)
  External (\_SB.PC00.RP12.SLOT, IntObj)
  External (\_SB.PC00.RP13.SLOT, IntObj)
  External (\_SB.PC00.RP14.SLOT, IntObj)
  External (\_SB.PC00.RP15.SLOT, IntObj)
  External (\_SB.PC00.RP16.SLOT, IntObj)
  External (\_SB.PC00.RP17.SLOT, IntObj)
  External (\_SB.PC00.RP18.SLOT, IntObj)
  External (\_SB.PC00.RP19.SLOT, IntObj)
  External (\_SB.PC00.RP20.SLOT, IntObj)
  External (\_SB.PC00.RP21.SLOT, IntObj)
  External (\_SB.PC00.RP22.SLOT, IntObj)
  External (\_SB.PC00.RP23.SLOT, IntObj)
  External (\_SB.PC00.RP24.SLOT, IntObj)
  External (\_SB.PC00.RP25.SLOT, IntObj)
  External (\_SB.PC00.RP26.SLOT, IntObj)
  External (\_SB.PC00.RP27.SLOT, IntObj)
  External (\_SB.PC00.RP28.SLOT, IntObj)
  
  External (\_SB.PC00.PEG0.SLOT, IntObj)
  External (\_SB.PC00.PEG1.SLOT, IntObj)
  External (\_SB.PC00.PEG2.SLOT, IntObj)
  
  // External Variable holding PCIE Rp Type Information
  External (\_SB.PC00.RP01.PRTP, IntObj)
  External (\_SB.PC00.RP02.PRTP, IntObj)
  External (\_SB.PC00.RP03.PRTP, IntObj)
  External (\_SB.PC00.RP04.PRTP, IntObj)
  External (\_SB.PC00.RP05.PRTP, IntObj)
  External (\_SB.PC00.RP06.PRTP, IntObj)
  External (\_SB.PC00.RP07.PRTP, IntObj)
  External (\_SB.PC00.RP08.PRTP, IntObj)
  External (\_SB.PC00.RP09.PRTP, IntObj)
  External (\_SB.PC00.RP10.PRTP, IntObj)
  External (\_SB.PC00.RP11.PRTP, IntObj)
  External (\_SB.PC00.RP12.PRTP, IntObj)
  External (\_SB.PC00.RP13.PRTP, IntObj)
  External (\_SB.PC00.RP14.PRTP, IntObj)
  External (\_SB.PC00.RP15.PRTP, IntObj)
  External (\_SB.PC00.RP16.PRTP, IntObj)
  External (\_SB.PC00.RP17.PRTP, IntObj)
  External (\_SB.PC00.RP18.PRTP, IntObj)
  External (\_SB.PC00.RP19.PRTP, IntObj)
  External (\_SB.PC00.RP20.PRTP, IntObj)
  External (\_SB.PC00.RP21.PRTP, IntObj)
  External (\_SB.PC00.RP22.PRTP, IntObj)
  External (\_SB.PC00.RP23.PRTP, IntObj)
  External (\_SB.PC00.RP24.PRTP, IntObj)
  External (\_SB.PC00.RP25.PRTP, IntObj)
  External (\_SB.PC00.RP26.PRTP, IntObj)
  External (\_SB.PC00.RP27.PRTP, IntObj)
  External (\_SB.PC00.RP28.PRTP, IntObj)
  
  External (\_SB.PC00.PEG0.PRTP, IntObj)
  External (\_SB.PC00.PEG1.PRTP, IntObj)
  External (\_SB.PC00.PEG2.PRTP, IntObj)
  
  // External Variable holding PCIE Rp RTD3 Cold Capability
  External (\_SB.PC00.RP01.RD3C, IntObj)
  External (\_SB.PC00.RP02.RD3C, IntObj)
  External (\_SB.PC00.RP03.RD3C, IntObj)
  External (\_SB.PC00.RP04.RD3C, IntObj)
  External (\_SB.PC00.RP05.RD3C, IntObj)
  External (\_SB.PC00.RP06.RD3C, IntObj)
  External (\_SB.PC00.RP07.RD3C, IntObj)
  External (\_SB.PC00.RP08.RD3C, IntObj)
  External (\_SB.PC00.RP09.RD3C, IntObj)
  External (\_SB.PC00.RP10.RD3C, IntObj)
  External (\_SB.PC00.RP11.RD3C, IntObj)
  External (\_SB.PC00.RP12.RD3C, IntObj)
  External (\_SB.PC00.RP13.RD3C, IntObj)
  External (\_SB.PC00.RP14.RD3C, IntObj)
  External (\_SB.PC00.RP15.RD3C, IntObj)
  External (\_SB.PC00.RP16.RD3C, IntObj)
  External (\_SB.PC00.RP17.RD3C, IntObj)
  External (\_SB.PC00.RP18.RD3C, IntObj)
  External (\_SB.PC00.RP19.RD3C, IntObj)
  External (\_SB.PC00.RP20.RD3C, IntObj)
  External (\_SB.PC00.RP21.RD3C, IntObj)
  External (\_SB.PC00.RP22.RD3C, IntObj)
  External (\_SB.PC00.RP23.RD3C, IntObj)
  External (\_SB.PC00.RP24.RD3C, IntObj)
  External (\_SB.PC00.RP25.RD3C, IntObj)
  External (\_SB.PC00.RP26.RD3C, IntObj)
  External (\_SB.PC00.RP27.RD3C, IntObj)
  External (\_SB.PC00.RP28.RD3C, IntObj)
  
  External (\_SB.PC00.PEG0.RD3C, IntObj)
  External (\_SB.PC00.PEG1.RD3C, IntObj)
  External (\_SB.PC00.PEG2.RD3C, IntObj)


  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  ///////////////////////////////////////////////////////////////////////////////////
  //Values are set like this to have ASL compiler reserve enough space for objects
  ///////////////////////////////////////////////////////////////////////////////////
  //
  // Available Sleep states
  //
  Name(SS1,0)
  Name(SS2,0)
  Name(SS3,1)
  Name(SS4,1)
  

  //
  // Automatically generated by GenNvs ver 2.4.6
  // Please DO NOT modify !!!
  //
  
  
  /** @file
    ACPI DSDT table
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
    // Define a Global region of ACPI NVS Region that may be used for any
    // type of implementation.  The starting offset and size will be fixed
    // up by the System BIOS during POST.  Note that the Size must be a word
    // in size to be fixed up correctly.
  
  
  
    OperationRegion(GNVS,SystemMemory,0xFFFF0000,0xAA55)
    Field(GNVS,AnyAcc,Lock,Preserve)
    {  //
    // Miscellaneous Dynamic Registers:
    //
    Offset(0),      OSYS, 16, // Offset(0),     Operating System
    Offset(2),      SMIF, 8,  // Offset(2),     SMI Function Call (ASL to SMI via I/O Trap)
    Offset(3),      PRM0, 8,  // Offset(3),     SMIF - Parameter 0
    Offset(4),      PRM1, 8,  // Offset(4),     SMIF - Parameter 1
    Offset(5),      SCIF, 8,  // Offset(5),     SCI Function Call (SMI to ASL via _L00)
    Offset(6),      PRM2, 8,  // Offset(6),     SCIF - Parameter 0
    Offset(7),      PRM3, 8,  // Offset(7),     SCIF - Parameter 1
    Offset(8),      LCKF, 8,  // Offset(8),     Global Lock Function Call (EC Communication)
    Offset(9),      PRM4, 8,  // Offset(9),     LCKF - Parameter 0
    Offset(10),     PRM5, 8,  // Offset(10),    LCKF - Parameter 1
    Offset(11),     PWRS, 8,  // Offset(11),    Power State (AC Mode = 1)
    Offset(12),     DBGS, 8,  // Offset(12),    Debug State
    //
    // Thermal Policy Registers:
    //
    Offset(13),     THOF, 8,  // Offset(13),    Enable Thermal Offset for KSC
    Offset(14),     ACT1, 8,  // Offset(14),    Active Trip Point 1
    Offset(15),     ACTT, 8,  // Offset(15),    Active Trip Point
    Offset(16),     PSVT, 8,  // Offset(16),    Passive Trip Point
    Offset(17),     TC1V, 8,  // Offset(17),    Passive Trip Point TC1 Value
    Offset(18),     TC2V, 8,  // Offset(18),    Passive Trip Point TC2 Value
    Offset(19),     TSPV, 8,  // Offset(19),    Passive Trip Point TSP Value
    Offset(20),     CRTT, 8,  // Offset(20),    Critical Trip Point
    //
    // Revision Field:
    //
    Offset(21),     REVN, 8,  // Offset(21),    Revison of GlobalNvsArea
    //
    // CPU Identification Registers:
    //
    Offset(22),     APIC, 8,  // Offset(22),    APIC Enabled by SBIOS (APIC Enabled = 1)
    Offset(23),     TCNT, 8,  // Offset(23),    Number of Enabled Threads
    Offset(24),     PCP0, 8,  // Offset(24),    PDC Settings, Processor 0
    Offset(25),     PCP1, 8,  // Offset(25),    PDC Settings, Processor 1
    Offset(26),     PPCM, 8,  // Offset(26),    Maximum PPC state
    Offset(27),     PPMF, 32, // Offset(27),    PPM Flags (Same as CFGD)
    Offset(31),     C67L, 8,  // Offset(31),    C6/C7 Entry/Exit latency
    //
    // SIO Configuration Registers:
    //
    Offset(32),     NATP, 8,  // Offset(32),    National SIO Present
    Offset(33),     CMAP, 8,  // Offset(33),    COM A Port
    Offset(34),     CMBP, 8,  // Offset(34),    COM B Port
    Offset(35),     LPTP, 8,  // Offset(35),    LPT Port
    Offset(36),     FDCP, 8,  // Offset(36),    FDC Port
    Offset(37),     CMCP, 8,  // Offset(37),    SMSC Com Port
    Offset(38),     CIRP, 8,  // Offset(38),    SMSC Com CIR Port
    Offset(39),     SMSC, 8,  // Offset(39),    SMSC1007 SIO Present
    Offset(40),     W381, 8,  // Offset(40),    WPCN381U SIO Present
    Offset(41),     SMC1, 8,  // Offset(41),    SMSC1000 SIO Present
    Offset(42),     ITCM, 8,  // Offset(42),    IT8659  COM
    Offset(43),     ITHW, 8,  // Offset(43),    IT8659  HWMON
    Offset(44),     ITSI, 8,  // Offset(44),    IT8659  SIO Present
    //
    // Extended Mobile Access Values
    //
    Offset(45),     EMAE, 8,  // Offset(45),    EMA Enable
    Offset(46),     EMAP, 16, // Offset(46),    EMA Pointer
    Offset(48),     EMAL, 16, // Offset(48),    EMA Length
    //
    // MEF Registers:
    //
    Offset(50),     MEFE, 8,  // Offset(50),    MEF Enable
    //
    // PCIe Dock Status:
    //
    Offset(51),     DSTS, 8,  // Offset(51),    PCIe Dock Status
    //
    // TPM Registers
    //
    Offset(52),     MORD, 8,  // Offset(52),    Memory Overwrite Request Data
    Offset(53),     TCGP, 8,  // Offset(53),    Used for save the Mor and/or physical presence paramter
    Offset(54),     PPRP, 32, // Offset(54),    Physical Presence request operation response
    Offset(58),     PPRQ, 8,  // Offset(58),    Physical Presence request operation
    Offset(59),     LPPR, 8,  // Offset(59),    Last Physical Presence request operation
    //
    // SATA Registers:
    //
    Offset(60),     IDEM, 8,  // Offset(60),    IDE Mode (Compatible\Enhanced)
    //
    // Board Id
    //
    Offset(61),     PLID, 8,  // Offset(61),    Platform id
    Offset(62),     BTYP, 8,  // Offset(62),    Board Type
    //
    // PCIe Hot Plug
    //
    Offset(63),     OSCC, 8,  // Offset(63),    PCIE OSC Control
    Offset(64),     NEXP, 8,  // Offset(64),    Native PCIE Setup Value
    //
    // USB Sideband Deferring Support
    //
    Offset(65),     SBV1, 8,  // Offset(65),    USB Sideband Deferring GPE Vector (HOST_ALERT#1)
    Offset(66),     SBV2, 8,  // Offset(66),    USB Sideband Deferring GPE Vector (HOST_ALERT#2)
    //
    // Embedded Controller Availability Flag.
    //
    Offset(67),     ECON, 8,  // Offset(67),    Embedded Controller Availability Flag.
    //
    // Global Variables
    //
    Offset(68),     DSEN, 8,  // Offset(68),    _DOS Display Support Flag.
    Offset(69),     GPIC, 8,  // Offset(69),    Global IOAPIC/8259 Interrupt Mode Flag.
    Offset(70),     CTYP, 8,  // Offset(70),    Global Cooling Type Flag.
    Offset(71),     L01C, 8,  // Offset(71),    Global L01 Counter.
    Offset(72),     VFN0, 8,  // Offset(72),    Virtual Fan0 Status.
    Offset(73),     VFN1, 8,  // Offset(73),    Virtual Fan1 Status.
    Offset(74),     VFN2, 8,  // Offset(74),    Virtual Fan2 Status.
    Offset(75),     VFN3, 8,  // Offset(75),    Virtual Fan3 Status.
    Offset(76),     VFN4, 8,  // Offset(76),    Virtual Fan4 Status.
    Offset(77),     VFN5, 8,  // Offset(77),    Virtual Fan5 Status.
    Offset(78),     VFN6, 8,  // Offset(78),    Virtual Fan6 Status.
    Offset(79),     VFN7, 8,  // Offset(79),    Virtual Fan7 Status.
    Offset(80),     VFN8, 8,  // Offset(80),    Virtual Fan8 Status.
    Offset(81),     VFN9, 8,  // Offset(81),    Virtual Fan9 Status.
    //
    // Thermal
    //
    Offset(82),     PNHM, 32, // Offset(82),    CPUID Feature Information [EAX]
    Offset(86),     TBAL, 32, // Offset(86),    Reserved for Thermal Base Low Address for BIOS
    Offset(90),     TBAH, 32, // Offset(90),    Reserved for Thermal Base High Address for BIOS
    Offset(94),     TSOD, 8,  // Offset(94),    TS-on-DIMM is chosen in SETUP and present on the DIMM
    //
    // Board info
    //
    Offset(95),     PFLV, 8,  // Offset(95),    Platform Flavor
    Offset(96),     BREV, 16, // Offset(96),    Board Rev
    //
    // Package temperature
    //
    Offset(98),     PAMT, 8,  // Offset(98),    Peci Access Method
    Offset(99),     AC0F, 8,  // Offset(99),    _AC0 Fan Speed
    Offset(100),    AC1F, 8,  // Offset(100),   _AC1 Fan Speed
    //
    // XTU 3.0 Specification
    //
    Offset(101),    XTUB, 32, // Offset(101),   XTU Continous structure Base Address
    Offset(105),    XTUS, 32, // Offset(105),   XMP Size
    Offset(109),    XMPB, 32, // Offset(109),   XMP Base Address
    Offset(113),    DDRF, 8,  // Offset(113),   DDR Reference Frequency
    Offset(114),    RTD3, 8,  // Offset(114),   Runtime D3 support.
    Offset(115),    PEP0, 8,  // Offset(115),   User selctable Delay for Device D0 transition.
    Offset(116),    PEP3, 8,  // Offset(116),   User selctable Delay for Device D3 transition.
    //
    // Intel(R) Dynamic Tuning Technology Devices and trip points
    //
    Offset(117),    DPTF, 8,  // Offset(117),   EnableDptf
    Offset(118),    DCFE, 16, // Offset(118),   EnableDCFG
    Offset(120),    SADE, 8,  // Offset(120),   EnableSaDevice
    //
    // DPPM Devices and trip points
    //
    Offset(121),    FND1, 8,  // Offset(121),   EnableFan1Device
    Offset(122),    AMBD, 8,  // Offset(122),   EnableAmbientDevice
    Offset(123),    AMAT, 8,  // Offset(123),   ActiveThermalTripPointAmbient
    Offset(124),    AMPT, 8,  // Offset(124),   PassiveThermalTripPointAmbient
    Offset(125),    AMCT, 8,  // Offset(125),   CriticalThermalTripPointAmbient
    Offset(126),    AMHT, 8,  // Offset(126),   HotThermalTripPointAmbient
    Offset(127),    SKDE, 8,  // Offset(127),   EnableSkinDevice
    Offset(128),    SKAT, 8,  // Offset(128),   ActiveThermalTripPointSkin
    Offset(129),    SKPT, 8,  // Offset(129),   PassiveThermalTripPointSkin
    Offset(130),    SKCT, 8,  // Offset(130),   CriticalThermalTripPointSkin
    Offset(131),    SKHT, 8,  // Offset(131),   HotThermalTripPointSkin
    Offset(132),    EFDE, 8,  // Offset(132),   EnableExhaustFanDevice
    Offset(133),    EFAT, 8,  // Offset(133),   ActiveThermalTripPointExhaustFan
    Offset(134),    EFPT, 8,  // Offset(134),   PassiveThermalTripPointExhaustFan
    Offset(135),    EFCT, 8,  // Offset(135),   CriticalThermalTripPointExhaustFan
    Offset(136),    EFHT, 8,  // Offset(136),   HotThermalTripPointExhaustFan
    Offset(137),    VRDE, 8,  // Offset(137),   EnableVRDevice
    Offset(138),    VRAT, 8,  // Offset(138),   ActiveThermalTripPointVR
    Offset(139),    VRPT, 8,  // Offset(139),   PassiveThermalTripPointVR
    Offset(140),    VRCT, 8,  // Offset(140),   CriticalThermalTripPointVR
    Offset(141),    VRHT, 8,  // Offset(141),   HotThermalTripPointVR
    //
    // DPPM Policies
    //
    Offset(142),    DPAP, 8,  // Offset(142),   EnableActivePolicy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    Offset(143),    DPPP, 8,  // Offset(143),   EnablePassivePolicy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    Offset(144),    DPCP, 8,  // Offset(144),   EnableCriticalPolicy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    Offset(145),    PIDE, 8,  // Offset(145),   EnablePIDPolicy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    //
    // Miscellaneous Intel(R) Dynamic Tuning Technology
    //
    Offset(146),    PPSZ, 32, // Offset(146),   PPCC Step Size
    Offset(156),              // Offset(150) : Offset(155), Reserved bytes
    //
    // Comms Hub
    //
    Offset(156),    CHEN, 8,  // Offset(156),   Comms Hub Enable/Disable
    Offset(157),    S0ID, 8,  // Offset(157),   Low Power S0 Idle Enable
    //
    // BIOS only version of Config TDP
    //
    Offset(158),    CTDB, 8,  // Offset(158),   enable/disable BIOS only version of Config TDP
    Offset(159),    DKSM, 8,  // Offset(159),   Dock SMI number
    //
    // LPC SIO configuration
    //
    Offset(160),    SIO1, 16, // Offset(160),   SIO config port 1
    Offset(162),    SIO2, 16, // Offset(162),   SIO config port 2
    Offset(164),    SPBA, 16, // Offset(164),   SIO PME Base Address
    Offset(499),              // Offset(166) : Offset(498), Reserved bytes
    Offset(499),    PG3S, 8,  // Offset(499),   Pseudo G3 Enable / Disable
    Offset(500),    PWRE, 8,  // Offset(500),   EnablePowerParticipant
    Offset(501),        , 16, // Offset(501),   DPTFRsvd0
    Offset(503),    PPPR, 16, // Offset(503),   PowerParticipantPollingRate
    Offset(505),    PBPE, 8,  // Offset(505),   EnablePowerBossPolicy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    Offset(506),    VSPE, 8,  // Offset(506),   EnableVSPolicy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    Offset(507),    RFIM, 8,  // Offset(507),   RFI Mitigation @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    Offset(515),              // Offset(508) : Offset(514), Reserved bytes
    Offset(515),    XHPR, 8,  // Offset(515),   RTD3 USB Power Resource config
    Offset(516),    RIC0, 8,  // Offset(516),   RTD3 support for I2C0 SH
    Offset(517),    GBSX, 8,  // Offset(517),   Virtual GPIO button Notify Sleep State Change
    Offset(518),    IUBE, 8,  // Offset(518),   IUER Button Enable
    Offset(519),    IUCE, 8,  // Offset(519),   IUER Convertible Enable
    Offset(520),    IUDE, 8,  // Offset(520),   IUER Dock Enable
    Offset(521),    ECNO, 8,  // Offset(521),   EC Notification of Low Power S0 Idle State
    Offset(522),    AUDD, 16, // Offset(522),   RTD3 Audio Codec device delay
    Offset(524),    IC0D, 16, // Offset(524),   RTD3 TouchPad delay time after applying power to device
    Offset(526),    IC1D, 16, // Offset(526),   RTD3 TouchPanel delay time after applying power to device
    Offset(528),    IC1S, 16, // Offset(528),   RTD3 SensorHub delay time after applying power to device
    Offset(530),    VRRD, 16, // Offset(530),   VR Ramp up delay
    Offset(532),    PSCP, 8,  // Offset(532),   P-state Capping
    Offset(533),    I20D, 16, // Offset(533),   Delay in _PS0 after powering up I2C0 Controller
    Offset(535),    I21D, 16, // Offset(535),   Delay in _PS0 after powering up I2C1 Controller
    Offset(537),    RCG0, 16, // Offset(537),   RTD3 Config Setting0(BIT0:ZPODD, BIT1:Reserved, BIT2:PCIe NVMe, BIT3:BT, BIT4:SKL SDS SIP I2C Touch, BIT6:Card Reader, BIT7:WWAN)
    Offset(539),    RCG1, 16, // Offset(539),   RTD3 Config Setting1(BIT0:Sata Port0, BIT1:Sata Port1, BIT2:Sata Port2, BIT3:Sata Port3)
    Offset(541),    P2ME, 8,  // Offset(541),   Ps2 Mouse Enable
    Offset(542),    P2MK, 8,  // Offset(542),   Ps2 Keyboard and Mouse Enable
    Offset(543),    SSH0, 16, // Offset(543),   SSCN-HIGH for I2C0
    Offset(545),    SSL0, 16, // Offset(545),   SSCN-LOW  for I2C0
    Offset(547),    SSD0, 16, // Offset(547),   SSCN-HOLD for I2C0
    Offset(549),    FMH0, 16, // Offset(549),   FMCN-HIGH for I2C0
    Offset(551),    FML0, 16, // Offset(551),   FMCN-LOW  for I2C0
    Offset(553),    FMD0, 16, // Offset(553),   FMCN-HOLD for I2C0
    Offset(555),    FPH0, 16, // Offset(555),   FPCN-HIGH for I2C0
    Offset(557),    FPL0, 16, // Offset(557),   FPCN-LOW  for I2C0
    Offset(559),    FPD0, 16, // Offset(559),   FPCN-HOLD for I2C0
    Offset(561),    HSH0, 16, // Offset(561),   HSCN-HIGH for I2C0
    Offset(563),    HSL0, 16, // Offset(563),   HSCN-LOW  for I2C0
    Offset(565),    HSD0, 16, // Offset(565),   HSCN-HOLD for I2C0
    Offset(573),              // Offset(567) : Offset(572), Reserved bytes
    Offset(573),    SSH1, 16, // Offset(573),   SSCN-HIGH for I2C1
    Offset(575),    SSL1, 16, // Offset(575),   SSCN-LOW  for I2C1
    Offset(577),    SSD1, 16, // Offset(577),   SSCN-HOLD for I2C1
    Offset(579),    FMH1, 16, // Offset(579),   FMCN-HIGH for I2C1
    Offset(581),    FML1, 16, // Offset(581),   FMCN-LOW  for I2C1
    Offset(583),    FMD1, 16, // Offset(583),   FMCN-HOLD for I2C1
    Offset(585),    FPH1, 16, // Offset(585),   FPCN-HIGH for I2C1
    Offset(587),    FPL1, 16, // Offset(587),   FPCN-LOW  for I2C1
    Offset(589),    FPD1, 16, // Offset(589),   FPCN-HOLD for I2C1
    Offset(591),    HSH1, 16, // Offset(591),   HSCN-HIGH for I2C1
    Offset(593),    HSL1, 16, // Offset(593),   HSCN-LOW  for I2C1
    Offset(595),    HSD1, 16, // Offset(595),   HSCN-HOLD for I2C1
    Offset(598),              // Offset(597) : Offset(597), Reserved bytes
    Offset(598),    SSH2, 16, // Offset(598),   SSCN-HIGH for I2C2
    Offset(600),    SSL2, 16, // Offset(600),   SSCN-LOW  for I2C2
    Offset(602),    SSD2, 16, // Offset(602),   SSCN-HOLD for I2C2
    Offset(604),    FMH2, 16, // Offset(604),   FMCN-HIGH for I2C2
    Offset(606),    FML2, 16, // Offset(606),   FMCN-LOW  for I2C2
    Offset(608),    FMD2, 16, // Offset(608),   FMCN-HOLD for I2C2
    Offset(610),    FPH2, 16, // Offset(610),   FPCN-HIGH for I2C2
    Offset(612),    FPL2, 16, // Offset(612),   FPCN-LOW  for I2C2
    Offset(614),    FPD2, 16, // Offset(614),   FPCN-HOLD for I2C2
    Offset(616),    HSH2, 16, // Offset(616),   HSCN-HIGH for I2C2
    Offset(618),    HSL2, 16, // Offset(618),   HSCN-LOW  for I2C2
    Offset(620),    HSD2, 16, // Offset(620),   HSCN-HOLD for I2C2
    Offset(623),              // Offset(622) : Offset(622), Reserved bytes
    Offset(623),    SSH3, 16, // Offset(623),   SSCN-HIGH for I2C3
    Offset(625),    SSL3, 16, // Offset(625),   SSCN-LOW  for I2C3
    Offset(627),    SSD3, 16, // Offset(627),   SSCN-HOLD for I2C3
    Offset(629),    FMH3, 16, // Offset(629),   FMCN-HIGH for I2C3
    Offset(631),    FML3, 16, // Offset(631),   FMCN-LOW  for I2C3
    Offset(633),    FMD3, 16, // Offset(633),   FMCN-HOLD for I2C3
    Offset(635),    FPH3, 16, // Offset(635),   FPCN-HIGH for I2C3
    Offset(637),    FPL3, 16, // Offset(637),   FPCN-LOW  for I2C3
    Offset(639),    FPD3, 16, // Offset(639),   FPCN-HOLD for I2C3
    Offset(641),    HSH3, 16, // Offset(641),   HSCN-HIGH for I2C3
    Offset(643),    HSL3, 16, // Offset(643),   HSCN-LOW  for I2C3
    Offset(645),    HSD3, 16, // Offset(645),   HSCN-HOLD for I2C3
    Offset(648),              // Offset(647) : Offset(647), Reserved bytes
    Offset(648),    SSH4, 16, // Offset(648),   SSCN-HIGH for I2C4
    Offset(650),    SSL4, 16, // Offset(650),   SSCN-LOW  for I2C4
    Offset(652),    SSD4, 16, // Offset(652),   SSCN-HOLD for I2C4
    Offset(654),    FMH4, 16, // Offset(654),   FMCN-HIGH for I2C4
    Offset(656),    FML4, 16, // Offset(656),   FMCN-LOW  for I2C4
    Offset(658),    FMD4, 16, // Offset(658),   FMCN-HOLD for I2C4
    Offset(660),    FPH4, 16, // Offset(660),   FPCN-HIGH for I2C4
    Offset(662),    FPL4, 16, // Offset(662),   FPCN-LOW  for I2C4
    Offset(664),    FPD4, 16, // Offset(664),   FPCN-HOLD for I2C4
    Offset(666),    HSH4, 16, // Offset(666),   HSCN-HIGH for I2C4
    Offset(668),    HSL4, 16, // Offset(668),   HSCN-LOW  for I2C4
    Offset(670),    HSD4, 16, // Offset(670),   HSCN-HOLD for I2C4
    Offset(673),              // Offset(672) : Offset(672), Reserved bytes
    Offset(673),    SSH5, 16, // Offset(673),   SSCN-HIGH for I2C5
    Offset(675),    SSL5, 16, // Offset(675),   SSCN-LOW  for I2C5
    Offset(677),    SSD5, 16, // Offset(677),   SSCN-HOLD for I2C5
    Offset(679),    FMH5, 16, // Offset(679),   FMCN-HIGH for I2C5
    Offset(681),    FML5, 16, // Offset(681),   FMCN-LOW  for I2C5
    Offset(683),    FMD5, 16, // Offset(683),   FMCN-HOLD for I2C5
    Offset(685),    FPH5, 16, // Offset(685),   FPCN-HIGH for I2C5
    Offset(687),    FPL5, 16, // Offset(687),   FPCN-LOW  for I2C5
    Offset(689),    FPD5, 16, // Offset(689),   FPCN-HOLD for I2C5
    Offset(691),    HSH5, 16, // Offset(691),   HSCN-HIGH for I2C5
    Offset(693),    HSL5, 16, // Offset(693),   HSCN-LOW  for I2C5
    Offset(695),    HSD5, 16, // Offset(695),   HSCN-HOLD for I2C5
    Offset(698),              // Offset(697) : Offset(697), Reserved bytes
    Offset(698),    M0C0, 16, // Offset(698),   M0D3 for I2C0
    Offset(700),    M1C0, 16, // Offset(700),   M1D3 for I2C0
    Offset(702),    M0C1, 16, // Offset(702),   M0D3 for I2C1
    Offset(704),    M1C1, 16, // Offset(704),   M1D3 for I2C1
    Offset(706),    M0C2, 16, // Offset(706),   M0D3 for I2C2
    Offset(708),    M1C2, 16, // Offset(708),   M1D3 for I2C2
    Offset(710),    M0C3, 16, // Offset(710),   M0D3 for I2C3
    Offset(712),    M1C3, 16, // Offset(712),   M1D3 for I2C3
    Offset(714),    M0C4, 16, // Offset(714),   M0D3 for I2C4
    Offset(716),    M1C4, 16, // Offset(716),   M1D3 for I2C4
    Offset(718),    M0C5, 16, // Offset(718),   M0D3 for I2C5
    Offset(720),    M1C5, 16, // Offset(720),   M1D3 for I2C5
    Offset(722),    M0C6, 16, // Offset(722),   M0D3 for SPI0
    Offset(724),    M1C6, 16, // Offset(724),   M1D3 for SPI0
    Offset(726),    M0C7, 16, // Offset(726),   M0D3 for SPI1
    Offset(728),    M1C7, 16, // Offset(728),   M1D3 for SPI1
    Offset(730),    M0C8, 16, // Offset(730),   M0D3 for SPI2
    Offset(732),    M1C8, 16, // Offset(732),   M1D3 for SPI2
    Offset(735),              // Offset(734) : Offset(734), Reserved bytes
    Offset(735),    M0C9, 16, // Offset(735),   M0D3 for UART0
    Offset(737),    M1C9, 16, // Offset(737),   M1D3 for UART0
    Offset(739),    M0CA, 16, // Offset(739),   M0D3 for UART1
    Offset(741),    M1CA, 16, // Offset(741),   M1D3 for UART1
    Offset(743),    M0CB, 16, // Offset(743),   M0D3 for UART2
    Offset(745),    M1CB, 16, // Offset(745),   M1D3 for UART2
    Offset(748),              // Offset(747) : Offset(747), Reserved bytes
    //
    // Driver Mode
    //
    Offset(748),    GIRQ, 32, // Offset(748),   GPIO IRQ
    Offset(752),    DMTP, 8,  // Offset(752),   PIRQS 34,50(GPIO)
    Offset(753),    DMTD, 8,  // Offset(753),   PIRQX 39,55(GPIO)
    Offset(754),    DMSH, 8,  // Offset(754),   PIRQM 28,14(GPIO)
    Offset(755),    SHSB, 8,  // Offset(755),   Sensor Standby mode
    Offset(756),    PLCS, 8,  // Offset(756),   set PL1 limit when entering CS
    Offset(757),    PLVL, 16, // Offset(757),   PL1 limit value
    Offset(759),    WWSD, 8,  // Offset(759),   EnableWwanTempSensorDevice
    Offset(760),    CVSD, 8,  // Offset(760),   EnableCpuVrTempSensorDevice
    Offset(761),    SSDD, 8,  // Offset(761),   EnableSsdTempSensorDevice
    Offset(762),    INLD, 8,  // Offset(762),   EnableInletFanTempSensorDevice
    Offset(763),    IFAT, 8,  // Offset(763),   ActiveThermalTripPointInletFan
    Offset(764),    IFPT, 8,  // Offset(764),   PassiveThermalTripPointInletFan
    Offset(765),    IFCT, 8,  // Offset(765),   CriticalThermalTripPointInletFan
    Offset(766),    IFHT, 8,  // Offset(766),   HotThermalTripPointInletFan
    Offset(767),    USBH, 8,  // Offset(767),   Sensor Hub Type - (0)None, (1)USB, (2)I2C Intel, (3)I2C STM
    Offset(768),    BCV4, 8,  // Offset(768),   Broadcom's Bluetooth adapter's revision
    Offset(769),    WTV0, 8,  // Offset(769),   I2C0/WITT devices version
    Offset(770),    WTV1, 8,  // Offset(770),   I2C1/WITT devices version
    Offset(771),    APFU, 8,  // Offset(771),   Atmel panel FW update Enable/Disable
    Offset(778),              // Offset(772) : Offset(777), Reserved bytes
    Offset(778),    PEPC, 64, // Offset(778),   PEP Constraints
    // Bit[1:0] - Storage (0:None, 1:Storage Controller, 2:Raid)
    // Bit[2]   - En/Dis UART0
    // Bit[3]   - En/Dis UART1
    // Bit[4]   - En/Dis I2C0
    // Bit[5]   - En/Dis I2C1
    // Bit[6]   - En/Dis XHCI
    // Bit[8:7]  - HD Audio (includes ADSP) (0: No Constraints or 1: D0/F1 or 3:D3)
    // Bit[9]   - En/Dis Gfx
    // Bit[10]  - En/Dis CPU
    // Bit[11]  - En/Dis EMMC
    // Bit[12]  - En/Dis SDXC
    // Bit[13]  - En/Dis I2C2
    // Bit[14]  - En/Dis I2C3
    // Bit[15]  - En/Dis I2C4
    // Bit[16]  - En/Dis I2C5
    // Bit[17]  - En/Dis UART2
    // Bit[18]  - En/Dis SPI0
    // Bit[19]  - En/Dis SPI1
    // Bit[20]  - En/Dis SPI2
    // Bit[21]  - En/Dis IPU0
    // Bit[22]  - En/Dis CSME
    // Bit[23]  - En/Dis LAN(GBE)
    // Bit[24]  - En/Dis PEG0
    // Bit[25]  - En/Dis THC0
    // Bit[26]  - En/Dis THC1
    // Bit[27]  - Reserved
    // Bit[28]  - En/Dis I2C6
    // Bit[29]  - En/Dis TCSS IPs/DTBT
    // Bit[30]  - En/Dis GNA
    // Bit[31]  - En/Dis VMD0
    // Bit[32]  - En/Dis HECI3
    // Bit[34:33]  - PCIe Storage RP(0: No Constraints or 1: D0/F1 or 3:D3)
    // Bit[36:35] - Pcie Lan (0:No Constraint or 1:D0/F1 or 3:D3)
    // Bit[38:37] - Pcie Wlan (0:No Constraint or 1:D0/F1 or 3:D3)
    // Bit[40:39] - Pcie Gfx (0:No Constraint or 1:D0/F1 or 3:D3)
    // Bit[42:41] - Pcie Other (0:No Constraint or 1:D0/F1 or 3:D3)
    // Bit[43]  - En/Dis DG on x8 PEG port (PEG1)
    // Bit[44]  - En/Dis UFS0
    // Bit[45]  - En/Dis UFS1
    // Bit[46]  - En/Dis I2C7
    Offset(786),    VRSD, 16, // Offset(786),   VR Staggering delay
    Offset(788),    PB1E, 8,  // Offset(788),   10sec Power button support
    // Bit0: 10 sec P-button Enable/Disable
    // Bit1: Internal Flag
    // Bit2: Rotation Lock flag, 0:unlock, 1:lock
    // Bit3: Slate/Laptop Mode Flag, 0: Slate, 1: Laptop
    // Bit4: Undock / Dock Flag, 0: Undock, 1: Dock
    // Bit5: VBDL Flag. 0: VBDL is not called, 1: VBDL is called, Virtual Button Driver is loaded.
    // Bit7-6: Reserved for future use.
    //
    // Generation Id(Tock/Tick)
    //
    Offset(789),    GNID, 8,  // Offset(789),   Generation Id(0=Shark bay, 1=Crescent Bay)
    Offset(800),              // Offset(790) : Offset(799), Reserved bytes
    Offset(800),    AUPL, 32, // Offset(800),   Maximum aux power available for PCIe root ports
    //
    // Intel(R) Dynamic Tuning Technology
    //
    Offset(807),              // Offset(804) : Offset(806), Reserved bytes
    Offset(807),    CHGE, 8,  // Offset(807),   EnableChargerParticipant
    Offset(808),    AMC3, 8,  // Offset(808),   CriticalThermalTripPointAmbientS3
    Offset(809),    SKC3, 8,  // Offset(809),   CriticalThermalTripPointSkinS3
    Offset(810),    EFC3, 8,  // Offset(810),   CriticalThermalTripPointExhaustFanS3
    Offset(811),    VRC3, 8,  // Offset(811),   CriticalThermalTripPointVRS3
    Offset(812),    IFC3, 8,  // Offset(812),   CriticalThermalTripPointInletFanS3
    Offset(813),    WGC3, 8,  // Offset(813),   CriticalThermalTripPointWGigS3
    Offset(814),    ESPC, 8,  // Offset(814),   Set to indicate to PEP that constraints at SATA ports should be enumerated
    //
    // Intel(R) Dynamic Tuning Technology
    //
    Offset(815),    BATR, 8,  // Offset(815),   EnableBatteryParticipant
    Offset(816),    IN34, 8,  // Offset(816),   EnableInt3400Device.
    Offset(817),    ECLP, 8,  // Offset(817),   EC Low Power Mode: 1 - Enabled, 0 - Disabled
    Offset(818),    MEMS, 8,  // Offset(818),   ThermalSamplingPeriodTMEM @deprecated. Memory Participant is not POR for Intel(R) Dynamic Tuning Technology
    Offset(819),    S1DE, 8,  // Offset(819),   EnableSen1Participant
    Offset(820),    S2DE, 8,  // Offset(820),   EnableSen2Participant
    Offset(821),    S3DE, 8,  // Offset(821),   EnableSen3Participant
    Offset(822),    S4DE, 8,  // Offset(822),   EnableSen4Participant
    Offset(823),    S5DE, 8,  // Offset(823),   EnableSen5Participant
    Offset(824),    S1S3, 8,  // Offset(824),   CriticalThermalTripPointSen1S3
    Offset(825),    S2S3, 8,  // Offset(825),   CriticalThermalTripPointSen2S3
    Offset(826),    S3S3, 8,  // Offset(826),   CriticalThermalTripPointSen3S3
    Offset(827),    S4S3, 8,  // Offset(827),   CriticalThermalTripPointSen4S3
    Offset(828),    S5S3, 8,  // Offset(828),   CriticalThermalTripPointSen5S3
    Offset(829),    PSME, 8,  // Offset(829),   PowerSharingManagerEnable
    Offset(830),    PDT1, 8,  // Offset(830),   PsmSplcDomainType1
    Offset(831),    PLM1, 32, // Offset(831),   PsmSplcPowerLimit1
    Offset(835),    PTW1, 32, // Offset(835),   PsmSplcTimeWindow1
    Offset(839),    DDT1, 8,  // Offset(839),   PsmDplcDomainType1
    Offset(840),    DDP1, 8,  // Offset(840),   PsmDplcDomainPreference1
    Offset(841),    DLI1, 16, // Offset(841),   PsmDplcPowerLimitIndex1
    Offset(843),    DPL1, 16, // Offset(843),   PsmDplcDefaultPowerLimit1
    Offset(845),    DTW1, 32, // Offset(845),   PsmDplcDefaultTimeWindow1
    Offset(849),    DMI1, 16, // Offset(849),   PsmDplcMinimumPowerLimit1
    Offset(851),    DMA1, 16, // Offset(851),   PsmDplcMaximumPowerLimit1
    Offset(853),    DMT1, 16, // Offset(853),   PsmDplcMaximumTimeWindow1
    Offset(855),    WIFE, 8,  // Offset(855),   WifiEnable
    Offset(856),    DOM1, 8,  // Offset(856),   WifiDomainType1
    Offset(857),    LIM1, 16, // Offset(857),   WifiPowerLimit1
    Offset(859),    TIM1, 32, // Offset(859),   WifiTimeWindow1
    Offset(863),    TRD0, 8,  // Offset(863),   TRxDelay0
    Offset(864),    TRL0, 8,  // Offset(864),   TRxCableLength0
    Offset(865),    TRD1, 8,  // Offset(865),   TRxDelay1
    Offset(866),    TRL1, 8,  // Offset(866),   TRxCableLength1
    Offset(867),    WDM1, 8,  // Offset(867),   WrddDomainType1
    Offset(868),    CID1, 16, // Offset(868),   WrddCountryIndentifier1
    Offset(1018),             // Offset(870) : Offset(1017), Reserved bytes
    Offset(1018),   APPE, 8,  // Offset(1018),  Adaptive Performance Policy @deprecated. Intel(R) Dynamic Tuning can dynamically enable/disable policies
    //
    // Intel Serial(R) IO Sensor Device Selection
    //
    Offset(1019),   SDS0, 8,  // Offset(1019),  SerialIo Devices for controller0
    Offset(1020),   SDS1, 8,  // Offset(1020),  SerialIo Devices for controller1
    Offset(1021),   SDS2, 8,  // Offset(1021),  SerialIo Devices for controller2
    Offset(1022),   SDS3, 8,  // Offset(1022),  SerialIo Devices for controller3
    Offset(1023),   SDS4, 8,  // Offset(1023),  SerialIo Devices for controller4
    Offset(1024),   SDS5, 8,  // Offset(1024),  SerialIo Devices for controller5
    Offset(1025),   SDS6, 8,  // Offset(1025),  SerialIo Devices for controller6
    Offset(1026),   SDS7, 8,  // Offset(1026),  SerialIo Devices for controller7
    Offset(1027),   SDS8, 8,  // Offset(1027),  SerialIo Devices for controller8
    Offset(1028),   SDS9, 8,  // Offset(1028),  SerialIo Devices for controller9
    Offset(1029),   SDSA, 8,  // Offset(1029),  SerialIo Devices for controller10
    Offset(1030),   TPLT, 8,  // Offset(1030),  I2C SerialIo Devices Type of TouchPanel
    Offset(1031),   TPLM, 8,  // Offset(1031),  I2C SerialIo Devices Interrupt Mode for TouchPanel
    Offset(1032),   TPLB, 8,  // Offset(1032),  I2C Custom TouchPanel's BUS Address
    Offset(1033),   TPLH, 16, // Offset(1033),  I2C Custom TouchPanel's HID Address
    Offset(1035),   TPLS, 8,  // Offset(1035),  I2C Custom TouchPanel's BUS Speed
    Offset(1036),   TPDT, 8,  // Offset(1036),  I2C SerialIo Devices Type of TouchPad
    Offset(1037),   TPDM, 8,  // Offset(1037),  I2C SerialIo Devices Interrupt Mode for TouchPad
    Offset(1038),   TPDB, 8,  // Offset(1038),  I2C Custom TouchPad's BUS Address
    Offset(1039),   TPDH, 16, // Offset(1039),  I2C Custom TouchPad's HID Address
    Offset(1041),   TPDS, 8,  // Offset(1041),  I2C Custom TouchPad's BUS Speed
    Offset(1042),   FPTT, 8,  // Offset(1042),  SPI SerialIo Devices Type of FingerPrint
    Offset(1043),   FPTM, 8,  // Offset(1043),  SPI SerialIo Devices Interrupt Mode for FingerPrint
    Offset(1044),   WTVX, 8,  // Offset(1044),  WITT test devices' version
    Offset(1045),   WITX, 8,  // Offset(1045),  WITT test devices' connection point
    Offset(1046),   SIOI, 8,  // Offset(1046),  WITT SIO I2C test devices' connection point
    Offset(1047),   SIOS, 8,  // Offset(1047),  WITT SIO SPI test devices' connection point
    Offset(1048),   GPTD, 8,  // Offset(1048),  GPIO test devices
    Offset(1049),   GDBT, 16, // Offset(1049),  GPIO test devices' debounce value,
    Offset(1051),   UTKX, 8,  // Offset(1051),  UTK test devices' connection point
    Offset(1052),   SPTD, 8,  // Offset(1052),  SerialIo additional test devices
    // Test Device for Serial IOs
    Offset(1053),   SII0, 8,  // Offset(1053),  SIO I2C0 test devices' connection point
    Offset(1054),   SII1, 8,  // Offset(1054),  SIO I2C1 test devices' connection point
    Offset(1055),   SII2, 8,  // Offset(1055),  SIO I2C2 test devices' connection point
    Offset(1056),   SII3, 8,  // Offset(1056),  SIO I2C3 test devices' connection point
    Offset(1057),   SII4, 8,  // Offset(1057),  SIO I2C4 test devices' connection point
    Offset(1058),   SII5, 8,  // Offset(1058),  SIO I2C5 test devices' connection point
    Offset(1059),   SIS0, 8,  // Offset(1059),  SIO SPI0 test devices' connection point
    Offset(1060),   SIS1, 8,  // Offset(1060),  SIO SPI1 test devices' connection point
    Offset(1061),   SIS2, 8,  // Offset(1061),  SIO SPI2 test devices' connection point
    Offset(1066),             // Offset(1062) : Offset(1065), Reserved bytes
    Offset(1066),   ATLB, 32, // Offset(1066),  Buffer for runtime ACPI Table loading
    Offset(1070),   SDM0, 8,  // Offset(1070),  interrupt mode for controller0 devices
    Offset(1071),   SDM1, 8,  // Offset(1071),  interrupt mode for controller1 devices
    Offset(1072),   SDM2, 8,  // Offset(1072),  interrupt mode for controller2 devices
    Offset(1073),   SDM3, 8,  // Offset(1073),  interrupt mode for controller3 devices
    Offset(1074),   SDM4, 8,  // Offset(1074),  interrupt mode for controller4 devices
    Offset(1075),   SDM5, 8,  // Offset(1075),  interrupt mode for controller5 devices
    Offset(1076),   SDM6, 8,  // Offset(1076),  interrupt mode for controller6 devices
    Offset(1077),   SDM7, 8,  // Offset(1077),  interrupt mode for controller7 devices
    Offset(1078),   SDM8, 8,  // Offset(1078),  interrupt mode for controller8 devices
    Offset(1079),   SDM9, 8,  // Offset(1079),  interrupt mode for controller9 devices
    Offset(1080),   SDMA, 8,  // Offset(1080),  interrupt mode for controller10 devices
    Offset(1081),   SDMB, 8,  // Offset(1081),  interrupt mode for controller11 devices
    Offset(1083),             // Offset(1082) : Offset(1082), Reserved bytes
    Offset(1083),   USTP, 8,  // Offset(1083),  use SerialIo timing parameters
    Offset(1125),             // Offset(1084) : Offset(1124), Reserved bytes
    Offset(1125),   GFPS, 32, // Offset(1125),  Gpio for fingerprint sleep
    Offset(1129),   GFPI, 32, // Offset(1129),  Gpio for fingerprint irq
    Offset(1133),   WBBR, 32, // Offset(1133),  Gpio for modem reset
    Offset(1137),   GBTK, 32, // Offset(1137),  Gpio for Bluetooth RfKill
    Offset(1141),   GBTI, 32, // Offset(1141),  Gpio for Bluetooth interrupt
    Offset(1145),   GPDI, 32, // Offset(1145),  Gpio for touchPaD Interrupt
    Offset(1149),   GPLI, 32, // Offset(1149),  Gpio for touchPaneL Interrupt
    //
    // MipiCam specific
    //
    Offset(1153),   CL00, 8,  // Offset(1153),
    Offset(1154),   CL01, 8,  // Offset(1154),
    Offset(1155),   CL02, 8,  // Offset(1155),
    Offset(1156),   CL03, 8,  // Offset(1156),
    Offset(1157),   CL04, 8,  // Offset(1157),
    Offset(1158),   CL05, 8,  // Offset(1158),
    Offset(1159),   L0EN, 8,  // Offset(1159),
    Offset(1160),   L1EN, 8,  // Offset(1160),
    Offset(1161),   L2EN, 8,  // Offset(1161),
    Offset(1162),   L3EN, 8,  // Offset(1162),
    Offset(1163),   L4EN, 8,  // Offset(1163),
    Offset(1164),   L5EN, 8,  // Offset(1164),
    Offset(1165),   CDIV, 8,  // Offset(1165),  MipiCamLanesClkDiv is @deprecated as the Laneclockdivision option is added and now can be set uniquely for all the links.
    // Control Logic 0 options
    Offset(1166),   C0VE, 8,  // Offset(1166),  Version of CLDB structure
    Offset(1167),   C0TP, 8,  // Offset(1167),  Type
    Offset(1168),   C0CV, 8,  // Offset(1168),  Version of CRD
    Offset(1169),   C0IC, 32, // Offset(1169),  Input Clock
    Offset(1173),   C0GP, 8,  // Offset(1173),  Number of GPIO Pins enabled
    Offset(1174),   C0IB, 8,  // Offset(1174),  I2C Serial Bus Number
    Offset(1175),   C0IA, 16, // Offset(1175),  I2C Address
    Offset(1177),   C0P0, 8,  // Offset(1177),  GPIO Group Pad Number
    Offset(1178),   C0P1, 8,  // Offset(1178),
    Offset(1179),   C0P2, 8,  // Offset(1179),
    Offset(1180),   C0P3, 8,  // Offset(1180),
    Offset(1181),   C0P4, 8,  // Offset(1181),
    Offset(1182),   C0P5, 8,  // Offset(1182),
    Offset(1183),   C0G0, 8,  // Offset(1183),  GPIO Group Number
    Offset(1184),   C0G1, 8,  // Offset(1184),
    Offset(1185),   C0G2, 8,  // Offset(1185),
    Offset(1186),   C0G3, 8,  // Offset(1186),
    Offset(1187),   C0G4, 8,  // Offset(1187),
    Offset(1188),   C0G5, 8,  // Offset(1188),
    Offset(1189),   C0F0, 8,  // Offset(1189),  GPIO Function
    Offset(1190),   C0F1, 8,  // Offset(1190),
    Offset(1191),   C0F2, 8,  // Offset(1191),
    Offset(1192),   C0F3, 8,  // Offset(1192),
    Offset(1193),   C0F4, 8,  // Offset(1193),
    Offset(1194),   C0F5, 8,  // Offset(1194),
    Offset(1195),   C0A0, 8,  // Offset(1195),  GPIO Active Value
    Offset(1196),   C0A1, 8,  // Offset(1196),
    Offset(1197),   C0A2, 8,  // Offset(1197),
    Offset(1198),   C0A3, 8,  // Offset(1198),
    Offset(1199),   C0A4, 8,  // Offset(1199),
    Offset(1200),   C0A5, 8,  // Offset(1200),
    Offset(1201),   C0I0, 8,  // Offset(1201),  GPIO Initial Value
    Offset(1202),   C0I1, 8,  // Offset(1202),
    Offset(1203),   C0I2, 8,  // Offset(1203),
    Offset(1204),   C0I3, 8,  // Offset(1204),
    Offset(1205),   C0I4, 8,  // Offset(1205),
    Offset(1206),   C0I5, 8,  // Offset(1206),
    Offset(1207),   C0PL, 8,  // Offset(1207),  Camera Position
    Offset(1208),   C0W0, 8,  // Offset(1208),  WLED1 Flash Max Current
    Offset(1209),   C0W1, 8,  // Offset(1209),  WLED1 Torch Max Current
    Offset(1210),   C0W2, 8,  // Offset(1210),  WLED2 Flash Max Current
    Offset(1211),   C0W3, 8,  // Offset(1211),  WLED2 Torch Max Current
    Offset(1212),   C0SP, 8,  // Offset(1212),  Sub Platform Id
    Offset(1213),   C0W4, 8,  // Offset(1213),  WLED1 Type
    Offset(1214),   C0W5, 8,  // Offset(1214),  WLED2 Type
    Offset(1215),   C0CS, 8,  // Offset(1215),  PCH Clock source
    // Control Logic 1 options
    Offset(1216),   C1VE, 8,  // Offset(1216),  Version of CLDB structure
    Offset(1217),   C1TP, 8,  // Offset(1217),  Type
    Offset(1218),   C1CV, 8,  // Offset(1218),  Version of CRD
    Offset(1219),   C1IC, 32, // Offset(1219),  Input Clock
    Offset(1223),   C1GP, 8,  // Offset(1223),  Number of GPIO Pins enabled
    Offset(1224),   C1IB, 8,  // Offset(1224),  I2C Serial Bus Number
    Offset(1225),   C1IA, 16, // Offset(1225),  I2C Address
    Offset(1227),   C1P0, 8,  // Offset(1227),  GPIO Group Pad Number
    Offset(1228),   C1P1, 8,  // Offset(1228),
    Offset(1229),   C1P2, 8,  // Offset(1229),
    Offset(1230),   C1P3, 8,  // Offset(1230),
    Offset(1231),   C1P4, 8,  // Offset(1231),
    Offset(1232),   C1P5, 8,  // Offset(1232),
    Offset(1233),   C1G0, 8,  // Offset(1233),  GPIO Group Number
    Offset(1234),   C1G1, 8,  // Offset(1234),
    Offset(1235),   C1G2, 8,  // Offset(1235),
    Offset(1236),   C1G3, 8,  // Offset(1236),
    Offset(1237),   C1G4, 8,  // Offset(1237),
    Offset(1238),   C1G5, 8,  // Offset(1238),
    Offset(1239),   C1F0, 8,  // Offset(1239),  GPIO Function
    Offset(1240),   C1F1, 8,  // Offset(1240),
    Offset(1241),   C1F2, 8,  // Offset(1241),
    Offset(1242),   C1F3, 8,  // Offset(1242),
    Offset(1243),   C1F4, 8,  // Offset(1243),
    Offset(1244),   C1F5, 8,  // Offset(1244),
    Offset(1245),   C1A0, 8,  // Offset(1245),  GPIO Active Value
    Offset(1246),   C1A1, 8,  // Offset(1246),
    Offset(1247),   C1A2, 8,  // Offset(1247),
    Offset(1248),   C1A3, 8,  // Offset(1248),
    Offset(1249),   C1A4, 8,  // Offset(1249),
    Offset(1250),   C1A5, 8,  // Offset(1250),
    Offset(1251),   C1I0, 8,  // Offset(1251),  GPIO Initial Value
    Offset(1252),   C1I1, 8,  // Offset(1252),
    Offset(1253),   C1I2, 8,  // Offset(1253),
    Offset(1254),   C1I3, 8,  // Offset(1254),
    Offset(1255),   C1I4, 8,  // Offset(1255),
    Offset(1256),   C1I5, 8,  // Offset(1256),
    Offset(1257),   C1PL, 8,  // Offset(1257),  Camera Position
    Offset(1258),   C1W0, 8,  // Offset(1258),  WLED1 Flash Max Current
    Offset(1259),   C1W1, 8,  // Offset(1259),  WLED1 Torch Max Current
    Offset(1260),   C1W2, 8,  // Offset(1260),  WLED2 Flash Max Current
    Offset(1261),   C1W3, 8,  // Offset(1261),  WLED2 Torch Max Current
    Offset(1262),   C1SP, 8,  // Offset(1262),  Sub Platform Id
    Offset(1263),   C1W4, 8,  // Offset(1263),  WLED1 Type
    Offset(1264),   C1W5, 8,  // Offset(1264),  WLED2 Type
    Offset(1265),   C1CS, 8,  // Offset(1265),  PCH Clock source
    // Control Logic 2 options
    Offset(1266),   C2VE, 8,  // Offset(1266),  Version of CLDB structure
    Offset(1267),   C2TP, 8,  // Offset(1267),  Type
    Offset(1268),   C2CV, 8,  // Offset(1268),  Version of CRD
    Offset(1269),   C2IC, 32, // Offset(1269),  Input Clock
    Offset(1273),   C2GP, 8,  // Offset(1273),  Number of GPIO Pins enabled
    Offset(1274),   C2IB, 8,  // Offset(1274),  I2C Serial Bus Number
    Offset(1275),   C2IA, 16, // Offset(1275),  I2C Address
    Offset(1277),   C2P0, 8,  // Offset(1277),  GPIO Group Pad Number
    Offset(1278),   C2P1, 8,  // Offset(1278),
    Offset(1279),   C2P2, 8,  // Offset(1279),
    Offset(1280),   C2P3, 8,  // Offset(1280),
    Offset(1281),   C2P4, 8,  // Offset(1281),
    Offset(1282),   C2P5, 8,  // Offset(1282),
    Offset(1283),   C2G0, 8,  // Offset(1283),  GPIO Group Number
    Offset(1284),   C2G1, 8,  // Offset(1284),
    Offset(1285),   C2G2, 8,  // Offset(1285),
    Offset(1286),   C2G3, 8,  // Offset(1286),
    Offset(1287),   C2G4, 8,  // Offset(1287),
    Offset(1288),   C2G5, 8,  // Offset(1288),
    Offset(1289),   C2F0, 8,  // Offset(1289),  GPIO Function
    Offset(1290),   C2F1, 8,  // Offset(1290),
    Offset(1291),   C2F2, 8,  // Offset(1291),
    Offset(1292),   C2F3, 8,  // Offset(1292),
    Offset(1293),   C2F4, 8,  // Offset(1293),
    Offset(1294),   C2F5, 8,  // Offset(1294),
    Offset(1295),   C2A0, 8,  // Offset(1295),  GPIO Active Value
    Offset(1296),   C2A1, 8,  // Offset(1296),
    Offset(1297),   C2A2, 8,  // Offset(1297),
    Offset(1298),   C2A3, 8,  // Offset(1298),
    Offset(1299),   C2A4, 8,  // Offset(1299),
    Offset(1300),   C2A5, 8,  // Offset(1300),
    Offset(1301),   C2I0, 8,  // Offset(1301),  GPIO Initial Value
    Offset(1302),   C2I1, 8,  // Offset(1302),
    Offset(1303),   C2I2, 8,  // Offset(1303),
    Offset(1304),   C2I3, 8,  // Offset(1304),
    Offset(1305),   C2I4, 8,  // Offset(1305),
    Offset(1306),   C2I5, 8,  // Offset(1306),
    Offset(1307),   C2PL, 8,  // Offset(1307),  Camera Position
    Offset(1308),   C2W0, 8,  // Offset(1308),  WLED1 Flash Max Current
    Offset(1309),   C2W1, 8,  // Offset(1309),  WLED1 Torch Max Current
    Offset(1310),   C2W2, 8,  // Offset(1310),  WLED2 Flash Max Current
    Offset(1311),   C2W3, 8,  // Offset(1311),  WLED2 Torch Max Current
    Offset(1312),   C2SP, 8,  // Offset(1312),  Sub Platform Id
    Offset(1313),   C2W4, 8,  // Offset(1313),  WLED1 Type
    Offset(1314),   C2W5, 8,  // Offset(1314),  WLED2 Type
    Offset(1315),   C2CS, 8,  // Offset(1315),  PCH Clock source
    // Control Logic 3 options
    Offset(1316),   C3VE, 8,  // Offset(1316),  Version of CLDB structure
    Offset(1317),   C3TP, 8,  // Offset(1317),  Type
    Offset(1318),   C3CV, 8,  // Offset(1318),  Version of CRD
    Offset(1319),   C3IC, 32, // Offset(1319),  Input Clock
    Offset(1323),   C3GP, 8,  // Offset(1323),  Number of GPIO Pins enabled
    Offset(1324),   C3IB, 8,  // Offset(1324),  I2C Serial Bus Number
    Offset(1325),   C3IA, 16, // Offset(1325),  I2C Address
    Offset(1327),   C3P0, 8,  // Offset(1327),  GPIO Group Pad Number
    Offset(1328),   C3P1, 8,  // Offset(1328),
    Offset(1329),   C3P2, 8,  // Offset(1329),
    Offset(1330),   C3P3, 8,  // Offset(1330),
    Offset(1331),   C3P4, 8,  // Offset(1331),
    Offset(1332),   C3P5, 8,  // Offset(1332),
    Offset(1333),   C3G0, 8,  // Offset(1333),  GPIO Group Number
    Offset(1334),   C3G1, 8,  // Offset(1334),
    Offset(1335),   C3G2, 8,  // Offset(1335),
    Offset(1336),   C3G3, 8,  // Offset(1336),
    Offset(1337),   C3G4, 8,  // Offset(1337),
    Offset(1338),   C3G5, 8,  // Offset(1338),
    Offset(1339),   C3F0, 8,  // Offset(1339),  GPIO Function
    Offset(1340),   C3F1, 8,  // Offset(1340),
    Offset(1341),   C3F2, 8,  // Offset(1341),
    Offset(1342),   C3F3, 8,  // Offset(1342),
    Offset(1343),   C3F4, 8,  // Offset(1343),
    Offset(1344),   C3F5, 8,  // Offset(1344),
    Offset(1345),   C3A0, 8,  // Offset(1345),  GPIO Active Value
    Offset(1346),   C3A1, 8,  // Offset(1346),
    Offset(1347),   C3A2, 8,  // Offset(1347),
    Offset(1348),   C3A3, 8,  // Offset(1348),
    Offset(1349),   C3A4, 8,  // Offset(1349),
    Offset(1350),   C3A5, 8,  // Offset(1350),
    Offset(1351),   C3I0, 8,  // Offset(1351),  GPIO Initial Value
    Offset(1352),   C3I1, 8,  // Offset(1352),
    Offset(1353),   C3I2, 8,  // Offset(1353),
    Offset(1354),   C3I3, 8,  // Offset(1354),
    Offset(1355),   C3I4, 8,  // Offset(1355),
    Offset(1356),   C3I5, 8,  // Offset(1356),
    Offset(1357),   C3PL, 8,  // Offset(1357),  Camera Position
    Offset(1358),   C3W0, 8,  // Offset(1358),  WLED1 Flash Max Current
    Offset(1359),   C3W1, 8,  // Offset(1359),  WLED1 Torch Max Current
    Offset(1360),   C3W2, 8,  // Offset(1360),  WLED2 Flash Max Current
    Offset(1361),   C3W3, 8,  // Offset(1361),  WLED2 Torch Max Current
    Offset(1362),   C3SP, 8,  // Offset(1362),  Sub Platform Id
    Offset(1363),   C3W4, 8,  // Offset(1363),  WLED1 Type
    Offset(1364),   C3W5, 8,  // Offset(1364),  WLED2 Type
    Offset(1365),   C3CS, 8,  // Offset(1365),  PCH Clock source
    // Control Logic 4 options
    Offset(1366),   C4VE, 8,  // Offset(1366),  Version of CLDB structure
    Offset(1367),   C4TP, 8,  // Offset(1367),  Type
    Offset(1368),   C4CV, 8,  // Offset(1368),  Version of CRD
    Offset(1369),   C4IC, 32, // Offset(1369),  Input Clock
    Offset(1373),   C4GP, 8,  // Offset(1373),  Number of GPIO Pins enabled
    Offset(1374),   C4IB, 8,  // Offset(1374),  I2C Serial Bus Number
    Offset(1375),   C4IA, 16, // Offset(1375),  I2C Address
    Offset(1377),   C4P0, 8,  // Offset(1377),  GPIO Group Pad Number
    Offset(1378),   C4P1, 8,  // Offset(1378),
    Offset(1379),   C4P2, 8,  // Offset(1379),
    Offset(1380),   C4P3, 8,  // Offset(1380),
    Offset(1381),   C4P4, 8,  // Offset(1381),
    Offset(1382),   C4P5, 8,  // Offset(1382),
    Offset(1383),   C4G0, 8,  // Offset(1383),  GPIO Group Number
    Offset(1384),   C4G1, 8,  // Offset(1384),
    Offset(1385),   C4G2, 8,  // Offset(1385),
    Offset(1386),   C4G3, 8,  // Offset(1386),
    Offset(1387),   C4G4, 8,  // Offset(1387),
    Offset(1388),   C4G5, 8,  // Offset(1388),
    Offset(1389),   C4F0, 8,  // Offset(1389),  GPIO Function
    Offset(1390),   C4F1, 8,  // Offset(1390),
    Offset(1391),   C4F2, 8,  // Offset(1391),
    Offset(1392),   C4F3, 8,  // Offset(1392),
    Offset(1393),   C4F4, 8,  // Offset(1393),
    Offset(1394),   C4F5, 8,  // Offset(1394),
    Offset(1395),   C4A0, 8,  // Offset(1395),  GPIO Active Value
    Offset(1396),   C4A1, 8,  // Offset(1396),
    Offset(1397),   C4A2, 8,  // Offset(1397),
    Offset(1398),   C4A3, 8,  // Offset(1398),
    Offset(1399),   C4A4, 8,  // Offset(1399),
    Offset(1400),   C4A5, 8,  // Offset(1400),
    Offset(1401),   C4I0, 8,  // Offset(1401),  GPIO Initial Value
    Offset(1402),   C4I1, 8,  // Offset(1402),
    Offset(1403),   C4I2, 8,  // Offset(1403),
    Offset(1404),   C4I3, 8,  // Offset(1404),
    Offset(1405),   C4I4, 8,  // Offset(1405),
    Offset(1406),   C4I5, 8,  // Offset(1406),
    Offset(1407),   C4PL, 8,  // Offset(1407),  Camera Position
    Offset(1408),   C4W0, 8,  // Offset(1408),  WLED1 Flash Max Current
    Offset(1409),   C4W1, 8,  // Offset(1409),  WLED1 Torch Max Current
    Offset(1410),   C4W2, 8,  // Offset(1410),  WLED2 Flash Max Current
    Offset(1411),   C4W3, 8,  // Offset(1411),  WLED2 Torch Max Current
    Offset(1412),   C4SP, 8,  // Offset(1412),  Sub Platform Id
    Offset(1413),   C4W4, 8,  // Offset(1413),  WLED1 Type
    Offset(1414),   C4W5, 8,  // Offset(1414),  WLED2 Type
    Offset(1415),   C4CS, 8,  // Offset(1415),  PCH Clock source
    // Control Logic 5 options
    Offset(1416),   C5VE, 8,  // Offset(1416),  Version of CLDB structure
    Offset(1417),   C5TP, 8,  // Offset(1417),  Type
    Offset(1418),   C5CV, 8,  // Offset(1418),  Version of CRD
    Offset(1419),   C5IC, 32, // Offset(1419),  Input Clock
    Offset(1423),   C5GP, 8,  // Offset(1423),  Number of GPIO Pins enabled
    Offset(1424),   C5IB, 8,  // Offset(1424),  I2C Serial Bus Number
    Offset(1425),   C5IA, 16, // Offset(1425),  I2C Address
    Offset(1427),   C5P0, 8,  // Offset(1427),  GPIO Group Pad Number
    Offset(1428),   C5P1, 8,  // Offset(1428),
    Offset(1429),   C5P2, 8,  // Offset(1429),
    Offset(1430),   C5P3, 8,  // Offset(1430),
    Offset(1431),   C5P4, 8,  // Offset(1431),
    Offset(1432),   C5P5, 8,  // Offset(1432),
    Offset(1433),   C5G0, 8,  // Offset(1433),  GPIO Group Number
    Offset(1434),   C5G1, 8,  // Offset(1434),
    Offset(1435),   C5G2, 8,  // Offset(1435),
    Offset(1436),   C5G3, 8,  // Offset(1436),
    Offset(1437),   C5G4, 8,  // Offset(1437),
    Offset(1438),   C5G5, 8,  // Offset(1438),
    Offset(1439),   C5F0, 8,  // Offset(1439),  GPIO Function
    Offset(1440),   C5F1, 8,  // Offset(1440),
    Offset(1441),   C5F2, 8,  // Offset(1441),
    Offset(1442),   C5F3, 8,  // Offset(1442),
    Offset(1443),   C5F4, 8,  // Offset(1443),
    Offset(1444),   C5F5, 8,  // Offset(1444),
    Offset(1445),   C5A0, 8,  // Offset(1445),  GPIO Active Value
    Offset(1446),   C5A1, 8,  // Offset(1446),
    Offset(1447),   C5A2, 8,  // Offset(1447),
    Offset(1448),   C5A3, 8,  // Offset(1448),
    Offset(1449),   C5A4, 8,  // Offset(1449),
    Offset(1450),   C5A5, 8,  // Offset(1450),
    Offset(1451),   C5I0, 8,  // Offset(1451),  GPIO Initial Value
    Offset(1452),   C5I1, 8,  // Offset(1452),
    Offset(1453),   C5I2, 8,  // Offset(1453),
    Offset(1454),   C5I3, 8,  // Offset(1454),
    Offset(1455),   C5I4, 8,  // Offset(1455),
    Offset(1456),   C5I5, 8,  // Offset(1456),
    Offset(1457),   C5PL, 8,  // Offset(1457),  Camera Position
    Offset(1458),   C5W0, 8,  // Offset(1458),  WLED1 Flash Max Current
    Offset(1459),   C5W1, 8,  // Offset(1459),  WLED1 Torch Max Current
    Offset(1460),   C5W2, 8,  // Offset(1460),  WLED2 Flash Max Current
    Offset(1461),   C5W3, 8,  // Offset(1461),  WLED2 Torch Max Current
    Offset(1462),   C5SP, 8,  // Offset(1462),  Sub Platform Id
    Offset(1463),   C5W4, 8,  // Offset(1463),  WLED1 Type
    Offset(1464),   C5W5, 8,  // Offset(1464),  WLED2 Type
    Offset(1465),   C5CS, 8,  // Offset(1465),  PCH Clock source
    // Mipi Cam Link0 options
    Offset(1466),   L0SM, 8,  // Offset(1466),  Sensor Model
    Offset(1467),   L0H0, 8,  // Offset(1467),  User defined HID ASCII character 0
    Offset(1468),   L0H1, 8,  // Offset(1468),
    Offset(1469),   L0H2, 8,  // Offset(1469),
    Offset(1470),   L0H3, 8,  // Offset(1470),
    Offset(1471),   L0H4, 8,  // Offset(1471),
    Offset(1472),   L0H5, 8,  // Offset(1472),
    Offset(1473),   L0H6, 8,  // Offset(1473),
    Offset(1474),   L0H7, 8,  // Offset(1474),
    Offset(1475),   L0H8, 8,  // Offset(1475),  User defined HID ASCII character 8
    Offset(1476),   L0PL, 8,  // Offset(1476),  Camera Position
    Offset(1477),   L0M0, 8,  // Offset(1477),  Camera Module Name ASCII character 0
    Offset(1478),   L0M1, 8,  // Offset(1478),
    Offset(1479),   L0M2, 8,  // Offset(1479),
    Offset(1480),   L0M3, 8,  // Offset(1480),
    Offset(1481),   L0M4, 8,  // Offset(1481),
    Offset(1482),   L0M5, 8,  // Offset(1482),
    Offset(1483),   L0M6, 8,  // Offset(1483),
    Offset(1484),   L0M7, 8,  // Offset(1484),
    Offset(1485),   L0M8, 8,  // Offset(1485),
    Offset(1486),   L0M9, 8,  // Offset(1486),
    Offset(1487),   L0MA, 8,  // Offset(1487),
    Offset(1488),   L0MB, 8,  // Offset(1488),
    Offset(1489),   L0MC, 8,  // Offset(1489),
    Offset(1490),   L0MD, 8,  // Offset(1490),
    Offset(1491),   L0ME, 8,  // Offset(1491),
    Offset(1492),   L0MF, 8,  // Offset(1492),  Camera Module Name ASCII character 15
    Offset(1493),   L0DI, 8,  // Offset(1493),  Number of I2C devices
    Offset(1494),   L0BS, 8,  // Offset(1494),  I2C Serial Bus number
    Offset(1495),   L0A0, 16, // Offset(1495),  Address of I2C Device0 on Link0
    Offset(1497),   L0A1, 16, // Offset(1497),  Address of I2C Device1 on Link0
    Offset(1499),   L0A2, 16, // Offset(1499),  Address of I2C Device2 on Link0
    Offset(1501),   L0A3, 16, // Offset(1501),  Address of I2C Device3 on Link0
    Offset(1503),   L0A4, 16, // Offset(1503),  Address of I2C Device4 on Link0
    Offset(1505),   L0A5, 16, // Offset(1505),  Address of I2C Device5 on Link0
    Offset(1507),   L0A6, 16, // Offset(1507),  Address of I2C Device6 on Link0
    Offset(1509),   L0A7, 16, // Offset(1509),  Address of I2C Device7 on Link0
    Offset(1511),   L0A8, 16, // Offset(1511),  Address of I2C Device8 on Link0
    Offset(1513),   L0A9, 16, // Offset(1513),  Address of I2C Device9 on Link0
    Offset(1515),   L0AA, 16, // Offset(1515),  Address of I2C Device10 on Link0
    Offset(1517),   L0AB, 16, // Offset(1517),  Address of I2C Device11 on Link0
    Offset(1519),   L0D0, 8,  // Offset(1519),  Type of I2C Device0 on Link0
    Offset(1520),   L0D1, 8,  // Offset(1520),  Type of I2C Device1 on Link0
    Offset(1521),   L0D2, 8,  // Offset(1521),  Type of I2C Device2 on Link0
    Offset(1522),   L0D3, 8,  // Offset(1522),  Type of I2C Device3 on Link0
    Offset(1523),   L0D4, 8,  // Offset(1523),  Type of I2C Device4 on Link0
    Offset(1524),   L0D5, 8,  // Offset(1524),  Type of I2C Device5 on Link0
    Offset(1525),   L0D6, 8,  // Offset(1525),  Type of I2C Device6 on Link0
    Offset(1526),   L0D7, 8,  // Offset(1526),  Type of I2C Device7 on Link0
    Offset(1527),   L0D8, 8,  // Offset(1527),  Type of I2C Device8 on Link0
    Offset(1528),   L0D9, 8,  // Offset(1528),  Type of I2C Device9 on Link0
    Offset(1529),   L0DA, 8,  // Offset(1529),  Type of I2C Device10 on Link0
    Offset(1530),   L0DB, 8,  // Offset(1530),  Type of I2C Device11 on Link0
    Offset(1531),   L0DV, 8,  // Offset(1531),  Version of SSDB structure
    Offset(1532),   L0CV, 8,  // Offset(1532),  Version of CRD
    Offset(1533),   L0LU, 8,  // Offset(1533),  CSI2 Link used
    Offset(1534),   L0NL, 8,  // Offset(1534),  MIPI-CSI2 Data Lane
    Offset(1535),   L0EE, 8,  // Offset(1535),  EEPROM Type
    Offset(1536),   L0VC, 8,  // Offset(1536),  VCM Type
    Offset(1537),   L0FS, 8,  // Offset(1537),  Flash Support
    Offset(1538),   L0LE, 8,  // Offset(1538),  Privacy LED
    Offset(1539),   L0DG, 8,  // Offset(1539),  Degree
    Offset(1540),   L0CK, 32, // Offset(1540),  MCLK
    Offset(1544),   L0CL, 8,  // Offset(1544),  Control Logic
    Offset(1545),   L0PP, 8,  // Offset(1545),  PMIC Position
    Offset(1546),   L0VR, 8,  // Offset(1546),  Voltage Rail
    Offset(1547),   L0FD, 8,  // Offset(1547),  Flash Driver Selection
    // Mipi Cam Link1 options
    Offset(1548),   L1SM, 8,  // Offset(1548),  Sensor Model
    Offset(1549),   L1H0, 8,  // Offset(1549),  User defined HID ASCII character 0
    Offset(1550),   L1H1, 8,  // Offset(1550),
    Offset(1551),   L1H2, 8,  // Offset(1551),
    Offset(1552),   L1H3, 8,  // Offset(1552),
    Offset(1553),   L1H4, 8,  // Offset(1553),
    Offset(1554),   L1H5, 8,  // Offset(1554),
    Offset(1555),   L1H6, 8,  // Offset(1555),
    Offset(1556),   L1H7, 8,  // Offset(1556),
    Offset(1557),   L1H8, 8,  // Offset(1557),  User defined HID ASCII character 8
    Offset(1558),   L1PL, 8,  // Offset(1558),  Camera Position
    Offset(1559),   L1M0, 8,  // Offset(1559),  Camera Module Name ASCII character 0
    Offset(1560),   L1M1, 8,  // Offset(1560),
    Offset(1561),   L1M2, 8,  // Offset(1561),
    Offset(1562),   L1M3, 8,  // Offset(1562),
    Offset(1563),   L1M4, 8,  // Offset(1563),
    Offset(1564),   L1M5, 8,  // Offset(1564),
    Offset(1565),   L1M6, 8,  // Offset(1565),
    Offset(1566),   L1M7, 8,  // Offset(1566),
    Offset(1567),   L1M8, 8,  // Offset(1567),
    Offset(1568),   L1M9, 8,  // Offset(1568),
    Offset(1569),   L1MA, 8,  // Offset(1569),
    Offset(1570),   L1MB, 8,  // Offset(1570),
    Offset(1571),   L1MC, 8,  // Offset(1571),
    Offset(1572),   L1MD, 8,  // Offset(1572),
    Offset(1573),   L1ME, 8,  // Offset(1573),
    Offset(1574),   L1MF, 8,  // Offset(1574),  Camera Module Name ASCII character 15
    Offset(1575),   L1DI, 8,  // Offset(1575),  Number of I2C devices
    Offset(1576),   L1BS, 8,  // Offset(1576),  I2C Serial Bus number
    Offset(1577),   L1A0, 16, // Offset(1577),  Address of I2C Device0 on Link1
    Offset(1579),   L1A1, 16, // Offset(1579),  Address of I2C Device1 on Link1
    Offset(1581),   L1A2, 16, // Offset(1581),  Address of I2C Device2 on Link1
    Offset(1583),   L1A3, 16, // Offset(1583),  Address of I2C Device3 on Link1
    Offset(1585),   L1A4, 16, // Offset(1585),  Address of I2C Device4 on Link1
    Offset(1587),   L1A5, 16, // Offset(1587),  Address of I2C Device5 on Link1
    Offset(1589),   L1A6, 16, // Offset(1589),  Address of I2C Device6 on Link1
    Offset(1591),   L1A7, 16, // Offset(1591),  Address of I2C Device7 on Link1
    Offset(1593),   L1A8, 16, // Offset(1593),  Address of I2C Device8 on Link1
    Offset(1595),   L1A9, 16, // Offset(1595),  Address of I2C Device9 on Link1
    Offset(1597),   L1AA, 16, // Offset(1597),  Address of I2C Device10 on Link1
    Offset(1599),   L1AB, 16, // Offset(1599),  Address of I2C Device11 on Link1
    Offset(1601),   L1D0, 8,  // Offset(1601),  Type of I2C Device0 on Link1
    Offset(1602),   L1D1, 8,  // Offset(1602),  Type of I2C Device1 on Link1
    Offset(1603),   L1D2, 8,  // Offset(1603),  Type of I2C Device2 on Link1
    Offset(1604),   L1D3, 8,  // Offset(1604),  Type of I2C Device3 on Link1
    Offset(1605),   L1D4, 8,  // Offset(1605),  Type of I2C Device4 on Link1
    Offset(1606),   L1D5, 8,  // Offset(1606),  Type of I2C Device5 on Link1
    Offset(1607),   L1D6, 8,  // Offset(1607),  Type of I2C Device6 on Link1
    Offset(1608),   L1D7, 8,  // Offset(1608),  Type of I2C Device7 on Link1
    Offset(1609),   L1D8, 8,  // Offset(1609),  Type of I2C Device8 on Link1
    Offset(1610),   L1D9, 8,  // Offset(1610),  Type of I2C Device9 on Link1
    Offset(1611),   L1DA, 8,  // Offset(1611),  Type of I2C Device10 on Link1
    Offset(1612),   L1DB, 8,  // Offset(1612),  Type of I2C Device11 on Link1
    Offset(1613),   L1DV, 8,  // Offset(1613),  Version of SSDB structure
    Offset(1614),   L1CV, 8,  // Offset(1614),  Version of CRD
    Offset(1615),   L1LU, 8,  // Offset(1615),  CSI2 Link used
    Offset(1616),   L1NL, 8,  // Offset(1616),  MIPI-CSI2 Data Lane
    Offset(1617),   L1EE, 8,  // Offset(1617),  EEPROM Type
    Offset(1618),   L1VC, 8,  // Offset(1618),  VCM Type
    Offset(1619),   L1FS, 8,  // Offset(1619),  Flash Support
    Offset(1620),   L1LE, 8,  // Offset(1620),  Privacy LED
    Offset(1621),   L1DG, 8,  // Offset(1621),  Degree
    Offset(1622),   L1CK, 32, // Offset(1622),  MCLK
    Offset(1626),   L1CL, 8,  // Offset(1626),  Control Logic
    Offset(1627),   L1PP, 8,  // Offset(1627),  PMIC Position
    Offset(1628),   L1VR, 8,  // Offset(1628),  Voltage Rail
    Offset(1629),   L1FD, 8,  // Offset(1629),  Flash Driver Selection
    // Mipi Cam Link2 options
    Offset(1630),   L2SM, 8,  // Offset(1630),  Sensor Model
    Offset(1631),   L2H0, 8,  // Offset(1631),  User defined HID ASCII character 0
    Offset(1632),   L2H1, 8,  // Offset(1632),
    Offset(1633),   L2H2, 8,  // Offset(1633),
    Offset(1634),   L2H3, 8,  // Offset(1634),
    Offset(1635),   L2H4, 8,  // Offset(1635),
    Offset(1636),   L2H5, 8,  // Offset(1636),
    Offset(1637),   L2H6, 8,  // Offset(1637),
    Offset(1638),   L2H7, 8,  // Offset(1638),
    Offset(1639),   L2H8, 8,  // Offset(1639),  User defined HID ASCII character 8
    Offset(1640),   L2PL, 8,  // Offset(1640),  Camera Position
    Offset(1641),   L2M0, 8,  // Offset(1641),  Camera Module Name ASCII character 0
    Offset(1642),   L2M1, 8,  // Offset(1642),
    Offset(1643),   L2M2, 8,  // Offset(1643),
    Offset(1644),   L2M3, 8,  // Offset(1644),
    Offset(1645),   L2M4, 8,  // Offset(1645),
    Offset(1646),   L2M5, 8,  // Offset(1646),
    Offset(1647),   L2M6, 8,  // Offset(1647),
    Offset(1648),   L2M7, 8,  // Offset(1648),
    Offset(1649),   L2M8, 8,  // Offset(1649),
    Offset(1650),   L2M9, 8,  // Offset(1650),
    Offset(1651),   L2MA, 8,  // Offset(1651),
    Offset(1652),   L2MB, 8,  // Offset(1652),
    Offset(1653),   L2MC, 8,  // Offset(1653),
    Offset(1654),   L2MD, 8,  // Offset(1654),
    Offset(1655),   L2ME, 8,  // Offset(1655),
    Offset(1656),   L2MF, 8,  // Offset(1656),  Camera Module Name ASCII character 15
    Offset(1657),   L2DI, 8,  // Offset(1657),  Number of I2C devices
    Offset(1658),   L2BS, 8,  // Offset(1658),  I2C Serial Bus number
    Offset(1659),   L2A0, 16, // Offset(1659),  Address of I2C Device0 on Link2
    Offset(1661),   L2A1, 16, // Offset(1661),  Address of I2C Device1 on Link2
    Offset(1663),   L2A2, 16, // Offset(1663),  Address of I2C Device2 on Link2
    Offset(1665),   L2A3, 16, // Offset(1665),  Address of I2C Device3 on Link2
    Offset(1667),   L2A4, 16, // Offset(1667),  Address of I2C Device4 on Link2
    Offset(1669),   L2A5, 16, // Offset(1669),  Address of I2C Device5 on Link2
    Offset(1671),   L2A6, 16, // Offset(1671),  Address of I2C Device6 on Link2
    Offset(1673),   L2A7, 16, // Offset(1673),  Address of I2C Device7 on Link2
    Offset(1675),   L2A8, 16, // Offset(1675),  Address of I2C Device8 on Link2
    Offset(1677),   L2A9, 16, // Offset(1677),  Address of I2C Device9 on Link2
    Offset(1679),   L2AA, 16, // Offset(1679),  Address of I2C Device10 on Link2
    Offset(1681),   L2AB, 16, // Offset(1681),  Address of I2C Device11 on Link2
    Offset(1683),   L2D0, 8,  // Offset(1683),  Type of I2C Device0 on Link2
    Offset(1684),   L2D1, 8,  // Offset(1684),  Type of I2C Device1 on Link2
    Offset(1685),   L2D2, 8,  // Offset(1685),  Type of I2C Device2 on Link2
    Offset(1686),   L2D3, 8,  // Offset(1686),  Type of I2C Device3 on Link2
    Offset(1687),   L2D4, 8,  // Offset(1687),  Type of I2C Device4 on Link2
    Offset(1688),   L2D5, 8,  // Offset(1688),  Type of I2C Device5 on Link2
    Offset(1689),   L2D6, 8,  // Offset(1689),  Type of I2C Device6 on Link2
    Offset(1690),   L2D7, 8,  // Offset(1690),  Type of I2C Device7 on Link2
    Offset(1691),   L2D8, 8,  // Offset(1691),  Type of I2C Device8 on Link2
    Offset(1692),   L2D9, 8,  // Offset(1692),  Type of I2C Device9 on Link2
    Offset(1693),   L2DA, 8,  // Offset(1693),  Type of I2C Device10 on Link2
    Offset(1694),   L2DB, 8,  // Offset(1694),  Type of I2C Device11 on Link2
    Offset(1695),   L2DV, 8,  // Offset(1695),  Version of SSDB structure
    Offset(1696),   L2CV, 8,  // Offset(1696),  Version of CRD
    Offset(1697),   L2LU, 8,  // Offset(1697),  CSI2 Link used
    Offset(1698),   L2NL, 8,  // Offset(1698),  MIPI-CSI2 Data Lane
    Offset(1699),   L2EE, 8,  // Offset(1699),  EEPROM Type
    Offset(1700),   L2VC, 8,  // Offset(1700),  VCM Type
    Offset(1701),   L2FS, 8,  // Offset(1701),  Flash Support
    Offset(1702),   L2LE, 8,  // Offset(1702),  Privacy LED
    Offset(1703),   L2DG, 8,  // Offset(1703),  Degree
    Offset(1704),   L2CK, 32, // Offset(1704),  MCLK
    Offset(1708),   L2CL, 8,  // Offset(1708),  Control Logic
    Offset(1709),   L2PP, 8,  // Offset(1709),  PMIC Position
    Offset(1710),   L2VR, 8,  // Offset(1710),  Voltage Rail
    Offset(1711),   L2FD, 8,  // Offset(1711),  Flash Driver Selection
    // Mipi Cam Link3 options
    Offset(1712),   L3SM, 8,  // Offset(1712),  Sensor Model
    Offset(1713),   L3H0, 8,  // Offset(1713),  User defined HID ASCII character 0
    Offset(1714),   L3H1, 8,  // Offset(1714),
    Offset(1715),   L3H2, 8,  // Offset(1715),
    Offset(1716),   L3H3, 8,  // Offset(1716),
    Offset(1717),   L3H4, 8,  // Offset(1717),
    Offset(1718),   L3H5, 8,  // Offset(1718),
    Offset(1719),   L3H6, 8,  // Offset(1719),
    Offset(1720),   L3H7, 8,  // Offset(1720),
    Offset(1721),   L3H8, 8,  // Offset(1721),  User defined HID ASCII character 8
    Offset(1722),   L3PL, 8,  // Offset(1722),  Camera Position
    Offset(1723),   L3M0, 8,  // Offset(1723),  Camera Module Name ASCII character 0
    Offset(1724),   L3M1, 8,  // Offset(1724),
    Offset(1725),   L3M2, 8,  // Offset(1725),
    Offset(1726),   L3M3, 8,  // Offset(1726),
    Offset(1727),   L3M4, 8,  // Offset(1727),
    Offset(1728),   L3M5, 8,  // Offset(1728),
    Offset(1729),   L3M6, 8,  // Offset(1729),
    Offset(1730),   L3M7, 8,  // Offset(1730),
    Offset(1731),   L3M8, 8,  // Offset(1731),
    Offset(1732),   L3M9, 8,  // Offset(1732),
    Offset(1733),   L3MA, 8,  // Offset(1733),
    Offset(1734),   L3MB, 8,  // Offset(1734),
    Offset(1735),   L3MC, 8,  // Offset(1735),
    Offset(1736),   L3MD, 8,  // Offset(1736),
    Offset(1737),   L3ME, 8,  // Offset(1737),
    Offset(1738),   L3MF, 8,  // Offset(1738),  Camera Module Name ASCII character 15
    Offset(1739),   L3DI, 8,  // Offset(1739),  Number of I2C devices
    Offset(1740),   L3BS, 8,  // Offset(1740),  I2C Serial Bus number
    Offset(1741),   L3A0, 16, // Offset(1741),  Address of I2C Device0 on Link3
    Offset(1743),   L3A1, 16, // Offset(1743),  Address of I2C Device1 on Link3
    Offset(1745),   L3A2, 16, // Offset(1745),  Address of I2C Device2 on Link3
    Offset(1747),   L3A3, 16, // Offset(1747),  Address of I2C Device3 on Link3
    Offset(1749),   L3A4, 16, // Offset(1749),  Address of I2C Device4 on Link3
    Offset(1751),   L3A5, 16, // Offset(1751),  Address of I2C Device5 on Link3
    Offset(1753),   L3A6, 16, // Offset(1753),  Address of I2C Device6 on Link3
    Offset(1755),   L3A7, 16, // Offset(1755),  Address of I2C Device7 on Link3
    Offset(1757),   L3A8, 16, // Offset(1757),  Address of I2C Device8 on Link3
    Offset(1759),   L3A9, 16, // Offset(1759),  Address of I2C Device9 on Link3
    Offset(1761),   L3AA, 16, // Offset(1761),  Address of I2C Device10 on Link3
    Offset(1763),   L3AB, 16, // Offset(1763),  Address of I2C Device11 on Link3
    Offset(1765),   L3D0, 8,  // Offset(1765),  Type of I2C Device0 on Link3
    Offset(1766),   L3D1, 8,  // Offset(1766),  Type of I2C Device1 on Link3
    Offset(1767),   L3D2, 8,  // Offset(1767),  Type of I2C Device2 on Link3
    Offset(1768),   L3D3, 8,  // Offset(1768),  Type of I2C Device3 on Link3
    Offset(1769),   L3D4, 8,  // Offset(1769),  Type of I2C Device4 on Link3
    Offset(1770),   L3D5, 8,  // Offset(1770),  Type of I2C Device5 on Link3
    Offset(1771),   L3D6, 8,  // Offset(1771),  Type of I2C Device6 on Link3
    Offset(1772),   L3D7, 8,  // Offset(1772),  Type of I2C Device7 on Link3
    Offset(1773),   L3D8, 8,  // Offset(1773),  Type of I2C Device8 on Link3
    Offset(1774),   L3D9, 8,  // Offset(1774),  Type of I2C Device9 on Link3
    Offset(1775),   L3DA, 8,  // Offset(1775),  Type of I2C Device10 on Link3
    Offset(1776),   L3DB, 8,  // Offset(1776),  Type of I2C Device11 on Link3
    Offset(1777),   L3DV, 8,  // Offset(1777),  Version of SSDB structure
    Offset(1778),   L3CV, 8,  // Offset(1778),  Version of CRD
    Offset(1779),   L3LU, 8,  // Offset(1779),  CSI2 Link used
    Offset(1780),   L3NL, 8,  // Offset(1780),  MIPI-CSI2 Data Lane
    Offset(1781),   L3EE, 8,  // Offset(1781),  EEPROM Type
    Offset(1782),   L3VC, 8,  // Offset(1782),  VCM Type
    Offset(1783),   L3FS, 8,  // Offset(1783),  Flash Support
    Offset(1784),   L3LE, 8,  // Offset(1784),  Privacy LED
    Offset(1785),   L3DG, 8,  // Offset(1785),  Degree
    Offset(1786),   L3CK, 32, // Offset(1786),  MCLK
    Offset(1790),   L3CL, 8,  // Offset(1790),  Control Logic
    Offset(1791),   L3PP, 8,  // Offset(1791),  PMIC Position
    Offset(1792),   L3VR, 8,  // Offset(1792),  Voltage Rail
    Offset(1793),   L3FD, 8,  // Offset(1793),  Flash Driver Selection
    // Mipi Cam Link4 options
    Offset(1794),   L4SM, 8,  // Offset(1794),  Sensor Model
    Offset(1795),   L4H0, 8,  // Offset(1795),  User defined HID ASCII character 0
    Offset(1796),   L4H1, 8,  // Offset(1796),
    Offset(1797),   L4H2, 8,  // Offset(1797),
    Offset(1798),   L4H3, 8,  // Offset(1798),
    Offset(1799),   L4H4, 8,  // Offset(1799),
    Offset(1800),   L4H5, 8,  // Offset(1800),
    Offset(1801),   L4H6, 8,  // Offset(1801),
    Offset(1802),   L4H7, 8,  // Offset(1802),
    Offset(1803),   L4H8, 8,  // Offset(1803),  User defined HID ASCII character 8
    Offset(1804),   L4PL, 8,  // Offset(1804),  Camera Position
    Offset(1805),   L4M0, 8,  // Offset(1805),  Camera Module Name ASCII character 0
    Offset(1806),   L4M1, 8,  // Offset(1806),
    Offset(1807),   L4M2, 8,  // Offset(1807),
    Offset(1808),   L4M3, 8,  // Offset(1808),
    Offset(1809),   L4M4, 8,  // Offset(1809),
    Offset(1810),   L4M5, 8,  // Offset(1810),
    Offset(1811),   L4M6, 8,  // Offset(1811),
    Offset(1812),   L4M7, 8,  // Offset(1812),
    Offset(1813),   L4M8, 8,  // Offset(1813),
    Offset(1814),   L4M9, 8,  // Offset(1814),
    Offset(1815),   L4MA, 8,  // Offset(1815),
    Offset(1816),   L4MB, 8,  // Offset(1816),
    Offset(1817),   L4MC, 8,  // Offset(1817),
    Offset(1818),   L4MD, 8,  // Offset(1818),
    Offset(1819),   L4ME, 8,  // Offset(1819),
    Offset(1820),   L4MF, 8,  // Offset(1820),  Camera Module Name ASCII character 15
    Offset(1821),   L4DI, 8,  // Offset(1821),  Number of I2C devices
    Offset(1822),   L4BS, 8,  // Offset(1822),  I2C Serial Bus number
    Offset(1823),   L4A0, 16, // Offset(1823),  Address of I2C Device0 on Link4
    Offset(1825),   L4A1, 16, // Offset(1825),  Address of I2C Device1 on Link4
    Offset(1827),   L4A2, 16, // Offset(1827),  Address of I2C Device2 on Link4
    Offset(1829),   L4A3, 16, // Offset(1829),  Address of I2C Device3 on Link4
    Offset(1831),   L4A4, 16, // Offset(1831),  Address of I2C Device4 on Link4
    Offset(1833),   L4A5, 16, // Offset(1833),  Address of I2C Device5 on Link4
    Offset(1835),   L4A6, 16, // Offset(1835),  Address of I2C Device6 on Link4
    Offset(1837),   L4A7, 16, // Offset(1837),  Address of I2C Device7 on Link4
    Offset(1839),   L4A8, 16, // Offset(1839),  Address of I2C Device8 on Link4
    Offset(1841),   L4A9, 16, // Offset(1841),  Address of I2C Device9 on Link4
    Offset(1843),   L4AA, 16, // Offset(1843),  Address of I2C Device10 on Link4
    Offset(1845),   L4AB, 16, // Offset(1845),  Address of I2C Device11 on Link4
    Offset(1847),   L4D0, 8,  // Offset(1847),  Type of I2C Device0 on Link4
    Offset(1848),   L4D1, 8,  // Offset(1848),  Type of I2C Device1 on Link4
    Offset(1849),   L4D2, 8,  // Offset(1849),  Type of I2C Device2 on Link4
    Offset(1850),   L4D3, 8,  // Offset(1850),  Type of I2C Device3 on Link4
    Offset(1851),   L4D4, 8,  // Offset(1851),  Type of I2C Device4 on Link4
    Offset(1852),   L4D5, 8,  // Offset(1852),  Type of I2C Device5 on Link4
    Offset(1853),   L4D6, 8,  // Offset(1853),  Type of I2C Device6 on Link4
    Offset(1854),   L4D7, 8,  // Offset(1854),  Type of I2C Device7 on Link4
    Offset(1855),   L4D8, 8,  // Offset(1855),  Type of I2C Device8 on Link4
    Offset(1856),   L4D9, 8,  // Offset(1856),  Type of I2C Device9 on Link4
    Offset(1857),   L4DA, 8,  // Offset(1857),  Type of I2C Device10 on Link4
    Offset(1858),   L4DB, 8,  // Offset(1858),  Type of I2C Device11 on Link4
    Offset(1859),   L4DV, 8,  // Offset(1859),  Version of SSDB structure
    Offset(1860),   L4CV, 8,  // Offset(1860),  Version of CRD
    Offset(1861),   L4LU, 8,  // Offset(1861),  CSI2 Link used
    Offset(1862),   L4NL, 8,  // Offset(1862),  MIPI-CSI2 Data Lane
    Offset(1863),   L4EE, 8,  // Offset(1863),  EEPROM Type
    Offset(1864),   L4VC, 8,  // Offset(1864),  VCM Type
    Offset(1865),   L4FS, 8,  // Offset(1865),  Flash Support
    Offset(1866),   L4LE, 8,  // Offset(1866),  Privacy LED
    Offset(1867),   L4DG, 8,  // Offset(1867),  Degree
    Offset(1868),   L4CK, 32, // Offset(1868),  MCLK
    Offset(1872),   L4CL, 8,  // Offset(1872),  Control Logic
    Offset(1873),   L4PP, 8,  // Offset(1873),  PMIC Position
    Offset(1874),   L4VR, 8,  // Offset(1874),  Voltage Rail
    Offset(1875),   L4FD, 8,  // Offset(1875),  Flash Driver Selection
    // Mipi Cam Link5 options
    Offset(1876),   L5SM, 8,  // Offset(1876),  Sensor Model
    Offset(1877),   L5H0, 8,  // Offset(1877),  User defined HID ASCII character 0
    Offset(1878),   L5H1, 8,  // Offset(1878),
    Offset(1879),   L5H2, 8,  // Offset(1879),
    Offset(1880),   L5H3, 8,  // Offset(1880),
    Offset(1881),   L5H4, 8,  // Offset(1881),
    Offset(1882),   L5H5, 8,  // Offset(1882),
    Offset(1883),   L5H6, 8,  // Offset(1883),
    Offset(1884),   L5H7, 8,  // Offset(1884),
    Offset(1885),   L5H8, 8,  // Offset(1885),  User defined HID ASCII character 8
    Offset(1886),   L5PL, 8,  // Offset(1886),  Camera Position
    Offset(1887),   L5M0, 8,  // Offset(1887),  Camera Module Name ASCII character 0
    Offset(1888),   L5M1, 8,  // Offset(1888),
    Offset(1889),   L5M2, 8,  // Offset(1889),
    Offset(1890),   L5M3, 8,  // Offset(1890),
    Offset(1891),   L5M4, 8,  // Offset(1891),
    Offset(1892),   L5M5, 8,  // Offset(1892),
    Offset(1893),   L5M6, 8,  // Offset(1893),
    Offset(1894),   L5M7, 8,  // Offset(1894),
    Offset(1895),   L5M8, 8,  // Offset(1895),
    Offset(1896),   L5M9, 8,  // Offset(1896),
    Offset(1897),   L5MA, 8,  // Offset(1897),
    Offset(1898),   L5MB, 8,  // Offset(1898),
    Offset(1899),   L5MC, 8,  // Offset(1899),
    Offset(1900),   L5MD, 8,  // Offset(1900),
    Offset(1901),   L5ME, 8,  // Offset(1901),
    Offset(1902),   L5MF, 8,  // Offset(1902),  Camera Module Name ASCII character 15
    Offset(1903),   L5DI, 8,  // Offset(1903),  Number of I2C devices
    Offset(1904),   L5BS, 8,  // Offset(1904),  I2C Serial Bus number
    Offset(1905),   L5A0, 16, // Offset(1905),  Address of I2C Device0 on Link5
    Offset(1907),   L5A1, 16, // Offset(1907),  Address of I2C Device1 on Link5
    Offset(1909),   L5A2, 16, // Offset(1909),  Address of I2C Device2 on Link5
    Offset(1911),   L5A3, 16, // Offset(1911),  Address of I2C Device3 on Link5
    Offset(1913),   L5A4, 16, // Offset(1913),  Address of I2C Device4 on Link5
    Offset(1915),   L5A5, 16, // Offset(1915),  Address of I2C Device5 on Link5
    Offset(1917),   L5A6, 16, // Offset(1917),  Address of I2C Device6 on Link5
    Offset(1919),   L5A7, 16, // Offset(1919),  Address of I2C Device7 on Link5
    Offset(1921),   L5A8, 16, // Offset(1921),  Address of I2C Device8 on Link5
    Offset(1923),   L5A9, 16, // Offset(1923),  Address of I2C Device9 on Link5
    Offset(1925),   L5AA, 16, // Offset(1925),  Address of I2C Device10 on Link5
    Offset(1927),   L5AB, 16, // Offset(1927),  Address of I2C Device11 on Link5
    Offset(1929),   L5D0, 8,  // Offset(1929),  Type of I2C Device0 on Link5
    Offset(1930),   L5D1, 8,  // Offset(1930),  Type of I2C Device1 on Link5
    Offset(1931),   L5D2, 8,  // Offset(1931),  Type of I2C Device2 on Link5
    Offset(1932),   L5D3, 8,  // Offset(1932),  Type of I2C Device3 on Link5
    Offset(1933),   L5D4, 8,  // Offset(1933),  Type of I2C Device4 on Link5
    Offset(1934),   L5D5, 8,  // Offset(1934),  Type of I2C Device5 on Link5
    Offset(1935),   L5D6, 8,  // Offset(1935),  Type of I2C Device6 on Link5
    Offset(1936),   L5D7, 8,  // Offset(1936),  Type of I2C Device7 on Link5
    Offset(1937),   L5D8, 8,  // Offset(1937),  Type of I2C Device8 on Link5
    Offset(1938),   L5D9, 8,  // Offset(1938),  Type of I2C Device9 on Link5
    Offset(1939),   L5DA, 8,  // Offset(1939),  Type of I2C Device10 on Link5
    Offset(1940),   L5DB, 8,  // Offset(1940),  Type of I2C Device11 on Link5
    Offset(1941),   L5DV, 8,  // Offset(1941),  Version of SSDB structure
    Offset(1942),   L5CV, 8,  // Offset(1942),  Version of CRD
    Offset(1943),   L5LU, 8,  // Offset(1943),  CSI2 Link used
    Offset(1944),   L5NL, 8,  // Offset(1944),  MIPI-CSI2 Data Lane
    Offset(1945),   L5EE, 8,  // Offset(1945),  EEPROM Type
    Offset(1946),   L5VC, 8,  // Offset(1946),  VCM Type
    Offset(1947),   L5FS, 8,  // Offset(1947),  Flash Support
    Offset(1948),   L5LE, 8,  // Offset(1948),  Privacy LED
    Offset(1949),   L5DG, 8,  // Offset(1949),  Degree
    Offset(1950),   L5CK, 32, // Offset(1950),  MCLK
    Offset(1954),   L5CL, 8,  // Offset(1954),  Control Logic
    Offset(1955),   L5PP, 8,  // Offset(1955),  PMIC Position
    Offset(1956),   L5VR, 8,  // Offset(1956),  Voltage Rail
    Offset(1957),   L5FD, 8,  // Offset(1957),  Flash Driver Selection
    Offset(1958),   F0FM, 8,  // Offset(1958),  Flash Driver Model
    Offset(1959),   F0MS, 8,  // Offset(1959),  Flash Mode Selection
    Offset(1960),   F0M0, 8,  // Offset(1960),  Flash Module Name ASCII character 0
    Offset(1961),   F0M1, 8,  // Offset(1961),
    Offset(1962),   F0M2, 8,  // Offset(1962),
    Offset(1963),   F0M3, 8,  // Offset(1963),
    Offset(1964),   F0M4, 8,  // Offset(1964),
    Offset(1965),   F0M5, 8,  // Offset(1965),
    Offset(1966),   F0M6, 8,  // Offset(1966),
    Offset(1967),   F0M7, 8,  // Offset(1967),
    Offset(1968),   F0M8, 8,  // Offset(1968),
    Offset(1969),   F0M9, 8,  // Offset(1969),
    Offset(1970),   F0MA, 8,  // Offset(1970),
    Offset(1971),   F0MB, 8,  // Offset(1971),
    Offset(1972),   F0MC, 8,  // Offset(1972),
    Offset(1973),   F0MD, 8,  // Offset(1973),
    Offset(1974),   F0ME, 8,  // Offset(1974),
    Offset(1975),   F0MF, 8,  // Offset(1975),  Flash Module Name ASCII character 15
    Offset(1976),   F0BS, 8,  // Offset(1976),  I2C Bus Number
    Offset(1977),   F0AB, 16, // Offset(1977),  I2C Peripheral Device Address
    Offset(1979),   F0GP, 8,  // Offset(1979),  GPIO Group Pad Number
    Offset(1980),   F0GG, 16, // Offset(1980),  GPIO Group Number
    Offset(1982),   F0AV, 8,  // Offset(1982),  GPIO Active Value
    Offset(1983),   F0IV, 8,  // Offset(1983),  GPIO Initial Value
    Offset(1984),   F0OM, 8,  // Offset(1984),  Flash Driver Operating Mode
    Offset(1985),   F1FM, 8,  // Offset(1985),  Flash Driver Model
    Offset(1986),   F1MS, 8,  // Offset(1986),  Flash Mode Selection
    Offset(1987),   F1M0, 8,  // Offset(1987),  Flash Module Name ASCII character 0
    Offset(1988),   F1M1, 8,  // Offset(1988),
    Offset(1989),   F1M2, 8,  // Offset(1989),
    Offset(1990),   F1M3, 8,  // Offset(1990),
    Offset(1991),   F1M4, 8,  // Offset(1991),
    Offset(1992),   F1M5, 8,  // Offset(1992),
    Offset(1993),   F1M6, 8,  // Offset(1993),
    Offset(1994),   F1M7, 8,  // Offset(1994),
    Offset(1995),   F1M8, 8,  // Offset(1995),
    Offset(1996),   F1M9, 8,  // Offset(1996),
    Offset(1997),   F1MA, 8,  // Offset(1997),
    Offset(1998),   F1MB, 8,  // Offset(1998),
    Offset(1999),   F1MC, 8,  // Offset(1999),
    Offset(2000),   F1MD, 8,  // Offset(2000),
    Offset(2001),   F1ME, 8,  // Offset(2001),
    Offset(2002),   F1MF, 8,  // Offset(2002),  Flash Module Name ASCII character 15
    Offset(2003),   F1BS, 8,  // Offset(2003),  I2C Bus Number
    Offset(2004),   F1AB, 16, // Offset(2004),  I2C Peripheral Device Address
    Offset(2006),   F1GP, 8,  // Offset(2006),  GPIO Group Pad Number
    Offset(2007),   F1GG, 16, // Offset(2007),  GPIO Group Number
    Offset(2009),   F1AV, 8,  // Offset(2009),  GPIO Active Value
    Offset(2010),   F1IV, 8,  // Offset(2010),  GPIO Initial Value
    Offset(2011),   F1OM, 8,  // Offset(2011),  Flash Driver Operating Mode
    Offset(2012),   F2FM, 8,  // Offset(2012),  Flash Driver Model
    Offset(2013),   F2MS, 8,  // Offset(2013),  Flash Mode Selection
    Offset(2014),   F2M0, 8,  // Offset(2014),  Flash Module Name ASCII character 0
    Offset(2015),   F2M1, 8,  // Offset(2015),
    Offset(2016),   F2M2, 8,  // Offset(2016),
    Offset(2017),   F2M3, 8,  // Offset(2017),
    Offset(2018),   F2M4, 8,  // Offset(2018),
    Offset(2019),   F2M5, 8,  // Offset(2019),
    Offset(2020),   F2M6, 8,  // Offset(2020),
    Offset(2021),   F2M7, 8,  // Offset(2021),
    Offset(2022),   F2M8, 8,  // Offset(2022),
    Offset(2023),   F2M9, 8,  // Offset(2023),
    Offset(2024),   F2MA, 8,  // Offset(2024),
    Offset(2025),   F2MB, 8,  // Offset(2025),
    Offset(2026),   F2MC, 8,  // Offset(2026),
    Offset(2027),   F2MD, 8,  // Offset(2027),
    Offset(2028),   F2ME, 8,  // Offset(2028),
    Offset(2029),   F2MF, 8,  // Offset(2029),  Flash Module Name ASCII character 15
    Offset(2030),   F2BS, 8,  // Offset(2030),  I2C Bus Number
    Offset(2031),   F2AB, 16, // Offset(2031),  I2C Peripheral Device Address
    Offset(2033),   F2GP, 8,  // Offset(2033),  GPIO Group Pad Number
    Offset(2034),   F2GG, 16, // Offset(2034),  GPIO Group Number
    Offset(2036),   F2AV, 8,  // Offset(2036),  GPIO Active Value
    Offset(2037),   F2IV, 8,  // Offset(2037),  GPIO Initial Value
    Offset(2038),   F2OM, 8,  // Offset(2038),  Flash Driver Operating Mode
    Offset(2039),   F3FM, 8,  // Offset(2039),  Flash Driver Model
    Offset(2040),   F3MS, 8,  // Offset(2040),  Flash Mode Selection
    Offset(2041),   F3M0, 8,  // Offset(2041),  Flash Module Name ASCII character 0
    Offset(2042),   F3M1, 8,  // Offset(2042),
    Offset(2043),   F3M2, 8,  // Offset(2043),
    Offset(2044),   F3M3, 8,  // Offset(2044),
    Offset(2045),   F3M4, 8,  // Offset(2045),
    Offset(2046),   F3M5, 8,  // Offset(2046),
    Offset(2047),   F3M6, 8,  // Offset(2047),
    Offset(2048),   F3M7, 8,  // Offset(2048),
    Offset(2049),   F3M8, 8,  // Offset(2049),
    Offset(2050),   F3M9, 8,  // Offset(2050),
    Offset(2051),   F3MA, 8,  // Offset(2051),
    Offset(2052),   F3MB, 8,  // Offset(2052),
    Offset(2053),   F3MC, 8,  // Offset(2053),
    Offset(2054),   F3MD, 8,  // Offset(2054),
    Offset(2055),   F3ME, 8,  // Offset(2055),
    Offset(2056),   F3MF, 8,  // Offset(2056),  Flash Module Name ASCII character 15
    Offset(2057),   F3BS, 8,  // Offset(2057),  I2C Bus Number
    Offset(2058),   F3AB, 16, // Offset(2058),  I2C Peripheral Device Address
    Offset(2060),   F3GP, 8,  // Offset(2060),  GPIO Group Pad Number
    Offset(2061),   F3GG, 16, // Offset(2061),  GPIO Group Number
    Offset(2063),   F3AV, 8,  // Offset(2063),  GPIO Active Value
    Offset(2064),   F3IV, 8,  // Offset(2064),  GPIO Initial Value
    Offset(2065),   F3OM, 8,  // Offset(2065),  Flash Driver Operating Mode
    Offset(2066),   F4FM, 8,  // Offset(2066),  Flash Driver Model
    Offset(2067),   F4MS, 8,  // Offset(2067),  Flash Mode Selection
    Offset(2068),   F4M0, 8,  // Offset(2068),  Flash Module Name ASCII character 0
    Offset(2069),   F4M1, 8,  // Offset(2069),
    Offset(2070),   F4M2, 8,  // Offset(2070),
    Offset(2071),   F4M3, 8,  // Offset(2071),
    Offset(2072),   F4M4, 8,  // Offset(2072),
    Offset(2073),   F4M5, 8,  // Offset(2073),
    Offset(2074),   F4M6, 8,  // Offset(2074),
    Offset(2075),   F4M7, 8,  // Offset(2075),
    Offset(2076),   F4M8, 8,  // Offset(2076),
    Offset(2077),   F4M9, 8,  // Offset(2077),
    Offset(2078),   F4MA, 8,  // Offset(2078),
    Offset(2079),   F4MB, 8,  // Offset(2079),
    Offset(2080),   F4MC, 8,  // Offset(2080),
    Offset(2081),   F4MD, 8,  // Offset(2081),
    Offset(2082),   F4ME, 8,  // Offset(2082),
    Offset(2083),   F4MF, 8,  // Offset(2083),  Flash Module Name ASCII character 15
    Offset(2084),   F4BS, 8,  // Offset(2084),  I2C Bus Number
    Offset(2085),   F4AB, 16, // Offset(2085),  I2C Peripheral Device Address
    Offset(2087),   F4GP, 8,  // Offset(2087),  GPIO Group Pad Number
    Offset(2088),   F4GG, 16, // Offset(2088),  GPIO Group Number
    Offset(2090),   F4AV, 8,  // Offset(2090),  GPIO Active Value
    Offset(2091),   F4IV, 8,  // Offset(2091),  GPIO Initial Value
    Offset(2092),   F4OM, 8,  // Offset(2092),  Flash Driver Operating Mode
    Offset(2093),   F5FM, 8,  // Offset(2093),  Flash Driver Model
    Offset(2094),   F5MS, 8,  // Offset(2094),  Flash Mode Selection
    Offset(2095),   F5M0, 8,  // Offset(2095),  Flash Module Name ASCII character 0
    Offset(2096),   F5M1, 8,  // Offset(2096),
    Offset(2097),   F5M2, 8,  // Offset(2097),
    Offset(2098),   F5M3, 8,  // Offset(2098),
    Offset(2099),   F5M4, 8,  // Offset(2099),
    Offset(2100),   F5M5, 8,  // Offset(2100),
    Offset(2101),   F5M6, 8,  // Offset(2101),
    Offset(2102),   F5M7, 8,  // Offset(2102),
    Offset(2103),   F5M8, 8,  // Offset(2103),
    Offset(2104),   F5M9, 8,  // Offset(2104),
    Offset(2105),   F5MA, 8,  // Offset(2105),
    Offset(2106),   F5MB, 8,  // Offset(2106),
    Offset(2107),   F5MC, 8,  // Offset(2107),
    Offset(2108),   F5MD, 8,  // Offset(2108),
    Offset(2109),   F5ME, 8,  // Offset(2109),
    Offset(2110),   F5MF, 8,  // Offset(2110),  Flash Module Name ASCII character 15
    Offset(2111),   F5BS, 8,  // Offset(2111),  I2C Bus Number
    Offset(2112),   F5AB, 16, // Offset(2112),  I2C Peripheral Device Address
    Offset(2114),   F5GP, 8,  // Offset(2114),  GPIO Group Pad Number
    Offset(2115),   F5GG, 16, // Offset(2115),  GPIO Group Number
    Offset(2117),   F5AV, 8,  // Offset(2117),  GPIO Active Value
    Offset(2118),   F5IV, 8,  // Offset(2118),  GPIO Initial Value
    Offset(2119),   F5OM, 8,  // Offset(2119),  Flash Driver Operating Mode
    Offset(2120),             // Offset(2120) : Offset(2119), Reserved bytes
    Offset(2120),   ECR1, 8,  // Offset(2120),
    Offset(2121),   I2SC, 8,  // Offset(2121),  HD Audio I2S Codec Selection
    Offset(2122),   I2SI, 32, // Offset(2122),  HD Audio I2S Codec Interrupt Pin
    Offset(2126),   I2SB, 8,  // Offset(2126),  HD Audio I2S Codec Connection to I2C bus controller instance (I2C[0-5])
    Offset(2127),   ODV0, 8,  // Offset(2127),  Intel(R) Dynamic Tuning Technology Oem Design Variables
    Offset(2128),   ODV1, 8,  // Offset(2128),  Intel(R) Dynamic Tuning Technology Oem Design Variables
    Offset(2129),   ODV2, 8,  // Offset(2129),  Intel(R) Dynamic Tuning Technology Oem Design Variables
    Offset(2130),   ODV3, 8,  // Offset(2130),  Intel(R) Dynamic Tuning Technology Oem Design Variables
    Offset(2131),   ODV4, 8,  // Offset(2131),  Intel(R) Dynamic Tuning Technology Oem Design Variables
    Offset(2132),   ODV5, 8,  // Offset(2132),  Intel(R) Dynamic Tuning Technology Oem Design Variables
    Offset(2133),   UBCB, 32, // Offset(2133),  USB Type C Opregion base address
    Offset(2137),             // Offset(2137) : Offset(2136), Reserved bytes
    Offset(2137),   WIFC, 8,  // Offset(2137),  WirelessCharging
    Offset(2144),             // Offset(2138) : Offset(2143), Reserved bytes
    Offset(2144),   ADPM, 32, // Offset(2144),  HD-Audio DSP Post-Processing Module Mask
    Offset(2148),   AG1L, 64, // Offset(2148),  HDA PP module custom GUID 1 - first 64bit  [0-63]
    Offset(2156),   AG1H, 64, // Offset(2156),  HDA PP module custom GUID 1 - second 64bit [64-127]
    Offset(2164),   AG2L, 64, // Offset(2164),  HDA PP module custom GUID 2 - first 64bit  [0-63]
    Offset(2172),   AG2H, 64, // Offset(2172),  HDA PP module custom GUID 2 - second 64bit [64-127]
    Offset(2180),   AG3L, 64, // Offset(2180),  HDA PP module custom GUID 3 - first 64bit  [0-63]
    Offset(2188),   AG3H, 64, // Offset(2188),  HDA PP module custom GUID 3 - second 64bit [64-127]
    Offset(2196),   HEFE, 8,  // Offset(2196),  HID Event Filter Driver enable
    Offset(2197),   XDCE, 8,  // Offset(2197),  XDCI Enable/Disable status
    Offset(2198),   STXE, 8,  // Offset(2198),  WrdsWiFiSarEnable
    Offset(2199),   ST10, 8,  // Offset(2199),  WrdsWiFiSarTxPowerSet1Limit1
    Offset(2200),   ST11, 8,  // Offset(2200),  WrdsWiFiSarTxPowerSet1Limit2
    Offset(2201),   ST12, 8,  // Offset(2201),  WrdsWiFiSarTxPowerSet1Limit3
    Offset(2202),   ST13, 8,  // Offset(2202),  WrdsWiFiSarTxPowerSet1Limit4
    Offset(2203),   ST14, 8,  // Offset(2203),  WrdsWiFiSarTxPowerSet1Limit5
    Offset(2204),   ST15, 8,  // Offset(2204),  WrdsWiFiSarTxPowerSet1Limit6
    Offset(2205),   ST16, 8,  // Offset(2205),  WrdsWiFiSarTxPowerSet1Limit7
    Offset(2206),   ST17, 8,  // Offset(2206),  WrdsWiFiSarTxPowerSet1Limit8
    Offset(2207),   ST18, 8,  // Offset(2207),  WrdsWiFiSarTxPowerSet1Limit9
    Offset(2208),   ST19, 8,  // Offset(2208),  WrdsWiFiSarTxPowerSet1Limit10
    Offset(2209),   ENVM, 8,  // Offset(2209),  Enable Voltage Margining
    Offset(2210),   DHSP, 16, // Offset(2210),  D-State for xHCI HS port(BIT0:USB HS Port0 ~ BIT15:USB HS Port15)
    Offset(2212),   DSSP, 16, // Offset(2212),  D-State for xHCI SS port(BIT0:USB SS Port0 ~ BIT15:USB SS Port15)
    Offset(2214),   DSTP, 8,  // Offset(2214),  D-State for SATA port(BIT0:SATA Port0 ~ BIT7:SATA Port7)
    Offset(2215),   STDE, 8,  // Offset(2215),  EwrdWiFiDynamicSarEnable
    Offset(2216),   STRS, 8,  // Offset(2216),  EwrdWiFiDynamicSarRangeSets
    Offset(2217),   ST20, 8,  // Offset(2217),  EwrdWiFiSarTxPowerSet2Limit1
    Offset(2218),   ST21, 8,  // Offset(2218),  EwrdWiFiSarTxPowerSet2Limit2
    Offset(2219),   ST22, 8,  // Offset(2219),  EwrdWiFiSarTxPowerSet2Limit3
    Offset(2220),   ST23, 8,  // Offset(2220),  EwrdWiFiSarTxPowerSet2Limit4
    Offset(2221),   ST24, 8,  // Offset(2221),  EwrdWiFiSarTxPowerSet2Limit5
    Offset(2222),   ST25, 8,  // Offset(2222),  EwrdWiFiSarTxPowerSet2Limit6
    Offset(2223),   ST26, 8,  // Offset(2223),  EwrdWiFiSarTxPowerSet2Limit7
    Offset(2224),   ST27, 8,  // Offset(2224),  EwrdWiFiSarTxPowerSet2Limit8
    Offset(2225),   ST28, 8,  // Offset(2225),  EwrdWiFiSarTxPowerSet2Limit9
    Offset(2226),   ST29, 8,  // Offset(2226),  EwrdWiFiSarTxPowerSet2Limit10
    Offset(2227),   ST30, 8,  // Offset(2227),  EwrdWiFiSarTxPowerSet3Limit1
    Offset(2228),   ST31, 8,  // Offset(2228),  EwrdWiFiSarTxPowerSet3Limit2
    Offset(2229),   ST32, 8,  // Offset(2229),  EwrdWiFiSarTxPowerSet3Limit3
    Offset(2230),   ST33, 8,  // Offset(2230),  EwrdWiFiSarTxPowerSet3Limit4
    Offset(2231),   ST34, 8,  // Offset(2231),  EwrdWiFiSarTxPowerSet3Limit5
    Offset(2232),   ST35, 8,  // Offset(2232),  EwrdWiFiSarTxPowerSet3Limit6
    Offset(2233),   ST36, 8,  // Offset(2233),  EwrdWiFiSarTxPowerSet3Limit7
    Offset(2234),   ST37, 8,  // Offset(2234),  EwrdWiFiSarTxPowerSet3Limit8
    Offset(2235),   ST38, 8,  // Offset(2235),  EwrdWiFiSarTxPowerSet3Limit9
    Offset(2236),   ST39, 8,  // Offset(2236),  EwrdWiFiSarTxPowerSet3Limit10
    Offset(2237),   ST40, 8,  // Offset(2237),  EwrdWiFiSarTxPowerSet4Limit1
    Offset(2238),   ST41, 8,  // Offset(2238),  EwrdWiFiSarTxPowerSet4Limit2
    Offset(2239),   ST42, 8,  // Offset(2239),  EwrdWiFiSarTxPowerSet4Limit3
    Offset(2240),   ST43, 8,  // Offset(2240),  EwrdWiFiSarTxPowerSet4Limit4
    Offset(2241),   ST44, 8,  // Offset(2241),  EwrdWiFiSarTxPowerSet4Limit5
    Offset(2242),   ST45, 8,  // Offset(2242),  EwrdWiFiSarTxPowerSet4Limit6
    Offset(2243),   ST46, 8,  // Offset(2243),  EwrdWiFiSarTxPowerSet4Limit7
    Offset(2244),   ST47, 8,  // Offset(2244),  EwrdWiFiSarTxPowerSet4Limit8
    Offset(2245),   ST48, 8,  // Offset(2245),  EwrdWiFiSarTxPowerSet4Limit9
    Offset(2246),   ST49, 8,  // Offset(2246),  EwrdWiFiSarTxPowerSet4Limit10
    Offset(2247),   SD11, 8,  // Offset(2247),  WgdsWiFiSarDeltaGroup1PowerMax1
    Offset(2248),   SD12, 8,  // Offset(2248),  WgdsWiFiSarDeltaGroup1PowerChainA1
    Offset(2249),   SD13, 8,  // Offset(2249),  WgdsWiFiSarDeltaGroup1PowerChainB1
    Offset(2250),   SD14, 8,  // Offset(2250),  WgdsWiFiSarDeltaGroup1PowerMax2
    Offset(2251),   SD15, 8,  // Offset(2251),  WgdsWiFiSarDeltaGroup1PowerChainA2
    Offset(2252),   SD16, 8,  // Offset(2252),  WgdsWiFiSarDeltaGroup1PowerChainB2
    Offset(2253),   SD21, 8,  // Offset(2253),  WgdsWiFiSarDeltaGroup2PowerMax1
    Offset(2254),   SD22, 8,  // Offset(2254),  WgdsWiFiSarDeltaGroup2PowerChainA1
    Offset(2255),   SD23, 8,  // Offset(2255),  WgdsWiFiSarDeltaGroup2PowerChainB1
    Offset(2256),   SD24, 8,  // Offset(2256),  WgdsWiFiSarDeltaGroup2PowerMax2
    Offset(2257),   SD25, 8,  // Offset(2257),  WgdsWiFiSarDeltaGroup2PowerChainA2
    Offset(2258),   SD26, 8,  // Offset(2258),  WgdsWiFiSarDeltaGroup2PowerChainB2
    Offset(2259),   SD31, 8,  // Offset(2259),  WgdsWiFiSarDeltaGroup3PowerMax1
    Offset(2260),   SD32, 8,  // Offset(2260),  WgdsWiFiSarDeltaGroup3PowerChainA1
    Offset(2261),   SD33, 8,  // Offset(2261),  WgdsWiFiSarDeltaGroup3PowerChainB1
    Offset(2262),   SD34, 8,  // Offset(2262),  WgdsWiFiSarDeltaGroup3PowerMax2
    Offset(2263),   SD35, 8,  // Offset(2263),  WgdsWiFiSarDeltaGroup3PowerChainA2
    Offset(2264),   SD36, 8,  // Offset(2264),  WgdsWiFiSarDeltaGroup3PowerChainB2
    Offset(2306),             // Offset(2265) : Offset(2305), Reserved bytes
    // Reserved for Groups 4 to 9, each needs 6 bytes and total 36 bytes reserved
    Offset(2306),   SDAA, 8,  // Offset(2306),  WiFiDynamicSarAntennaACurrentSet
    Offset(2307),   SDAB, 8,  // Offset(2307),  WiFiDynamicSarAntennaBCurrentSet
    Offset(2308),   BTSE, 8,  // Offset(2308),  BluetoothSar
    Offset(2309),   BTBR, 8,  // Offset(2309),  BluetoothSarBr
    Offset(2310),   BED2, 8,  // Offset(2310),  BluetoothSarEdr2
    Offset(2311),   BED3, 8,  // Offset(2311),  BluetoothSarEdr3
    Offset(2312),   BTLE, 8,  // Offset(2312),  BluetoothSarLe
    Offset(2313),   BTL2, 8,  // Offset(2313),  BluetoothSarLe2Mhz
    Offset(2314),   BTLL, 8,  // Offset(2314),  BluetoothSarLeLr
    Offset(2317),             // Offset(2315) : Offset(2316), Reserved bytes
    // Reserved for Bluetooth Sar future use
    Offset(2317),   ATDV, 8,  // Offset(2317),  AntennaDiversity
    Offset(2318),   COEM, 8,  // Offset(2318),  CoExistenceManager
    Offset(2319),   RTVM, 8,  // Offset(2319),  RunTime VM Control
    //
    //Feature Specific Data Bits
    //
    Offset(2320),   USTC, 8,  // Offset(2320),  USB Type C Supported
    Offset(2321),   HEB1, 32, // Offset(2321),  HebcValue
    Offset(2325),   BATP, 8,  // Offset(2325),  Battery Present - Bit0: Real Battery is supported on this platform. Bit1: Virtual Battery is supported on this platform.
    Offset(2326),   TSDB, 8,  // Offset(2326),  TS-on-DIMM temperature
    Offset(2327),   EPTU, 8,  // Offset(2327),  Enable PCIE tunnelling support over USB4 links.
    Offset(2329),             // Offset(2328) : Offset(2328), Reserved bytes
    Offset(2329),   RBY1, 8,  // Offset(2329),  Real Battery 1 Control
    Offset(2330),   RBY2, 8,  // Offset(2330),  Real Battery 2 Control
    Offset(2331),   SCSS, 8,  // Offset(2331),  Mipi Camera Sensor
    Offset(2332),   NCTC, 8,  // Offset(2332),  NCT6776F COM
    Offset(2333),   NCTI, 8,  // Offset(2333),  NCT6776F SIO
    Offset(2334),   NCTH, 8,  // Offset(2334),  NCT6776F HWMON
    Offset(2335),   HSIO, 8,  // Offset(2335),  H8S2113 SIO
    Offset(2336),   ZPOD, 8,  // Offset(2336),  ZPODD
    Offset(2337),   RGBC, 8,  // Offset(2337),  RGB Camera Address
    Offset(2338),   DPTC, 8,  // Offset(2338),  Depth Camera Addresy
    Offset(2339),   SRSP, 32, // Offset(2339),  SMC Runtime Sci Pin
    Offset(2343),   CEDS, 8,  // Offset(2343),  Convertable Dock Support
    Offset(2344),   EHK3, 8,  // Offset(2344),  Ec Hotkey F3 Support
    Offset(2345),   EHK4, 8,  // Offset(2345),  Ec Hotkey F4 Support
    Offset(2346),   EHK5, 8,  // Offset(2346),  Ec Hotkey F5 Support
    Offset(2347),   EHK6, 8,  // Offset(2347),  Ec Hotkey F6 Support
    Offset(2348),   EHK7, 8,  // Offset(2348),  Ec Hotkey F7 Support
    Offset(2349),   EHK8, 8,  // Offset(2349),  Ec Hotkey F8 Support
    Offset(2350),   VBVP, 8,  // Offset(2350),  Virtual Button Volume Up Support
    Offset(2351),   VBVD, 8,  // Offset(2351),  Virtual Button Volume Down Support
    Offset(2352),   VBHB, 8,  // Offset(2352),  Virtual Button Home Button Support
    Offset(2353),   VBRL, 8,  // Offset(2353),  Virtual Button Rotation Lock Support
    Offset(2354),   SMSS, 8,  // Offset(2354),  Slate Mode Switch Support
    Offset(2355),   VBST, 8,  // Offset(2355),  Virtual Button Support
    Offset(2356),   ADAS, 8,  // Offset(2356),  Ac Dc Auto Switch Support
    Offset(2357),   PPBG, 32, // Offset(2357),  Pm Power Button Gpio Pin
    Offset(2361),   AEAB, 8,  // Offset(2361),  Acpi Enable All Button Support
    Offset(2362),   AHDB, 8,  // Offset(2362),  Acpi Hid Driver Button Support
    Offset(2363),   ELPM, 32, // Offset(2363),  EcLowPowerModeGpioPin
    Offset(2367),   ELPS, 32, // Offset(2367),  EcSmiGpioPin
    //
    // UCMC setup option, GPIO Pad
    //
    Offset(2371),   UCMS, 8,  // Offset(2371),  Option to select UCSI/UCMC device
    Offset(2372),   UCG1, 32, // Offset(2372),  Gpio for UCMC Port 1 Interrupt
    Offset(2376),   UCG2, 32, // Offset(2376),  Gpio for UCMC Port 2 Interrupt
    Offset(2380),   UCG3, 32, // Offset(2380),  Gpio for UCMC Port 3 Interrupt
    Offset(2384),   UCG4, 32, // Offset(2384),  Gpio for UCMC Port 4 Interrupt
    Offset(2388),   UTCE, 8,  // Offset(2388),  USB Type C EC None EC PD
    Offset(2409),             // Offset(2389) : Offset(2408), Reserved bytes
    Offset(2409),   PCHE, 8,  // Offset(2409),  EnablePchFivrParticipant
    Offset(2413),             // Offset(2410) : Offset(2412), Reserved bytes
    Offset(2413),   UDGF, 8,  // Offset(2413),  Upstream Facing port or Downstream Facing port Global Flag from LPC EC
    Offset(2414),   UDUP, 8,  // Offset(2414),  Upstream Facing port or Downstream Facing port number from LPC EC
    Offset(2415),   DBGF, 8,  // Offset(2415),  Debug Mode Global Flag from LPC EC
    Offset(2416),   DBUP, 8,  // Offset(2416),  Debug Mode USB Port Number from LPC EC
    Offset(2417),   TTUP, 8,  // Offset(2417),  Total Number of type C ports that are supported by platform
    Offset(2418),   TP1T, 8,  // Offset(2418),  Type C Connector 1  Port mapping within the controller the port exposed
    Offset(2419),   TP1P, 8,  // Offset(2419),  Type C Connector 1  Port mapping within the PCH controller (If Split mode supported)
    Offset(2420),   TP1D, 8,  // Offset(2420),  Type C Connector 1  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2421),   TP2T, 8,  // Offset(2421),  Type C Connector 2  Port mapping within the controller the port exposed
    Offset(2422),   TP2P, 8,  // Offset(2422),  Type C Connector 2  Port mapping within the PCH controller (If Split mode supported)
    Offset(2423),   TP2D, 8,  // Offset(2423),  Type C Connector 2  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2424),   TP3T, 8,  // Offset(2424),  Type C Connector 3  Port mapping within the controller the port exposed
    Offset(2425),   TP3P, 8,  // Offset(2425),  Type C Connector 3  Port mapping within the PCH controller (If Split mode supported)
    Offset(2426),   TP3D, 8,  // Offset(2426),  Type C Connector 3  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2427),   TP4T, 8,  // Offset(2427),  Type C Connector 4  Port mapping within the controller the port exposed
    Offset(2428),   TP4P, 8,  // Offset(2428),  Type C Connector 4  Port mapping within the PCH controller (If Split mode supported)
    Offset(2429),   TP4D, 8,  // Offset(2429),  Type C Connector 4  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2430),   TP5T, 8,  // Offset(2430),  Type C Connector 5  Port mapping within the controller the port exposed
    Offset(2431),   TP5P, 8,  // Offset(2431),  Type C Connector 5  Port mapping within the PCH controller (If Split mode supported)
    Offset(2432),   TP5D, 8,  // Offset(2432),  Type C Connector 5  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2433),   TP6T, 8,  // Offset(2433),  Type C Connector 6  Port mapping within the controller the port exposed
    Offset(2434),   TP6P, 8,  // Offset(2434),  Type C Connector 6  Port mapping within the PCH controller (If Split mode supported)
    Offset(2435),   TP6D, 8,  // Offset(2435),  Type C Connector 6  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2436),   STAS, 8,  // Offset(2436),  Select source for System time and alarm
    Offset(2437),   WRTO, 8,  // Offset(2437),  WWAN RTD3 options
    Offset(2438),   PRST, 32, // Offset(2438),  WWAN PERST Gpio pin
    Offset(2442),   WPRP, 8,  // Offset(2442),  WWAN PERST Gpio polarity
    Offset(2443),   PUIS, 8,  // Offset(2443),  Power Up In Standby mode
    Offset(2444),   PSWP, 32, // Offset(2444),  Pcie Slot Wake Gpio pin
    Offset(2448),   RPNB, 8,  // Offset(2448),  Pcie Slot Root Port Number
    Offset(2449),   POME, 8,  // Offset(2449),  Enable PowerMeter
    Offset(2450),   PSW2, 32, // Offset(2450),  Pcie Slot 2 Wake Gpio pin
    Offset(2454),   RPN2, 8,  // Offset(2454),  Pcie Slot 2 Root Port Number
    Offset(2455),   WFCP, 32, // Offset(2455),  WWAN Full card power off gpio pin
    Offset(2459),   PFCP, 8,  // Offset(2459),  WWAN Full card power off gpio pin polarity
    Offset(2460),   WBRS, 32, // Offset(2460),  WWAN BBRST Gpio pin
    Offset(2464),   PBRS, 8,  // Offset(2464),  WWAN BBRST Gpio pin polarity
    Offset(2465),   WWKP, 32, // Offset(2465),  WWAN Wake Gpio pin
    Offset(2469),   GPLP, 32, // Offset(2469),  Gpio for touchPaneL 0 power enable
    Offset(2473),   GPLR, 32, // Offset(2473),  Gpio for touchPaneL 0 Reset
    Offset(2477),   GPI1, 32, // Offset(2477),  Gpio for touchPaneL 1 Interrupt
    Offset(2481),   TPP1, 32, // Offset(2481),  Gpio for touchPaneL 1 power enable
    Offset(2485),   TPR1, 32, // Offset(2485),  Gpio for touchPaneL 1 Reset
    Offset(2489),   PPDI, 8,  // Offset(2489),  TouchPaD Interrupt Gpio pin polarity
    Offset(2490),   PPLI, 8,  // Offset(2490),  TouchPaneL 0 Interrupt Gpio pin polarity
    Offset(2491),   PPLP, 8,  // Offset(2491),  TouchPaneL 0 power enable Gpio pin polarity
    Offset(2492),   PPLR, 8,  // Offset(2492),  TouchPaneL 0 Reset Gpio pin polarity
    Offset(2493),   PPI1, 8,  // Offset(2493),  TouchPaneL 1 Interrupt Gpio pin polarity
    Offset(2494),   PPP1, 8,  // Offset(2494),  TouchPaneL 1 power enable Gpio pin polarity
    Offset(2495),   PPR1, 8,  // Offset(2495),  TouchPaneL 1 Reset Gpio pin polarity
    Offset(2496),   PSPE, 32, // Offset(2496),  Pcie Slot 1 Power Enable Gpio pin
    Offset(2500),   PPSP, 8,  // Offset(2500),  Pcie Slot 1 Power Enable Gpio pin polarity
    Offset(2501),   PSPR, 32, // Offset(2501),  Pcie Slot 1 Rest Gpio pin
    Offset(2505),   PPSR, 8,  // Offset(2505),  Pcie Slot 1 Rest Gpio pin polarity
    Offset(2506),   PSP2, 32, // Offset(2506),  Pcie Slot 2 Power Enable Gpio pin
    Offset(2510),   PS2P, 8,  // Offset(2510),  Pcie Slot 2 Power Enable Gpio pin polarity
    Offset(2511),   PSR2, 32, // Offset(2511),  Pcie Slot 2 Rest Gpio pin
    Offset(2515),   SR2P, 8,  // Offset(2515),  Pcie Slot 2 Rest Gpio pin polarity
    Offset(2516),   WLWK, 32, // Offset(2516),  WLAN Wake Gpio pin
    Offset(2520),   WLRP, 8,  // Offset(2520),  WLAN Root Port Number
    Offset(2521),   SATP, 32, // Offset(2521),  Sata port Power Enable Gpio pin
    Offset(2525),   STPP, 8,  // Offset(2525),  Sata port Power Enable Gpio pin polarity
    Offset(2526),   SSDP, 32, // Offset(2526),  Pch M.2 SSD Power Enable Gpio pin
    Offset(2530),   SDPP, 8,  // Offset(2530),  Pch M.2 SSD Power Enable Gpio pin polarity
    Offset(2531),   SSDR, 32, // Offset(2531),  Pch M.2 SSD Reset Gpio pin
    Offset(2535),   SDRP, 8,  // Offset(2535),  Pch M.2 SSD Reset Gpio pin polarity
    Offset(2536),   SD2P, 32, // Offset(2536),  PCIe x4 M.2 SSD Power Enable Gpio pin
    Offset(2540),   SDP1, 8,  // Offset(2540),  PCIe x4 M.2 SSD Power Enable Gpio pin polarity
    Offset(2541),   SD2R, 32, // Offset(2541),  PCIe x4 M.2 SSD Reset Gpio pin
    Offset(2545),   SDR1, 8,  // Offset(2545),  PCIe x4 M.2 SSD Reset Gpio pin polarity
    Offset(2546),   SD5P, 32, // Offset(2546),  PCIe x4 M.2 SSD Power Enable Gpio pin
    Offset(2550),   SDP5, 8,  // Offset(2550),  PCIe x4 M.2 SSD Power Enable Gpio pin polarity
    Offset(2551),   SD5R, 32, // Offset(2551),  PCIe x4 M.2 SSD Reset Gpio pin
    Offset(2555),   SDR5, 8,  // Offset(2555),  PCIe x4 M.2 SSD Reset Gpio pin polarity
    Offset(2556),   DG2P, 32, // Offset(2556),  PCIe x5 M.2 Discrete Graphics Power Enable Gpio Pin
    Offset(2560),   DGP2, 8,  // Offset(2560),  PCIe x5 M.2 Discrete Graphics Power Enable Gpio Pin polarity
    Offset(2561),   DG2R, 32, // Offset(2561),  PCIe x5 M.2 Discrete Graphics Reset Gpio Pin
    Offset(2565),   DGR2, 8,  // Offset(2565),  PCIe x5 M.2 Discrete Graphics Reset Gpio Pin Polarity
    Offset(2566),   DGWP, 32, // Offset(2566),  PEG X8 DG/DG2 Wake Gpio pin
    Offset(2570),   SXI1, 8,  // Offset(2570),  SDEV xHCI Interface Number for device 1
    Offset(2571),   SXI2, 8,  // Offset(2571),  SDEV xHCI Interface Number for device 2
    Offset(2572),   SXP1, 8,  // Offset(2572),  SDEV xHCI Root Port Number for device 1
    Offset(2573),   SXP2, 8,  // Offset(2573),  SDEV xHCI Root Port Number for device 2
    Offset(2574),   TSD0, 8,  // Offset(2574),  TSN PCS device Enable
    Offset(2575),   WCLK, 8,  // Offset(2575),  WWAN Source Clock
    Offset(2576),   CWEF, 8,  // Offset(2576),  CPU_WAKE_EN value
    Offset(2577),   CECV, 32, // Offset(2577),  CNV external 32KHz Clock
    Offset(2581),   WWRP, 8,  // Offset(2581),  WWAN Root Port Number
    Offset(2582),   GDOW, 8,  // Offset(2582),  PCIe Device On WWAN slot
    Offset(2583),   WAGE, 8,  // Offset(2583),  Wifi Ant Gain Enable
    Offset(2584),   AGA1, 8,  // Offset(2584),  Ant Gain Table Chain A 2400
    Offset(2585),   AGA2, 8,  // Offset(2585),  Ant Gain Table Chain A 5150-5350
    Offset(2586),   AGA3, 8,  // Offset(2586),  Ant Gain Table Chain A 5350-5470
    Offset(2587),   AGA4, 8,  // Offset(2587),  Ant Gain Table Chain A 5470-5725
    Offset(2588),   AGA5, 8,  // Offset(2588),  Ant Gain Table Chain A 5725-5950
    Offset(2589),   AGB1, 8,  // Offset(2589),  Ant Gain Table Chain B 2400
    Offset(2590),   AGB2, 8,  // Offset(2590),  Ant Gain Table Chain B 5150-5350
    Offset(2591),   AGB3, 8,  // Offset(2591),  Ant Gain Table Chain B 5350-5470
    Offset(2592),   AGB4, 8,  // Offset(2592),  Ant Gain Table Chain B 5470-5725
    Offset(2593),   AGB5, 8,  // Offset(2593),  Ant Gain Table Chain B 5725-5950
    Offset(2594),   SGMM, 8,  // Offset(2594),  SAR GEO Mapping Mode    @deprecated.
    Offset(2595),   SG00, 8,  // Offset(2595),  0 - DEFAULT            @deprecated.
    Offset(2596),   SG01, 8,  // Offset(2596),  1 - FCC                @deprecated.
    Offset(2597),   SG02, 8,  // Offset(2597),  2 - TW and alike       @deprecated.
    Offset(2598),   SG03, 8,  // Offset(2598),  3 - Canada ISED        @deprecated.
    Offset(2599),   SG04, 8,  // Offset(2599),  4 - ETSI 5G8SRD        @deprecated.
    Offset(2600),   SG05, 8,  // Offset(2600),  5 - ETSI 5G8Med        @deprecated.
    Offset(2601),   SG06, 8,  // Offset(2601),  6 - Japan              @deprecated.
    Offset(2602),   SG07, 8,  // Offset(2602),  7 - Brazil             @deprecated.
    Offset(2603),   SG08, 8,  // Offset(2603),  8 - ETSI 5G8FCC        @deprecated.
    Offset(2604),   SG09, 8,  // Offset(2604),  9 - Indonesia          @deprecated.
    Offset(2605),   SG10, 8,  // Offset(2605),  10 - South Korea        @deprecated.
    Offset(2606),   SG11, 8,  // Offset(2606),  11 - Chile              @deprecated.
    Offset(2607),   SG12, 8,  // Offset(2607),  12 - ETSI 5G8Pass       @deprecated.
    Offset(2608),   SG13, 8,  // Offset(2608),  13 - Pakistan           @deprecated.
    Offset(2609),   SG14, 8,  // Offset(2609),  14 - Egypt              @deprecated.
    Offset(2610),   SG15, 8,  // Offset(2610),  15 - Tunisia            @deprecated.
    Offset(2611),   SG16, 8,  // Offset(2611),  16 - China BIOS         @deprecated.
    Offset(2612),   SG17, 8,  // Offset(2612),  17 - Russia             @deprecated.
    Offset(2613),   SG18, 8,  // Offset(2613),  18 - EU + ETSI + 5G8SRD @deprecated.
    Offset(2614),   ACSD, 8,  // Offset(2614),  SRD Active Channels Selection
    Offset(2615),   I5BS, 8,  // Offset(2615),  Indonesia 5.15-5.35 GHz Band Support Selection
    Offset(2616),   DGVR, 32, // Offset(2616),  DG1 VRAM Self Refresh Gpio pin
    Offset(2620),   LPMR, 32, // Offset(2620),  Low Power Mode required register Address
    Offset(2624),   SG19, 8,  // Offset(2624),  19 - USA Only           @deprecated.
    Offset(2625),   SG20, 8,  // Offset(2625),  20 - EU + ETSI + 5G8DFS @deprecated.
    Offset(2626),   SG21, 8,  // Offset(2626),  21 - Qatar              @deprecated.
    Offset(2627),   P1PE, 32, // Offset(2627),  PEG slot 1 Power Enable Gpio pin
    Offset(2631),   P1PP, 8,  // Offset(2631),  PEG slot 1 Power Enable Gpio pin polarity
    Offset(2632),   P1RE, 32, // Offset(2632),  PEG slot 1 Reset Gpio pin
    Offset(2636),   P1RP, 8,  // Offset(2636),  PEG slot 1 Reset Gpio pin polarity
    Offset(2637),   P1WP, 32, // Offset(2637),  PEG slot 1 Wake Gpio pin
    Offset(2641),   PRP1, 8,  // Offset(2641),  PEG slot 1 Root Port
    Offset(2642),   P2PE, 32, // Offset(2642),  PEG slot 2 Power Enable Gpio pin
    Offset(2646),   P2PP, 8,  // Offset(2646),  PEG slot 2 Power Enable Gpio pin polarity
    Offset(2647),   P2RE, 32, // Offset(2647),  PEG slot 2 Reset Gpio pin
    Offset(2651),   P2RP, 8,  // Offset(2651),  PEG slot 2 Reset Gpio pin polarity
    Offset(2652),   P2WP, 32, // Offset(2652),  PEG slot 2 Wake Gpio pin
    Offset(2656),   PRP2, 8,  // Offset(2656),  PEG slot 2 Root Port
    Offset(2657),   PSP3, 32, // Offset(2657),  Pcie Slot 3 Power Enable Gpio pin
    Offset(2661),   PS3P, 8,  // Offset(2661),  Pcie Slot 3 Power Enable Gpio pin polarity
    Offset(2662),   PSR3, 32, // Offset(2662),  Pcie Slot 3 Rest Gpio pin
    Offset(2666),   SR3P, 8,  // Offset(2666),  Pcie Slot 3 Rest Gpio pin polarity
    Offset(2667),   PSW3, 32, // Offset(2667),  Pcie Slot 3 Wake Gpio pin
    Offset(2671),   RPN3, 8,  // Offset(2671),  Pcie Slot 3 Root Port Number
    Offset(2672),   SD3P, 32, // Offset(2672),  Pch M.2 SSD2 Power Enable Gpio pin
    Offset(2676),   SDP3, 8,  // Offset(2676),  Pch M.2 SSD2 Power Enable Gpio pin polarity
    Offset(2677),   SD3R, 32, // Offset(2677),  Pch M.2 SSD2 Reset Gpio pin
    Offset(2681),   SDR3, 8,  // Offset(2681),  Pch M.2 SSD2 Reset Gpio pin polarity
    Offset(2682),   SD4P, 32, // Offset(2682),  Pch M.2 SSD3 Power Enable Gpio pin
    Offset(2686),   SDP4, 8,  // Offset(2686),  Pch M.2 SSD3 Power Enable Gpio pin polarity
    Offset(2687),   SD4R, 32, // Offset(2687),  Pch M.2 SSD3 Reset Gpio pin
    Offset(2691),   SDR4, 8,  // Offset(2691),  Pch M.2 SSD3 Reset Gpio pin polarity
    //
    // XTU SMI base address
    //
    Offset(2692),   XSMI, 32, // Offset(2692),  XTU SMI memory in ACPI NVS
    Offset(2696),   DUWS, 8,  // Offset(2696),  Deepest USB Sleep Wake Capability
    Offset(2697),   ST50, 8,  // Offset(2697),  WrdsWiFiSarTxPowerSet1Limit11
    Offset(2698),   ST51, 8,  // Offset(2698),  WrdsWiFiSarTxPowerSet1Limit12
    Offset(2699),   ST52, 8,  // Offset(2699),  WrdsWiFiSarTxPowerSet1Limit13
    Offset(2700),   ST53, 8,  // Offset(2700),  WrdsWiFiSarTxPowerSet1Limit14
    Offset(2701),   ST54, 8,  // Offset(2701),  WrdsWiFiSarTxPowerSet1Limit15
    Offset(2702),   ST55, 8,  // Offset(2702),  WrdsWiFiSarTxPowerSet1Limit16
    Offset(2703),   ST56, 8,  // Offset(2703),  WrdsWiFiSarTxPowerSet1Limit17
    Offset(2704),   ST57, 8,  // Offset(2704),  WrdsWiFiSarTxPowerSet1Limit18
    Offset(2705),   ST58, 8,  // Offset(2705),  WrdsWiFiSarTxPowerSet1Limit19
    Offset(2706),   ST59, 8,  // Offset(2706),  WrdsWiFiSarTxPowerSet1Limit20
    Offset(2707),   ST5A, 8,  // Offset(2707),  WrdsWiFiSarTxPowerSet1Limit21
    Offset(2708),   ST5B, 8,  // Offset(2708),  WrdsWiFiSarTxPowerSet1Limit22
    Offset(2709),   ST60, 8,  // Offset(2709),  EwrdWiFiSarTxPowerSet2Limit11
    Offset(2710),   ST61, 8,  // Offset(2710),  EwrdWiFiSarTxPowerSet2Limit12
    Offset(2711),   ST62, 8,  // Offset(2711),  EwrdWiFiSarTxPowerSet2Limit13
    Offset(2712),   ST63, 8,  // Offset(2712),  EwrdWiFiSarTxPowerSet2Limit14
    Offset(2713),   ST64, 8,  // Offset(2713),  EwrdWiFiSarTxPowerSet2Limit15
    Offset(2714),   ST65, 8,  // Offset(2714),  EwrdWiFiSarTxPowerSet2Limit16
    Offset(2715),   ST66, 8,  // Offset(2715),  EwrdWiFiSarTxPowerSet2Limit17
    Offset(2716),   ST67, 8,  // Offset(2716),  EwrdWiFiSarTxPowerSet2Limit18
    Offset(2717),   ST68, 8,  // Offset(2717),  EwrdWiFiSarTxPowerSet2Limit19
    Offset(2718),   ST69, 8,  // Offset(2718),  EwrdWiFiSarTxPowerSet2Limit20
    Offset(2719),   ST6A, 8,  // Offset(2719),  EwrdWiFiSarTxPowerSet2Limit21
    Offset(2720),   ST6B, 8,  // Offset(2720),  EwrdWiFiSarTxPowerSet2Limit22
    Offset(2721),   ST70, 8,  // Offset(2721),  EwrdWiFiSarTxPowerSet3Limit11
    Offset(2722),   ST71, 8,  // Offset(2722),  EwrdWiFiSarTxPowerSet3Limit12
    Offset(2723),   ST72, 8,  // Offset(2723),  EwrdWiFiSarTxPowerSet3Limit13
    Offset(2724),   ST73, 8,  // Offset(2724),  EwrdWiFiSarTxPowerSet3Limit14
    Offset(2725),   ST74, 8,  // Offset(2725),  EwrdWiFiSarTxPowerSet3Limit15
    Offset(2726),   ST75, 8,  // Offset(2726),  EwrdWiFiSarTxPowerSet3Limit16
    Offset(2727),   ST76, 8,  // Offset(2727),  EwrdWiFiSarTxPowerSet3Limit17
    Offset(2728),   ST77, 8,  // Offset(2728),  EwrdWiFiSarTxPowerSet3Limit18
    Offset(2729),   ST78, 8,  // Offset(2729),  EwrdWiFiSarTxPowerSet3Limit19
    Offset(2730),   ST79, 8,  // Offset(2730),  EwrdWiFiSarTxPowerSet3Limit20
    Offset(2731),   ST7A, 8,  // Offset(2731),  EwrdWiFiSarTxPowerSet3Limit21
    Offset(2732),   ST7B, 8,  // Offset(2732),  EwrdWiFiSarTxPowerSet3Limit22
    Offset(2733),   ST80, 8,  // Offset(2733),  EwrdWiFiSarTxPowerSet4Limit11
    Offset(2734),   ST81, 8,  // Offset(2734),  EwrdWiFiSarTxPowerSet4Limit12
    Offset(2735),   ST82, 8,  // Offset(2735),  EwrdWiFiSarTxPowerSet4Limit13
    Offset(2736),   ST83, 8,  // Offset(2736),  EwrdWiFiSarTxPowerSet4Limit14
    Offset(2737),   ST84, 8,  // Offset(2737),  EwrdWiFiSarTxPowerSet4Limit15
    Offset(2738),   ST85, 8,  // Offset(2738),  EwrdWiFiSarTxPowerSet4Limit16
    Offset(2739),   ST86, 8,  // Offset(2739),  EwrdWiFiSarTxPowerSet4Limit17
    Offset(2740),   ST87, 8,  // Offset(2740),  EwrdWiFiSarTxPowerSet4Limit18
    Offset(2741),   ST88, 8,  // Offset(2741),  EwrdWiFiSarTxPowerSet4Limit19
    Offset(2742),   ST89, 8,  // Offset(2742),  EwrdWiFiSarTxPowerSet4Limit20
    Offset(2743),   ST8A, 8,  // Offset(2743),  EwrdWiFiSarTxPowerSet4Limit21
    Offset(2744),   ST8B, 8,  // Offset(2744),  EwrdWiFiSarTxPowerSet4Limit22
    Offset(2745),   SD17, 8,  // Offset(2745),  WgdsWiFiSarDeltaGroup1PowerMax3
    Offset(2746),   SD18, 8,  // Offset(2746),  WgdsWiFiSarDeltaGroup1PowerChainA3
    Offset(2747),   SD19, 8,  // Offset(2747),  WgdsWiFiSarDeltaGroup1PowerChainB3
    Offset(2748),   SD27, 8,  // Offset(2748),  WgdsWiFiSarDeltaGroup2PowerMax3
    Offset(2749),   SD28, 8,  // Offset(2749),  WgdsWiFiSarDeltaGroup2PowerChainA3
    Offset(2750),   SD29, 8,  // Offset(2750),  WgdsWiFiSarDeltaGroup2PowerChainB3
    Offset(2751),   SD37, 8,  // Offset(2751),  WgdsWiFiSarDeltaGroup3PowerMax3
    Offset(2752),   SD38, 8,  // Offset(2752),  WgdsWiFiSarDeltaGroup3PowerChainA3
    Offset(2753),   SD39, 8,  // Offset(2753),  WgdsWiFiSarDeltaGroup3PowerChainB3
    Offset(2754),   AGA6, 8,  // Offset(2754),  Ant Gain Table Chain A 5945-6165git
    Offset(2755),   AGA7, 8,  // Offset(2755),  Ant Gain Table Chain A 6165-6405
    Offset(2756),   AGA8, 8,  // Offset(2756),  Ant Gain Table Chain A 6405-6525
    Offset(2757),   AGA9, 8,  // Offset(2757),  Ant Gain Table Chain A 6525-6705
    Offset(2758),   AGAA, 8,  // Offset(2758),  Ant Gain Table Chain A 6705-6865
    Offset(2759),   AGAB, 8,  // Offset(2759),  Ant Gain Table Chain A 6865-7105
    Offset(2760),   AGB6, 8,  // Offset(2760),  Ant Gain Table Chain B 5945-6165
    Offset(2761),   AGB7, 8,  // Offset(2761),  Ant Gain Table Chain B 6165-6405
    Offset(2762),   AGB8, 8,  // Offset(2762),  Ant Gain Table Chain B 6405-6525
    Offset(2763),   AGB9, 8,  // Offset(2763),  Ant Gain Table Chain B 6525-6705
    Offset(2764),   AGBA, 8,  // Offset(2764),  Ant Gain Table Chain B 6705-6865
    Offset(2765),   AGBB, 8,  // Offset(2765),  Ant Gain Table Chain B 6865-7105
    Offset(2766),   UHBS, 32, // Offset(2766),  WifiUltraHighBandSupport
    Offset(2770),   AXSU, 8,  // Offset(2770),  11AxSettingUkraine
    Offset(2771),   AXMU, 8,  // Offset(2771),  11AxModeUkraine
    Offset(2772),   AXSR, 8,  // Offset(2772),  11AxSettingRussia
    Offset(2773),   AXMR, 8,  // Offset(2773),  11AxModeRussia
    Offset(2774),   CD10, 8,  // Offset(2774),  WrdsCdbWiFiSarTxPowerSet1Limit1
    Offset(2775),   CD11, 8,  // Offset(2775),  WrdsCdbWiFiSarTxPowerSet1Limit2
    Offset(2776),   CD12, 8,  // Offset(2776),  WrdsCdbWiFiSarTxPowerSet1Limit3
    Offset(2777),   CD13, 8,  // Offset(2777),  WrdsCdbWiFiSarTxPowerSet1Limit4
    Offset(2778),   CD14, 8,  // Offset(2778),  WrdsCdbWiFiSarTxPowerSet1Limit5
    Offset(2779),   CD15, 8,  // Offset(2779),  WrdsCdbWiFiSarTxPowerSet1Limit6
    Offset(2780),   CD16, 8,  // Offset(2780),  WrdsCdbWiFiSarTxPowerSet1Limit7
    Offset(2781),   CD17, 8,  // Offset(2781),  WrdsCdbWiFiSarTxPowerSet1Limit8
    Offset(2782),   CD18, 8,  // Offset(2782),  WrdsCdbWiFiSarTxPowerSet1Limit9
    Offset(2783),   CD19, 8,  // Offset(2783),  WrdsCdbWiFiSarTxPowerSet1Limit10
    Offset(2784),   CD1A, 8,  // Offset(2784),  WrdsCdbWiFiSarTxPowerSet1Limit11
    Offset(2785),   CD20, 8,  // Offset(2785),  WrdsCdbWiFiSarTxPowerSet1Limit12
    Offset(2786),   CD21, 8,  // Offset(2786),  WrdsCdbWiFiSarTxPowerSet1Limit13
    Offset(2787),   CD22, 8,  // Offset(2787),  WrdsCdbWiFiSarTxPowerSet1Limit14
    Offset(2788),   CD23, 8,  // Offset(2788),  WrdsCdbWiFiSarTxPowerSet1Limit15
    Offset(2789),   CD24, 8,  // Offset(2789),  WrdsCdbWiFiSarTxPowerSet1Limit16
    Offset(2790),   CD25, 8,  // Offset(2790),  WrdsCdbWiFiSarTxPowerSet1Limit17
    Offset(2791),   CD26, 8,  // Offset(2791),  WrdsCdbWiFiSarTxPowerSet1Limit18
    Offset(2792),   CD27, 8,  // Offset(2792),  WrdsCdbWiFiSarTxPowerSet1Limit19
    Offset(2793),   CD28, 8,  // Offset(2793),  WrdsCdbWiFiSarTxPowerSet1Limit20
    Offset(2794),   CD29, 8,  // Offset(2794),  WrdsCdbWiFiSarTxPowerSet1Limit21
    Offset(2795),   CD2A, 8,  // Offset(2795),  WrdsCdbWiFiSarTxPowerSet1Limit22
    Offset(2796),   CD30, 8,  // Offset(2796),  EwrdCdbWiFiSarTxPowerSet2Limit1
    Offset(2797),   CD31, 8,  // Offset(2797),  EwrdCdbWiFiSarTxPowerSet2Limit2
    Offset(2798),   CD32, 8,  // Offset(2798),  EwrdCdbWiFiSarTxPowerSet2Limit3
    Offset(2799),   CD33, 8,  // Offset(2799),  EwrdCdbWiFiSarTxPowerSet2Limit4
    Offset(2800),   CD34, 8,  // Offset(2800),  EwrdCdbWiFiSarTxPowerSet2Limit5
    Offset(2801),   CD35, 8,  // Offset(2801),  EwrdCdbWiFiSarTxPowerSet2Limit6
    Offset(2802),   CD36, 8,  // Offset(2802),  EwrdCdbWiFiSarTxPowerSet2Limit7
    Offset(2803),   CD37, 8,  // Offset(2803),  EwrdCdbWiFiSarTxPowerSet2Limit8
    Offset(2804),   CD38, 8,  // Offset(2804),  EwrdCdbWiFiSarTxPowerSet2Limit9
    Offset(2805),   CD39, 8,  // Offset(2805),  EwrdCdbWiFiSarTxPowerSet2Limit10
    Offset(2806),   CD3A, 8,  // Offset(2806),  EwrdCdbWiFiSarTxPowerSet2Limit11
    Offset(2807),   CD3B, 8,  // Offset(2807),  EwrdCdbWiFiSarTxPowerSet2Limit12
    Offset(2808),   CD3C, 8,  // Offset(2808),  EwrdCdbWiFiSarTxPowerSet2Limit13
    Offset(2809),   CD3D, 8,  // Offset(2809),  EwrdCdbWiFiSarTxPowerSet2Limit14
    Offset(2810),   CD3E, 8,  // Offset(2810),  EwrdCdbWiFiSarTxPowerSet2Limit15
    Offset(2811),   CD3F, 8,  // Offset(2811),  EwrdCdbWiFiSarTxPowerSet2Limit16
    Offset(2812),   CD40, 8,  // Offset(2812),  EwrdCdbWiFiSarTxPowerSet2Limit17
    Offset(2813),   CD41, 8,  // Offset(2813),  EwrdCdbWiFiSarTxPowerSet2Limit18
    Offset(2814),   CD42, 8,  // Offset(2814),  EwrdCdbWiFiSarTxPowerSet2Limit19
    Offset(2815),   CD43, 8,  // Offset(2815),  EwrdCdbWiFiSarTxPowerSet2Limit20
    Offset(2816),   CD44, 8,  // Offset(2816),  EwrdCdbWiFiSarTxPowerSet2Limit21
    Offset(2817),   CD45, 8,  // Offset(2817),  EwrdCdbWiFiSarTxPowerSet2Limit22
    Offset(2818),   CD46, 8,  // Offset(2818),  EwrdCdbWiFiSarTxPowerSet3Limit1
    Offset(2819),   CD47, 8,  // Offset(2819),  EwrdCdbWiFiSarTxPowerSet3Limit2
    Offset(2820),   CD48, 8,  // Offset(2820),  EwrdCdbWiFiSarTxPowerSet3Limit3
    Offset(2821),   CD49, 8,  // Offset(2821),  EwrdCdbWiFiSarTxPowerSet3Limit4
    Offset(2822),   CD4A, 8,  // Offset(2822),  EwrdCdbWiFiSarTxPowerSet3Limit5
    Offset(2823),   CD4B, 8,  // Offset(2823),  EwrdCdbWiFiSarTxPowerSet3Limit6
    Offset(2824),   CD4C, 8,  // Offset(2824),  EwrdCdbWiFiSarTxPowerSet3Limit7
    Offset(2825),   CD4D, 8,  // Offset(2825),  EwrdCdbWiFiSarTxPowerSet3Limit8
    Offset(2826),   CD4E, 8,  // Offset(2826),  EwrdCdbWiFiSarTxPowerSet3Limit9
    Offset(2827),   CD4F, 8,  // Offset(2827),  EwrdCdbWiFiSarTxPowerSet3Limit10
    Offset(2828),   CD50, 8,  // Offset(2828),  EwrdCdbWiFiSarTxPowerSet3Limit11
    Offset(2829),   CD51, 8,  // Offset(2829),  EwrdCdbWiFiSarTxPowerSet3Limit12
    Offset(2830),   CD52, 8,  // Offset(2830),  EwrdCdbWiFiSarTxPowerSet3Limit13
    Offset(2831),   CD53, 8,  // Offset(2831),  EwrdCdbWiFiSarTxPowerSet3Limit14
    Offset(2832),   CD54, 8,  // Offset(2832),  EwrdCdbWiFiSarTxPowerSet3Limit15
    Offset(2833),   CD55, 8,  // Offset(2833),  EwrdCdbWiFiSarTxPowerSet3Limit16
    Offset(2834),   CD56, 8,  // Offset(2834),  EwrdCdbWiFiSarTxPowerSet3Limit17
    Offset(2835),   CD57, 8,  // Offset(2835),  EwrdCdbWiFiSarTxPowerSet3Limit18
    Offset(2836),   CD58, 8,  // Offset(2836),  EwrdCdbWiFiSarTxPowerSet3Limit19
    Offset(2837),   CD59, 8,  // Offset(2837),  EwrdCdbWiFiSarTxPowerSet3Limit20
    Offset(2838),   CD5A, 8,  // Offset(2838),  EwrdCdbWiFiSarTxPowerSet3Limit21
    Offset(2839),   CD5B, 8,  // Offset(2839),  EwrdCdbWiFiSarTxPowerSet3Limit22
    Offset(2840),   CD5C, 8,  // Offset(2840),  EwrdCdbWiFiSarTxPowerSet4Limit1
    Offset(2841),   CD5D, 8,  // Offset(2841),  EwrdCdbWiFiSarTxPowerSet4Limit2
    Offset(2842),   CD5E, 8,  // Offset(2842),  EwrdCdbWiFiSarTxPowerSet4Limit3
    Offset(2843),   CD5F, 8,  // Offset(2843),  EwrdCdbWiFiSarTxPowerSet4Limit4
    Offset(2844),   CD60, 8,  // Offset(2844),  EwrdCdbWiFiSarTxPowerSet4Limit5
    Offset(2845),   CD61, 8,  // Offset(2845),  EwrdCdbWiFiSarTxPowerSet4Limit6
    Offset(2846),   CD62, 8,  // Offset(2846),  EwrdCdbWiFiSarTxPowerSet4Limit7
    Offset(2847),   CD63, 8,  // Offset(2847),  EwrdCdbWiFiSarTxPowerSet4Limit8
    Offset(2848),   CD64, 8,  // Offset(2848),  EwrdCdbWiFiSarTxPowerSet4Limit9
    Offset(2849),   CD65, 8,  // Offset(2849),  EwrdCdbWiFiSarTxPowerSet4Limit10
    Offset(2850),   CD66, 8,  // Offset(2850),  EwrdCdbWiFiSarTxPowerSet4Limit11
    Offset(2851),   CD67, 8,  // Offset(2851),  EwrdCdbWiFiSarTxPowerSet4Limit12
    Offset(2852),   CD68, 8,  // Offset(2852),  EwrdCdbWiFiSarTxPowerSet4Limit13
    Offset(2853),   CD69, 8,  // Offset(2853),  EwrdCdbWiFiSarTxPowerSet4Limit14
    Offset(2854),   CD6A, 8,  // Offset(2854),  EwrdCdbWiFiSarTxPowerSet4Limit15
    Offset(2855),   CD6B, 8,  // Offset(2855),  EwrdCdbWiFiSarTxPowerSet4Limit16
    Offset(2856),   CD6C, 8,  // Offset(2856),  EwrdCdbWiFiSarTxPowerSet4Limit17
    Offset(2857),   CD6D, 8,  // Offset(2857),  EwrdCdbWiFiSarTxPowerSet4Limit18
    Offset(2858),   CD6E, 8,  // Offset(2858),  EwrdCdbWiFiSarTxPowerSet4Limit19
    Offset(2859),   CD6F, 8,  // Offset(2859),  EwrdCdbWiFiSarTxPowerSet4Limit20
    Offset(2860),   CD70, 8,  // Offset(2860),  EwrdCdbWiFiSarTxPowerSet4Limit21
    Offset(2861),   CD71, 8,  // Offset(2861),  EwrdCdbWiFiSarTxPowerSet4Limit22
    Offset(2862),             // Offset(2862) : Offset(2861), Reserved bytes
    Offset(2862),   WPFA, 32, // Offset(2862),  Platform PHY Config Chain A  Deprecated
    Offset(2866),   WPFB, 32, // Offset(2866),  Platform PHY Config Chain B  Deprecated
    Offset(2870),   WPFC, 32, // Offset(2870),  Platform PHY Config Chain C  Deprecated
    Offset(2874),   WPFD, 32, // Offset(2874),  Platform PHY Config Chain D  Deprecated
    Offset(2878),   L0LC, 8,  // Offset(2878),  LanesClockDivision
    Offset(2879),   L1LC, 8,  // Offset(2879),  LanesClockDivision
    Offset(2880),   L2LC, 8,  // Offset(2880),  LanesClockDivision
    Offset(2881),   L3LC, 8,  // Offset(2881),  LanesClockDivision
    Offset(2882),   L4LC, 8,  // Offset(2882),  LanesClockDivision
    Offset(2883),   L5LC, 8,  // Offset(2883),  LanesClockDivision
    Offset(2884),   POVP, 32, // Offset(2884),  USBC_PSON_OVERRIDE_N Input pin
    Offset(2888),   PSG1, 32, // Offset(2888),  S0IX_EN_TRY_REQ Output pin
    Offset(2892),   PSG2, 32, // Offset(2892),  S0IX_EN_TRY_ACK Input pin
    Offset(2896),   PPOE, 32, // Offset(2896),  Option to enable/disable TCSS PD PS_ON
    Offset(2900),   FND2, 8,  // Offset(2900),  EnableFan2Device
    Offset(2901),   FND3, 8,  // Offset(2901),  EnableFan3Device
    Offset(2902),   S6DE, 8,  // Offset(2902),  EnableDgpuParticipant
    Offset(2903),   WTSE, 8,  // Offset(2903),  WifiTASSelection
    Offset(2904),   WTLE, 8,  // Offset(2904),  WifiTASListEntries
    Offset(2905),   BL01, 16, // Offset(2905),  WTASBlockedListEntry1
    Offset(2907),   BL02, 16, // Offset(2907),  WTASBlockedListEntry2
    Offset(2909),   BL03, 16, // Offset(2909),  WTASBlockedListEntry3
    Offset(2911),   BL04, 16, // Offset(2911),  WTASBlockedListEntry4
    Offset(2913),   BL05, 16, // Offset(2913),  WTASBlockedListEntry5
    Offset(2915),   BL06, 16, // Offset(2915),  WTASBlockedListEntry6
    Offset(2917),   BL07, 16, // Offset(2917),  WTASBlockedListEntry7
    Offset(2919),   BL08, 16, // Offset(2919),  WTASBlockedListEntry8
    Offset(2921),   BL09, 16, // Offset(2921),  WTASBlockedListEntry9
    Offset(2923),   BL10, 16, // Offset(2923),  WTASBlockedListEntry10
    Offset(2925),   BL11, 16, // Offset(2925),  WTASBlockedListEntry11
    Offset(2927),   BL12, 16, // Offset(2927),  WTASBlockedListEntry12
    Offset(2929),   BL13, 16, // Offset(2929),  WTASBlockedListEntry13
    Offset(2931),   BL14, 16, // Offset(2931),  WTASBlockedListEntry14
    Offset(2933),   BL15, 16, // Offset(2933),  WTASBlockedListEntry15
    Offset(2935),   BL16, 16, // Offset(2935),  WTASBlockedListEntry16
    Offset(2937),   CVFS, 8,  // Offset(2937),  To enable/disable Cloverfalls(CVF)
    Offset(2938),   CUPN, 8,  // Offset(2938),  CVF USB port number
    Offset(2939),   DGBA, 64, // Offset(2939),  DG PCIe Base Address
    Offset(2947),   DGOP, 32, // Offset(2947),  DG OpRegion Base Address
    Offset(2951),   TILE, 8,  // Offset(2951),  BT Tile Mode
    Offset(2952),   TIS0, 8,  // Offset(2952),  The activity of Tile in S0
    Offset(2953),   TS0X, 8,  // Offset(2953),  The activity of Tile in S0ix
    Offset(2954),   TIS4, 8,  // Offset(2954),  The activity of Tile in S4
    Offset(2955),   TIS5, 8,  // Offset(2955),  The activity of Tile in S5
    Offset(2956),   SLEC, 8,  // Offset(2956),  Special LED Config
    Offset(2957),   LEDU, 16, // Offset(2957),  LED Duration
    Offset(2959),   TAPM, 8,  // Offset(2959),  Tile Airplane Mode
    Offset(2960),   STD3, 8,  // Offset(2960),  Storage Runtime D3 Support
    Offset(2961),   PXDC, 8,  // Offset(2961),  PMAX Device
    Offset(2962),   PXAC, 8,  // Offset(2962),  PMAX Audio Codec
    Offset(2963),   PXWC, 8,  // Offset(2963),  PMAX WF Camera
    Offset(2964),   PXUC, 8,  // Offset(2964),  PMAX UF Camera
    Offset(2965),   PXFD, 8,  // Offset(2965),  PMAX Flash Device
    Offset(2966),       , 8,  // Offset(2966),  Reserved to remove Board Rework Option for ADLP/M
    Offset(2967),   WWEN, 8,  // Offset(2967),  WWAN Enable
    Offset(2968),   WFFD, 8,  // Offset(2968),  Enable WWAN Firmware Flash Device
    Offset(2969),   TN2B, 16, // Offset(2969),  FCPO# to BBRST# delay time during WWAN ON
    Offset(2971),   TB2R, 16, // Offset(2971),  BBRST# to PERST# delay time during WWAN ON
    Offset(2973),   TR2P, 16, // Offset(2973),  The delay between de-assertion of PERST# to change of PDS state from 0 to 1 during WWAN ON
    Offset(2975),   TB2F, 16, // Offset(2975),  BBRST# to FCPO# delay time during WWAN OFF
    Offset(2977),   TFDI, 16, // Offset(2977),  Rigorous shutdown time
    Offset(2979),   TBTG, 16, // Offset(2979),  The delay between assertion and de-assertion BBRST# during FLDR
    Offset(2981),   TBTP, 16, // Offset(2981),  The delay between de-assertion of BBRST# and change of PDS state from 0 to 1 after FLDR
    Offset(2983),   LSWP, 32, // Offset(2983),  Lid Switch Wake Gpio
    Offset(2987),   U4CM, 8,  // Offset(2987),  USB4 CM mode information in Pre-Boot
    Offset(2988),   CMSK, 8,  // Offset(2988),  Indicate enabled dTBT and iTBT for CM
    Offset(2989),   LP5E, 8,  // Offset(2989),  Closed Lid WoV LED Lighting Support Enable
    Offset(2990),   CLCN, 8,  // Offset(2990),  Closed Lid WoV LED Lighting I2C Controller Number
    Offset(2991),   CLSA, 8,  // Offset(2991),  Closed Lid WoV LED Lighting I2C Peripheral address
    // Type-C NVS variables for TCSS Port 7-10
    Offset(2992),   TP7T, 8,  // Offset(2992),  Type C Connector 7  Port mapping within the controller the port exposed
    Offset(2993),   TP7P, 8,  // Offset(2993),  Type C Connector 7  Port mapping within the PCH controller (If Split mode supported)
    Offset(2994),   TP7D, 8,  // Offset(2994),  Type C Connector 7  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2995),   TP8T, 8,  // Offset(2995),  Type C Connector 8  Port mapping within the controller the port exposed
    Offset(2996),   TP8P, 8,  // Offset(2996),  Type C Connector 8  Port mapping within the PCH controller (If Split mode supported)
    Offset(2997),   TP8D, 8,  // Offset(2997),  Type C Connector 8  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(2998),   TP9T, 8,  // Offset(2998),  Type C Connector 9  Port mapping within the controller the port exposed
    Offset(2999),   TP9P, 8,  // Offset(2999),  Type C Connector 9  Port mapping within the PCH controller (If Split mode supported)
    Offset(3000),   TP9D, 8,  // Offset(3000),  Type C Connector 9  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    Offset(3001),   TPAT, 8,  // Offset(3001),  Type C Connector A  Port mapping within the controller the port exposed
    Offset(3002),   TPAP, 8,  // Offset(3002),  Type C Connector A  Port mapping within the PCH controller (If Split mode supported)
    Offset(3003),   TPAD, 8,  // Offset(3003),  Type C Connector A  Portperties Split Support/Controller(PCH/TBT/CPU)/Root port (vaild for TBT)
    // UCSI/UCMX Driver Support. 0: Force Disable, 1: UCSI Driver support, 2: UCMX Driver support.
    Offset(3004),   TP1U, 8,  // Offset(3004),  Type C Connector 1  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3005),   TP2U, 8,  // Offset(3005),  Type C Connector 2  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3006),   TP3U, 8,  // Offset(3006),  Type C Connector 3  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3007),   TP4U, 8,  // Offset(3007),  Type C Connector 4  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3008),   TP5U, 8,  // Offset(3008),  Type C Connector 5  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3009),   TP6U, 8,  // Offset(3009),  Type C Connector 6  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3010),   TP7U, 8,  // Offset(3010),  Type C Connector 7  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3011),   TP8U, 8,  // Offset(3011),  Type C Connector 8  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3012),   TP9U, 8,  // Offset(3012),  Type C Connector 9  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3013),   TPAU, 8,  // Offset(3013),  Type C Connector A  UCSI/UCMX Driver Support Enable/ Force Disable.
    Offset(3014),   FVWP, 32, // Offset(3014),  Foxville I225 Wake Gpio pin
    Offset(3018),   FVRE, 32, // Offset(3018),  Foxville I225 Reset Gpio pin
    Offset(3022),   FVRP, 8,  // Offset(3022),  Foxville I225 Reset Gpio pin polarity
    Offset(3023),   FVPE, 32, // Offset(3023),  Foxville I225 Disable N Gpio pin
    Offset(3027),   FVPP, 8,  // Offset(3027),  Foxville I225 Disable N Gpio pin polarity
    Offset(3028),   FVSP, 8,  // Offset(3028),  Foxville I225 support configuration
    Offset(3029),   RPFV, 8,  // Offset(3029),  Foxville I225 PCIe Root Port Number
    Offset(3030),   DPIW, 8,  // Offset(3030),  DPin Dynamic Switch
    Offset(3031),   DPG1, 32, // Offset(3031),  PcdDpMuxGpio
    //
    // Data Role Swap:
    //
    Offset(3035),   UDRS, 8,  // Offset(3035),  Usbc Data Role Swap
    Offset(3036),   U4SE, 8,  // Offset(3036),  USB4 CM mode switch is enabled/disabled
    //Flash ID support for discrete flash solution
    Offset(3037),   L0FI, 8,  // Offset(3037),  Flash ID for Link0
    Offset(3038),   L1FI, 8,  // Offset(3038),  Flash ID for Link1
    Offset(3039),   L2FI, 8,  // Offset(3039),  Flash ID for Link2
    Offset(3040),   L3FI, 8,  // Offset(3040),  Flash ID for Link3
    Offset(3041),   L4FI, 8,  // Offset(3041),  Flash ID for Link4
    Offset(3042),   L5FI, 8,  // Offset(3042),  Flash ID for Link5
    //I2C6 Support
    Offset(3043),   SSH6, 16, // Offset(3043),  SSCN-HIGH for I2C6
    Offset(3045),   SSL6, 16, // Offset(3045),  SSCN-LOW  for I2C6
    Offset(3047),   SSD6, 16, // Offset(3047),  SSCN-HOLD for I2C6
    Offset(3049),   FMH6, 16, // Offset(3049),  FMCN-HIGH for I2C6
    Offset(3051),   FML6, 16, // Offset(3051),  FMCN-LOW  for I2C6
    Offset(3053),   FMD6, 16, // Offset(3053),  FMCN-HOLD for I2C6
    Offset(3055),   FPH6, 16, // Offset(3055),  FPCN-HIGH for I2C6
    Offset(3057),   FPL6, 16, // Offset(3057),  FPCN-LOW  for I2C6
    Offset(3059),   FPD6, 16, // Offset(3059),  FPCN-HOLD for I2C6
    Offset(3061),   HSH6, 16, // Offset(3061),  HSCN-HIGH for I2C6
    Offset(3063),   HSL6, 16, // Offset(3063),  HSCN-LOW  for I2C6
    Offset(3065),   HSD6, 16, // Offset(3065),  HSCN-HOLD for I2C6
    Offset(3067),   M0CC, 16, // Offset(3067),  M0D3 for I2C6
    Offset(3069),   M1CC, 16, // Offset(3069),  M1D3 for I2C6
    //I2C7 Support
    Offset(3071),   SSH7, 16, // Offset(3071),  SSCN-HIGH for I2C7
    Offset(3073),   SSL7, 16, // Offset(3073),  SSCN-LOW  for I2C7
    Offset(3075),   SSD7, 16, // Offset(3075),  SSCN-HOLD for I2C7
    Offset(3077),   FMH7, 16, // Offset(3077),  FMCN-HIGH for I2C7
    Offset(3079),   FML7, 16, // Offset(3079),  FMCN-LOW  for I2C7
    Offset(3081),   FMD7, 16, // Offset(3081),  FMCN-HOLD for I2C7
    Offset(3083),   FPH7, 16, // Offset(3083),  FPCN-HIGH for I2C7
    Offset(3085),   FPL7, 16, // Offset(3085),  FPCN-LOW  for I2C7
    Offset(3087),   FPD7, 16, // Offset(3087),  FPCN-HOLD for I2C7
    Offset(3089),   HSH7, 16, // Offset(3089),  HSCN-HIGH for I2C7
    Offset(3091),   HSL7, 16, // Offset(3091),  HSCN-LOW  for I2C7
    Offset(3093),   HSD7, 16, // Offset(3093),  HSCN-HOLD for I2C7
    Offset(3095),   M0CD, 16, // Offset(3095),  M0D3 for I2C7
    Offset(3097),   M1CD, 16, // Offset(3097),  M1D3 for I2C7
    Offset(3099),   TR2B, 16, // Offset(3099),  PERST# to BBRST# delay time during WWAN OFF
    //ZPODD support
    Offset(3101),   ZPDA, 32, // Offset(3101),  ZPODD device attention gpio
    Offset(3105),   ZDPR, 32, // Offset(3105),  ZPODD device present gpio
    Offset(3109),   ZDPW, 32, // Offset(3109),  ZPODD device power gpio
    Offset(3113),   ZDPP, 8,  // Offset(3113),  ZPODD device power gpio polarity
    Offset(3114),   WSID, 16, // Offset(3114),  WWAN OEM SVID
    Offset(3116),   WSTO, 16, // Offset(3116),  WWAN SVID Timeout
    Offset(3118),   HUAR, 8,  // Offset(3118),  H8S2113 UAR
    Offset(3119),   BLEC, 8,  // Offset(3119),  BT LED Config
    Offset(3120),   BLPD, 8,  // Offset(3120),  BT LED Pulse Duration
    Offset(3121),   BLPI, 8,  // Offset(3121),  BT LED Pulse Interval
    Offset(3122),   WFRC, 32, // Offset(3122),  WiFi Regulatory Configurations
    Offset(3126),   WFUC, 32, // Offset(3126),  WiFi UART Configurations
    Offset(3130),   UNI4, 32, // Offset(3130),  WiFi UNII-4
    Offset(3134),   WFIC, 32, // Offset(3134),  WiFi Indoor Control
    Offset(3138),   ATSC, 8,  // Offset(3138),  Flag to indicate if TSC is linked to ART
    Offset(3139),   R8DC, 8,  // Offset(3139),  RootPort 08 D3 Cold Disable
    // Onboard MR support (for ADL S8 only)
    Offset(3140),   OMP1, 32, // Offset(3140),  Onboard MR 1 Power Enable Gpio pin
    Offset(3144),   OM1P, 8,  // Offset(3144),  Onboard MR 1 Power Enable Gpio pin polarity
    Offset(3145),   OMR1, 32, // Offset(3145),  Onboard MR 1 Rest Gpio pin
    Offset(3149),   MR1P, 8,  // Offset(3149),  Onboard MR 1 Rest Gpio pin polarity
    Offset(3150),   OMW1, 32, // Offset(3150),  Onboard MR 1 Wake Gpio pin
    Offset(3154),   RPO1, 8,  // Offset(3154),  Onboard MR 1 Root Port Number
    // Onboard MR support
    Offset(3155),   OMP2, 32, // Offset(3155),  Onboard MR 2 Power Enable Gpio pin
    Offset(3159),   OM2P, 8,  // Offset(3159),  Onboard MR 2 Power Enable Gpio pin polarity
    Offset(3160),   OMR2, 32, // Offset(3160),  Onboard MR 2 Rest Gpio pin
    Offset(3164),   MR2P, 8,  // Offset(3164),  Onboard MR 2 Rest Gpio pin polarity
    Offset(3165),   OMW2, 32, // Offset(3165),  Onboard MR 2 Wake Gpio pin
    Offset(3169),   RPO2, 8,  // Offset(3169),  Onboard MR 2 Root Port Number
    Offset(3170),   WCEN, 8,  // Offset(3170),  WCCD Enable
    Offset(3171),   R8DS, 8,  // Offset(3171),  RP08 D3Cold Support
    Offset(3172),   WLBI, 8,  // Offset(3172),  WLAN/WWAN Low Band Isolation
    Offset(3173),   WHBI, 8,  // Offset(3173),  WLAN/WWAN High Band Isolation
    Offset(3174),   SDGN, 8,  // Offset(3174),  WgdsWiFiSarDeltaGroupNumber
    Offset(3175),   SD41, 8,  // Offset(3175),  WgdsWiFiSarDeltaGroup4PowerMax1
    Offset(3176),   SD42, 8,  // Offset(3176),  WgdsWiFiSarDeltaGroup4PowerChainA1
    Offset(3177),   SD43, 8,  // Offset(3177),  WgdsWiFiSarDeltaGroup4PowerChainB1
    Offset(3178),   SD44, 8,  // Offset(3178),  WgdsWiFiSarDeltaGroup4PowerMax2
    Offset(3179),   SD45, 8,  // Offset(3179),  WgdsWiFiSarDeltaGroup4PowerChainA2
    Offset(3180),   SD46, 8,  // Offset(3180),  WgdsWiFiSarDeltaGroup4PowerChainB2
    Offset(3181),   SD47, 8,  // Offset(3181),  WgdsWiFiSarDeltaGroup4PowerMax3
    Offset(3182),   SD48, 8,  // Offset(3182),  WgdsWiFiSarDeltaGroup4PowerChainA3
    Offset(3183),   SD49, 8,  // Offset(3183),  WgdsWiFiSarDeltaGroup4PowerChainB3
    Offset(3184),   SD51, 8,  // Offset(3184),  WgdsWiFiSarDeltaGroup5PowerMax1
    Offset(3185),   SD52, 8,  // Offset(3185),  WgdsWiFiSarDeltaGroup5PowerChainA1
    Offset(3186),   SD53, 8,  // Offset(3186),  WgdsWiFiSarDeltaGroup5PowerChainB1
    Offset(3187),   SD54, 8,  // Offset(3187),  WgdsWiFiSarDeltaGroup5PowerMax2
    Offset(3188),   SD55, 8,  // Offset(3188),  WgdsWiFiSarDeltaGroup5PowerChainA2
    Offset(3189),   SD56, 8,  // Offset(3189),  WgdsWiFiSarDeltaGroup5PowerChainB2
    Offset(3190),   SD57, 8,  // Offset(3190),  WgdsWiFiSarDeltaGroup5PowerMax3
    Offset(3191),   SD58, 8,  // Offset(3191),  WgdsWiFiSarDeltaGroup5PowerChainA3
    Offset(3192),   SD59, 8,  // Offset(3192),  WgdsWiFiSarDeltaGroup5PowerChainB3
    Offset(3193),   SD61, 8,  // Offset(3193),  WgdsWiFiSarDeltaGroup6PowerMax1
    Offset(3194),   SD62, 8,  // Offset(3194),  WgdsWiFiSarDeltaGroup6PowerChainA1
    Offset(3195),   SD63, 8,  // Offset(3195),  WgdsWiFiSarDeltaGroup6PowerChainB1
    Offset(3196),   SD64, 8,  // Offset(3196),  WgdsWiFiSarDeltaGroup6PowerMax2
    Offset(3197),   SD65, 8,  // Offset(3197),  WgdsWiFiSarDeltaGroup6PowerChainA2
    Offset(3198),   SD66, 8,  // Offset(3198),  WgdsWiFiSarDeltaGroup6PowerChainB2
    Offset(3199),   SD67, 8,  // Offset(3199),  WgdsWiFiSarDeltaGroup6PowerMax3
    Offset(3200),   SD68, 8,  // Offset(3200),  WgdsWiFiSarDeltaGroup6PowerChainA3
    Offset(3201),   SD69, 8,  // Offset(3201),  WgdsWiFiSarDeltaGroup6PowerChainB3
    Offset(3202),   SD71, 8,  // Offset(3202),  WgdsWiFiSarDeltaGroup7PowerMax1
    Offset(3203),   SD72, 8,  // Offset(3203),  WgdsWiFiSarDeltaGroup7PowerChainA1
    Offset(3204),   SD73, 8,  // Offset(3204),  WgdsWiFiSarDeltaGroup7PowerChainB1
    Offset(3205),   SD74, 8,  // Offset(3205),  WgdsWiFiSarDeltaGroup7PowerMax2
    Offset(3206),   SD75, 8,  // Offset(3206),  WgdsWiFiSarDeltaGroup7PowerChainA2
    Offset(3207),   SD76, 8,  // Offset(3207),  WgdsWiFiSarDeltaGroup7PowerChainB2
    Offset(3208),   SD77, 8,  // Offset(3208),  WgdsWiFiSarDeltaGroup7PowerMax3
    Offset(3209),   SD78, 8,  // Offset(3209),  WgdsWiFiSarDeltaGroup7PowerChainA3
    Offset(3210),   SD79, 8,  // Offset(3210),  WgdsWiFiSarDeltaGroup7PowerChainB3
    Offset(3211),   SD81, 8,  // Offset(3211),  WgdsWiFiSarDeltaGroup8PowerMax1
    Offset(3212),   SD82, 8,  // Offset(3212),  WgdsWiFiSarDeltaGroup8PowerChainA1
    Offset(3213),   SD83, 8,  // Offset(3213),  WgdsWiFiSarDeltaGroup8PowerChainB1
    Offset(3214),   SD84, 8,  // Offset(3214),  WgdsWiFiSarDeltaGroup8PowerMax2
    Offset(3215),   SD85, 8,  // Offset(3215),  WgdsWiFiSarDeltaGroup8PowerChainA2
    Offset(3216),   SD86, 8,  // Offset(3216),  WgdsWiFiSarDeltaGroup8PowerChainB2
    Offset(3217),   SD87, 8,  // Offset(3217),  WgdsWiFiSarDeltaGroup8PowerMax3
    Offset(3218),   SD88, 8,  // Offset(3218),  WgdsWiFiSarDeltaGroup8PowerChainA3
    Offset(3219),   SD89, 8,  // Offset(3219),  WgdsWiFiSarDeltaGroup8PowerChainB3
    Offset(3220),   R8WR, 8,  // Offset(3220),  Rp08WakeRework support
    Offset(3221),   WTSV, 32, // Offset(3221),  WifiTASSelectionValue
    Offset(3225),   EDMX, 32, // Offset(3225),  Display Mux GPIO pin
    Offset(3229),   DBRL, 8,  // Offset(3229),  DG eDP Brightness Level Percentage
    Offset(3230),   DNID, 8,  // Offset(3230),  DG Number of Valid Device IDs
    Offset(3231),   DGD1, 32, // Offset(3231),  DG Device ID 1
    Offset(3235),   DGD2, 32, // Offset(3235),  DG Device ID 2
    Offset(3239),   DGD3, 32, // Offset(3239),  DG Device ID 3
    Offset(3243),   DGD4, 32, // Offset(3243),  DG Device ID 4
    Offset(3247),   DGD5, 32, // Offset(3247),  DG Device ID 5
    Offset(3251),   DGD6, 32, // Offset(3251),  DG Device ID 6
    Offset(3255),   DGD7, 32, // Offset(3255),  DG Device ID 7
    Offset(3259),   DGD8, 32, // Offset(3259),  DG Device ID 8
    Offset(3263),   DGD9, 32, // Offset(3263),  DG Device ID 9
    Offset(3267),   DGDA, 32, // Offset(3267),  DG Device ID 10
    Offset(3271),   DGDB, 32, // Offset(3271),  DG Device ID 11
    Offset(3275),   DGDC, 32, // Offset(3275),  DG Device ID 12
    Offset(3279),   DGDD, 32, // Offset(3279),  DG Device ID 13
    Offset(3283),   DGDE, 32, // Offset(3283),  DG Device ID 14
    Offset(3287),   DGDF, 32, // Offset(3287),  DG Device ID 15
    Offset(3291),   DGDX, 32, // Offset(3291),  DG Device ID for eDP device
    Offset(3295),   DGDS, 8,  // Offset(3295),  _DOS DG Display Support Flag.
    Offset(3296),   VTCM, 8,  // Offset(3296),  Secure biometric VTIO over USB camera
    Offset(3297),   L0PV, 8,  // Offset(3297),  PPR Value
    Offset(3298),   L0PU, 8,  // Offset(3298),  PPR Unit
    Offset(3299),   L1PV, 8,  // Offset(3299),  PPR Value
    Offset(3300),   L1PU, 8,  // Offset(3300),  PPR Unit
    Offset(3301),   L2PV, 8,  // Offset(3301),  PPR Value
    Offset(3302),   L2PU, 8,  // Offset(3302),  PPR Unit
    Offset(3303),   L3PU, 8,  // Offset(3303),  PPR Unit
    Offset(3304),   L3PV, 8,  // Offset(3304),  PPR Value
    Offset(3305),   L4PU, 8,  // Offset(3305),  PPR Unit
    Offset(3306),   L4PV, 8,  // Offset(3306),  PPR Value
    Offset(3307),   L5PU, 8,  // Offset(3307),  PPR Unit
    Offset(3308),   L5PV, 8,  // Offset(3308),  PPR Value
    Offset(3309),   I2SE, 8,  // Offset(3309),  HD Audio I2S Enable
    Offset(3310),   ICS0, 32, // Offset(3310),  I2C0 Speed Mode Selection
    Offset(3314),   ICS1, 32, // Offset(3314),  I2C1 Speed Mode Selection
    Offset(3318),   ICS2, 32, // Offset(3318),  I2C2 Speed Mode Selection
    Offset(3322),   ICS3, 32, // Offset(3322),  I2C3 Speed Mode Selection
    Offset(3326),   ICS4, 32, // Offset(3326),  I2C4 Speed Mode Selection
    Offset(3330),   ICS5, 32, // Offset(3330),  I2C5 Speed Mode Selection
    Offset(3334),   FNAU, 8,  // Offset(3334),  Enabling Auto Mode for DTT
    }

  /** @file
  
    Copyright (c) 2021 - 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  External(TCIR) // TCSS xDCI Irq number
  
  Scope(\_SB) {
    Name(PD00, Package(){
  // WARNING: That setting should align with platform policy
  // D31
      Package(){0x001FFFFF, 0, 0, 11 },
      Package(){0x001FFFFF, 1, 0, 10 },
      Package(){0x001FFFFF, 2, 0, 11 },
      Package(){0x001FFFFF, 3, 0, 11 },
  // D29
      Package(){0x001DFFFF, 0, 0, 11 },
      Package(){0x001DFFFF, 1, 0, 10 },
      Package(){0x001DFFFF, 2, 0, 11 },
      Package(){0x001DFFFF, 3, 0, 11 },
  // D28
      Package(){0x001CFFFF, 0, 0, 11 },
      Package(){0x001CFFFF, 1, 0, 10 },
      Package(){0x001CFFFF, 2, 0, 11 },
      Package(){0x001CFFFF, 3, 0, 11 },
  // D27
      Package(){0x001BFFFF, 0, 0, 11 },
      Package(){0x001BFFFF, 1, 0, 10 },
      Package(){0x001BFFFF, 2, 0, 11 },
      Package(){0x001BFFFF, 3, 0, 11 },
  // D23
      Package(){0x0017FFFF, 0, 0, 11 },
  // D22
      Package(){0x0016FFFF, 0, 0, 11 },
      Package(){0x0016FFFF, 1, 0, 10 },
      Package(){0x0016FFFF, 2, 0, 11 },
      Package(){0x0016FFFF, 3, 0, 11 },
  // D20
      Package(){0x0014FFFF, 0, 0, 11 },
      Package(){0x0014FFFF, 1, 0, 10 },
      Package(){0x0014FFFF, 2, 0, 11 },
      Package(){0x0014FFFF, 3, 0, 11 },
  // Host Bridge
  // P.E.G. Root Port D6F0
      Package(){0x0006FFFF, 0, 0, 11 },
      Package(){0x0006FFFF, 1, 0, 10 },
      Package(){0x0006FFFF, 2, 0, 11 },
      Package(){0x0006FFFF, 3, 0, 11 },
  // P.E.G. Root Port D1F0
      Package(){0x0001FFFF, 0, 0, 11 },
      Package(){0x0001FFFF, 1, 0, 10 },
      Package(){0x0001FFFF, 2, 0, 11 },
      Package(){0x0001FFFF, 3, 0, 11 },
  // P.E.G. Root Port D1F1
  // P.E.G. Root Port D1F2
  // SA IGFX Device
      Package(){0x0002FFFF, 0, 0, 11 },
  // SA Thermal Device
      Package(){0x0004FFFF, 0, 0, 11 },
  // SA IPU Device
      Package(){0x0005FFFF, 0, 0, 11 },
  // SA GNA Device
      Package(){0x0008FFFF, 0, 0, 11 },
  // SA XHCI XDCI Device
      Package(){0x000DFFFF, 0, 0, 11 },
  // ITBT PCIE Root Port
      Package(){0x0007FFFF, 0, 0, 11 },
      Package(){0x0007FFFF, 1, 0, 10 },
      Package(){0x0007FFFF, 2, 0, 11 },
      Package(){0x0007FFFF, 3, 0, 11 },
    })
    Name(AR00, Package(){
  // PCI Bridge
  // D31
      Package(){0x001FFFFF, 0, 0, 16 },
      Package(){0x001FFFFF, 1, 0, 17 },
      Package(){0x001FFFFF, 2, 0, 18 },
      Package(){0x001FFFFF, 3, 0, 19 },
  // D30
      Package(){0x001EFFFF, 0, 0, 16 },
      Package(){0x001EFFFF, 1, 0, 17 },
      Package(){0x001EFFFF, 2, 0, 36 },
      Package(){0x001EFFFF, 3, 0, 37 },
  // D29
      Package(){0x001DFFFF, 0, 0, 16 },
      Package(){0x001DFFFF, 1, 0, 17 },
      Package(){0x001DFFFF, 2, 0, 18 },
      Package(){0x001DFFFF, 3, 0, 19 },
  // D28
      Package(){0x001CFFFF, 0, 0, 16 },
      Package(){0x001CFFFF, 1, 0, 17 },
      Package(){0x001CFFFF, 2, 0, 18 },
      Package(){0x001CFFFF, 3, 0, 19 },
  // D27
      Package(){0x001BFFFF, 0, 0, 16 },
      Package(){0x001BFFFF, 1, 0, 17 },
      Package(){0x001BFFFF, 2, 0, 18 },
      Package(){0x001BFFFF, 3, 0, 19 },
  // D26
      Package(){0x001AFFFF, 0, 0, 16 },
      Package(){0x001AFFFF, 1, 0, 17 },
      Package(){0x001AFFFF, 2, 0, 18 },
      Package(){0x001AFFFF, 3, 0, 19 },
  // D25
      Package(){0x0019FFFF, 0, 0, 31 },
      Package(){0x0019FFFF, 1, 0, 32 },
      Package(){0x0019FFFF, 2, 0, 42 },
  // D23
      Package(){0x0017FFFF, 0, 0, 16 },
  // D22
      Package(){0x0016FFFF, 0, 0, 16 },
      Package(){0x0016FFFF, 1, 0, 17 },
      Package(){0x0016FFFF, 2, 0, 18 },
      Package(){0x0016FFFF, 3, 0, 19 },
  // D21
  
      Package(){0x0015FFFF, 0, 0, 27 },
      Package(){0x0015FFFF, 1, 0, 40 },
      Package(){0x0015FFFF, 2, 0, 29 },
      Package(){0x0015FFFF, 3, 0, 33 },
  




#line 2604 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  // D20
      Package(){0x0014FFFF, 0, 0, 16 },
      Package(){0x0014FFFF, 1, 0, 17 },
      Package(){0x0014FFFF, 2, 0, 18 },
  //  Package(){0x0014FFFF, 3, 0, 19 }, not used
  // D19
      Package(){0x0013FFFF, 0, 0, 20 },
      Package(){0x0013FFFF, 1, 0, 21 },
      Package(){0x0013FFFF, 2, 0, 24 },
      Package(){0x0013FFFF, 3, 0, 38 },
  // D18
      Package(){0x0012FFFF, 0, 0, 26 },
      Package(){0x0012FFFF, 1, 0, 39 },
      Package(){0x0012FFFF, 2, 0, 18 },
  //  Package(){0x0012FFFF, 3, 0, 19 },
  // D17
      Package(){0x0011FFFF, 0, 0, 25 },
      Package(){0x0011FFFF, 1, 0, 35 },
      Package(){0x0011FFFF, 2, 0, 28 },
      Package(){0x0011FFFF, 3, 0, 34 },
  // D16
      Package(){0x0010FFFF, 2, 0, 18 },
      Package(){0x0010FFFF, 3, 0, 19 },
      Package(){0x0010FFFF, 0, 0, 23 },
      Package(){0x0010FFFF, 1, 0, 22 },
  // Host Bridge
  // P.E.G. Root Port D6F0
      Package(){0x0006FFFF, 0, 0, 16 },
      Package(){0x0006FFFF, 1, 0, 17 },
      Package(){0x0006FFFF, 2, 0, 18 },
      Package(){0x0006FFFF, 3, 0, 19 },
  // P.E.G. Root Port D1F0
      Package(){0x0001FFFF, 0, 0, 16 },
      Package(){0x0001FFFF, 1, 0, 17 },
      Package(){0x0001FFFF, 2, 0, 18 },
      Package(){0x0001FFFF, 3, 0, 19 },
  // P.E.G. Root Port D1F1
  // P.E.G. Root Port D1F2
  // SA IGFX Device
      Package(){0x0002FFFF, 0, 0, 16 },
  // SA Thermal Device
      Package(){0x0004FFFF, 0, 0, 16 },
  // SA IPU Device
      Package(){0x0005FFFF, 0, 0, 16 },
  // SA GNA Device
      Package(){0x0008FFFF, 0, 0, 16 },
  // SA XHCI XDCI Device
      Package(){0x000DFFFF, 0, 0, TCIR },
      Package(){0x000DFFFF, 1, 0, 17 },
  // ITBT PCIE Root Port
      Package(){0x0007FFFF, 0, 0, 16 },
      Package(){0x0007FFFF, 1, 0, 17 },
      Package(){0x0007FFFF, 2, 0, 18 },
      Package(){0x0007FFFF, 3, 0, 19 },
    })
    Name(PD04, Package(){
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 10 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR04, Package(){
      Package(){0x0000FFFF, 0, 0, 16 },
      Package(){0x0000FFFF, 1, 0, 17 },
      Package(){0x0000FFFF, 2, 0, 18 },
      Package(){0x0000FFFF, 3, 0, 19 },
    })
    Name(PD05, Package(){
      Package(){0x0000FFFF, 0, 0, 10 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR05, Package(){
      Package(){0x0000FFFF, 0, 0, 17 },
      Package(){0x0000FFFF, 1, 0, 18 },
      Package(){0x0000FFFF, 2, 0, 19 },
      Package(){0x0000FFFF, 3, 0, 16 },
    })
    Name(PD06, Package(){
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 10 },
    })
    Name(AR06, Package(){
      Package(){0x0000FFFF, 0, 0, 18 },
      Package(){0x0000FFFF, 1, 0, 19 },
      Package(){0x0000FFFF, 2, 0, 16 },
      Package(){0x0000FFFF, 3, 0, 17 },
    })
    Name(PD07, Package(){
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 10 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR07, Package(){
      Package(){0x0000FFFF, 0, 0, 19 },
      Package(){0x0000FFFF, 1, 0, 16 },
      Package(){0x0000FFFF, 2, 0, 17 },
      Package(){0x0000FFFF, 3, 0, 18 },
    })
    Name(PD08, Package(){
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 10 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR08, Package(){
      Package(){0x0000FFFF, 0, 0, 16 },
      Package(){0x0000FFFF, 1, 0, 17 },
      Package(){0x0000FFFF, 2, 0, 18 },
      Package(){0x0000FFFF, 3, 0, 19 },
    })
    Name(PD09, Package(){
      Package(){0x0000FFFF, 0, 0, 10 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR09, Package(){
      Package(){0x0000FFFF, 0, 0, 17 },
      Package(){0x0000FFFF, 1, 0, 18 },
      Package(){0x0000FFFF, 2, 0, 19 },
      Package(){0x0000FFFF, 3, 0, 16 },
    })
    Name(PD0E, Package(){
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 10 },
    })
    Name(AR0E, Package(){
      Package(){0x0000FFFF, 0, 0, 18 },
      Package(){0x0000FFFF, 1, 0, 19 },
      Package(){0x0000FFFF, 2, 0, 16 },
      Package(){0x0000FFFF, 3, 0, 17 },
    })
    Name(PD0F, Package(){
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 10 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR0F, Package(){
      Package(){0x0000FFFF, 0, 0, 19 },
      Package(){0x0000FFFF, 1, 0, 16 },
      Package(){0x0000FFFF, 2, 0, 17 },
      Package(){0x0000FFFF, 3, 0, 18 },
    })
    Name(PD02, Package(){
  // P.E.G. Port Slot x4
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 10 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR02, Package(){
  // P.E.G. Port Slot x4
      Package(){0x0000FFFF, 0, 0, 16 },
      Package(){0x0000FFFF, 1, 0, 17 },
      Package(){0x0000FFFF, 2, 0, 18 },
      Package(){0x0000FFFF, 3, 0, 19 },
    })
    Name(PD0A, Package(){
  // P.E.G. Port Slot x16
      Package(){0x0000FFFF, 0, 0, 10 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR0A, Package(){
  // P.E.G. Port Slot x16
      Package(){0x0000FFFF, 0, 0, 17 },
      Package(){0x0000FFFF, 1, 0, 18 },
      Package(){0x0000FFFF, 2, 0, 19 },
      Package(){0x0000FFFF, 3, 0, 16 },
    })
    Name(PD0B, Package(){
  // P.E.G. Port Slot x8
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 11 },
      Package(){0x0000FFFF, 3, 0, 10 },
    })
    Name(AR0B, Package(){
  // P.E.G. Port Slot x8
      Package(){0x0000FFFF, 0, 0, 18 },
      Package(){0x0000FFFF, 1, 0, 19 },
      Package(){0x0000FFFF, 2, 0, 16 },
      Package(){0x0000FFFF, 3, 0, 17 },
    })
    Name(PD0C, Package(){
  // P.E.G. Port Slot x4
      Package(){0x0000FFFF, 0, 0, 11 },
      Package(){0x0000FFFF, 1, 0, 11 },
      Package(){0x0000FFFF, 2, 0, 10 },
      Package(){0x0000FFFF, 3, 0, 11 },
    })
    Name(AR0C, Package(){
  // P.E.G. Port Slot x4
      Package(){0x0000FFFF, 0, 0, 19 },
      Package(){0x0000FFFF, 1, 0, 16 },
      Package(){0x0000FFFF, 2, 0, 17 },
      Package(){0x0000FFFF, 3, 0, 18 },
    })
  //---------------------------------------------------------------------------
  // Begin PCI tree object scope
  //---------------------------------------------------------------------------
    Device(PC00) { // PCI Bridge "Host Bridge"
      Name(_HID, EISAID("PNP0A08")) // Indicates PCI Express/PCI-X Mode2 host hierarchy
      Name(_CID, EISAID("PNP0A03")) // To support legacy OS that doesn't understand the new HID
      Name(_SEG, 0)
      Method(^BN00, 0){ return(0x0000) }  // Returns default Bus number for Peer PCI busses. Name can be overriden with control method placed directly under Device scope
      Method(_BBN, 0){ return(BN00()) } // Bus number, optional for the Root PCI Bus
      Name(_UID, 0x0000)  // Unique Bus ID, optional
      Method(_PRT,0) {
        If(PICM) {Return(AR00)} // APIC mode
        Return (PD00) // PIC Mode
      } // end _PRT
  
    /** @file
    
      Copyright (c) 2021 - 2022, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
    External(M64B)
    External(M64L)
    External(M32B)
    External(M32L)
    //External(MPGN)
    External(ITSP)
    External(SWAK, MethodObj)
    External (\_SB.PC00.PEG0.CPRA, MethodObj)
    External (\_SB.PC00.PEG1.CPRA, MethodObj)
    External (\_SB.PC00.PEG2.CPRA, MethodObj)
    External (\_SB.PC00.PEG3.CPRA, MethodObj)
    
    Device (MC)
    {
      Name(_ADR,0)
      //
      // Define various System Agent (SA) PCI Configuration Space
      // registers which will be used to dynamically produce all
      // resources in the Host Bus _CRS.
      //
      OperationRegion (HBUS, PCI_Config, 0x00, 0x100)
      Field (HBUS, DWordAcc, NoLock, Preserve)
      {
        Offset(0x40),   // EPBAR (0:0:0:40)
        EPEN, 1,        // Enable
            , 11,
        EPBR, 20,       // EPBAR [31:12]
    
        Offset(0x48),   // MCHBAR (0:0:0:48)
        MHEN, 1,        // Enable
            , 14,
        MHBR, 17,       // MCHBAR [31:15]
    
        Offset(0x50),   // GGC (0:0:0:50)
        GCLK, 1,        // GGCLCK
    
        Offset(0x54),   // DEVEN (0:0:0:54)
        D0EN, 1,        // DEV0 Enable
        D1F2, 1,        // DEV1 FUN2 Enable
        D1F1, 1,        // DEV1 FUN1 Enable
        D1F0, 1,        // DEV1 FUN0 Enable
            , 9,
        D6F0, 1,        // DEV6 FUN0 Enable
    
        Offset(0x60),   // PCIEXBAR (0:0:0:60)
        PXEN, 1,        // Enable
        PXSZ, 3,        // PCI Express Size
            , 22,
        PXBR, 6,        // PCI Express BAR [31:26]
    
        Offset(0x68),   // DMIBAR (0:0:0:68)
        DIEN, 1,        // Enable
            , 11,
        DIBR, 20,       // DMIBAR [31:12]
    
        Offset(0x70),   // MESEG_BASE (0:0:0:70)
            , 20,
        MEBR, 12,       // MESEG_BASE [31:20]
    
        Offset(0x80),   // PAM0 Register (0:0:0:80)
            , 4,
        PM0H, 2,        // PAM 0, High Nibble
            , 2,
    
        Offset(0x81),   // PAM1 Register (0:0:0:81)
        PM1L, 2,        // PAM1, Low  Nibble
            , 2,
        PM1H, 2,        // PAM1, High Nibble
            , 2,
    
        Offset(0x82),   // PAM2 Register (0:0:0:82)
        PM2L, 2,        // PAM2, Low  Nibble
            , 2,
        PM2H, 2,        // PAM2, High Nibble
            , 2,
    
        Offset(0x83),   // PAM3 Register (0:0:0:83)
        PM3L, 2,        // PAM3, Low  Nibble
            , 2,
        PM3H, 2,        // PAM3, High Nibble
            , 2,
    
        Offset(0x84),   // PAM4 Register (0:0:0:84)
        PM4L, 2,        // PAM4, Low  Nibble
            , 2,
        PM4H, 2,        // PAM4, High Nibble
            , 2,
    
        Offset(0x85),   // PAM5 Register (0:0:0:85)
        PM5L, 2,        // PAM5, Low  Nibble
            , 2,
        PM5H, 2,        // PAM5, High Nibble
            , 2,
    
        Offset(0x86),   // PAM6 Register (0:0:0:86)
        PM6L, 2,        // PAM6, Low  Nibble
            , 2,
        PM6H, 2,        // PAM6, High Nibble
            , 2,
    
        Offset(0xA8),   // Top of Upper Usable DRAM Register (0:0:0:A8)
            , 20,
        TUUD, 19,       // TOUUD [38:20]
    
        Offset(0xBC),   // Top of Lower Usable DRAM Register (0:0:0:BC)
            , 20,
        TLUD, 12,       // TOLUD [31:20]
    
        Offset(0xC8),   // ERRSTS register (0:0:0:C8)
            , 7,
        HTSE, 1         // Host Thermal Sensor Event for SMI/SCI/SERR
      }
    } // End MC
    //
    // Define a buffer that will store all the bus, memory, and IO information
    // relating to the Host Bus.  This buffer will be dynamically altered in
    // the _CRS and passed back to the OS.
    //
    Name(BUF0,ResourceTemplate()
    {
      //
      // Bus Number Allocation: Bus 0 to 0xFF
      //
      WORDBusNumber(ResourceProducer,MinFixed,MaxFixed,PosDecode,0x00,
        0x0000,0x00FF,0x00,0x0100,,,PB00)
    
      //
      // I/O Region Allocation 0 ( 0x0000 - 0x0CF7 )
      //
      DWordIo(ResourceProducer,MinFixed,MaxFixed,PosDecode,EntireRange,
        0x00,0x0000,0x0CF7,0x00,0x0CF8,,,PI00)
    
      //
      // PCI Configuration Registers ( 0x0CF8 - 0x0CFF )
      //
      Io(Decode16,0x0CF8,0x0CF8,1,0x08)
    
      //
      // I/O Region Allocation 1 ( 0x0D00 - 0xFFFF )
      //
      DWordIo(ResourceProducer,MinFixed,MaxFixed,PosDecode,EntireRange,
        0x00,0x0D00,0xFFFF,0x00,0xF300,,,PI01)
    
      //
      // Video Buffer Area ( 0xA0000 - 0xBFFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xA0000,0xBFFFF,0x00,0x20000,,,A000)
    
      //
      // ISA Add-on BIOS Area ( 0xC0000 - 0xC3FFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xC0000,0xC3FFF,0x00,0x4000,,,C000)
    
      //
      // ISA Add-on BIOS Area ( 0xC4000 - 0xC7FFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xC4000,0xC7FFF,0x00,0x4000,,,C400)
    
      //
      // ISA Add-on BIOS Area ( 0xC8000 - 0xCBFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xC8000,0xCBFFF,0x00,0x4000,,,C800)
    
      //
      // ISA Add-on BIOS Area ( 0xCC000 - 0xCFFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xCC000,0xCFFFF,0x00,0x4000,,,CC00)
    
      //
      // ISA Add-on BIOS Area ( 0xD0000 - 0xD3FFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xD0000,0xD3FFF,0x00,0x4000,,,D000)
    
      //
      // ISA Add-on BIOS Area ( 0xD4000 - 0xD7FFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xD4000,0xD7FFF,0x00,0x4000,,,D400)
    
      //
      // ISA Add-on BIOS Area ( 0xD8000 - 0xDBFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xD8000,0xDBFFF,0x00,0x4000,,,D800)
    
      //
      // ISA Add-on BIOS Area ( 0xDC000 - 0xDFFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xDC000,0xDFFFF,0x00,0x4000,,,DC00)
    
      //
      // BIOS Extension Area ( 0xE0000 - 0xE3FFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xE0000,0xE3FFF,0x00,0x4000,,,E000)
    
      //
      // BIOS Extension Area ( 0xE4000 - 0xE7FFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xE4000,0xE7FFF,0x00,0x4000,,,E400)
    
      //
      // BIOS Extension Area ( 0xE8000 - 0xEBFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xE8000,0xEBFFF,0x00,0x4000,,,E800)
    
      //
      // BIOS Extension Area ( 0xEC000 - 0xEFFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xEC000,0xEFFFF,0x00,0x4000,,,EC00)
    
      //
      // BIOS Area ( 0xF0000 - 0xFFFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
        ReadWrite,0x00,0xF0000,0xFFFFF,0x00,0x10000,,,F000)
    
    //  //
    //  // Memory Hole Region ( 0xF00000 - 0xFFFFFF )
    //  //
    //  DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,Cacheable,
    //    ReadWrite,0x00,0xF00000,0xFFFFFF,0x00,0x100000,,,HOLE)
    
      //
      // PCI Memory Region ( TOLUD - 0xDFFFFFFF )
      //
      DWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,NonCacheable,
        ReadWrite,0x00,0x00000000,0xDFFFFFFF,0x00,0xE0000000,,,PM01)
    
      //
      // PCI Memory Region ( TOUUD - (TOUUD + ABOVE_4G_MMIO_SIZE) )
      // (This is dummy range for OS compatibility, will patch it in _CRS)
      //
      QWordMemory(ResourceProducer,PosDecode,MinFixed,MaxFixed,NonCacheable,
        ReadWrite,0x00,0x10000,0x1FFFF,0x00,0x10000,,,PM02)
    
    })
    
    Name(EP_B, 0) // to store EP BAR
    Name(MH_B, 0) // to store MCH BAR
    Name(PC_B, 0) // to store PCIe BAR
    Name(PC_L, 0) // to store PCIe BAR Length
    Name(DM_B, 0) // to store DMI BAR
    
    //
    // Get EP BAR
    //
    Method(GEPB,0,Serialized)
    {
      if(LEqual(EP_B,0))
      {
        ShiftLeft(\_SB.PC00.MC.EPBR,12,EP_B)
      }
      Return(EP_B)
    }
    
    //
    // Get MCH BAR
    //
    Method(GMHB,0,Serialized)
    {
      if(LEqual(MH_B,0))
      {
        ShiftLeft(\_SB.PC00.MC.MHBR,15,MH_B)
      }
      Return(MH_B)
    }
    
    //
    // Get PCIe BAR
    //
    Method(GPCB,0,Serialized)
    {
      if(LEqual(PC_B,0))
      {
        ShiftLeft(\_SB.PC00.MC.PXBR,26,PC_B)
      }
      Return(PC_B)
    }
    
    //
    // PCIe root port Pci Cfg space to MMIO address
    // Converts PCI device address from _ADR method to physical memory address
    // Arg0 - _ADR object of the device that will be accessed
    // _ADR returns Integer containing the address of the device
    // High word Device Number, Low word Function Number
    // (for example, device 3, function 2 is 0x00030002). To refer to all the functions on a device #, use a function number of FFFF).
    // Host Memory Space address:
    // Bus Number      [8 bits] [27:20]
    // Device Number   [5 bits] [19:15]
    // Function Number [3 bits] [14:12]
    // Register Number [10 bits][ 9:0 ]
    //
    Method (PC2M, 1, Serialized) {     // Convert _ADR to PCI MMIO address.
      Store (\_SB.PC00.GPCB(), Local0) // MMIO Base address
      Add (Local0, ShiftRight(And(Arg0, 0x001F0000), 1), Local0) // Device no [19:15]
      Add (Local0, ShiftLeft(And(Arg0, 0x00000007), 12), Local0) // Function no [14:12]
      Return (Local0)
    }
    
    //
    // Get PCIe Length
    //
    Method(GPCL,0,Serialized)
    {
      if(LEqual(PC_L,0)) {
        if(LLess (\_SB.PC00.MC.PXSZ, 3)) {
          ShiftRight(0x10000000, \_SB.PC00.MC.PXSZ,PC_L)
        } Else {
          Store(0x10000000, PC_L) // it's for calculating Bus Number of the Segment, so the MAX value is 256MB for 256 Buses
        }
      }
      Return(PC_L)
    }
    
    //
    // Get DMI BAR
    //
    Method(GDMB,0,Serialized)
    {
      if(LEqual(DM_B,0))
      {
        ShiftLeft(\_SB.PC00.MC.DIBR,12,DM_B)
      }
      Return(DM_B)
    }
    
    
    Method(_CRS,0,Serialized)
    {
      //
      // Fix up Max Bus Number and Length
      //
      Store(\_SB.PC00.GPCL(),Local0)
      CreateWordField(BUF0, ^PB00._MAX, PBMX)
      Store(Subtract(ShiftRight(Local0,20),2), PBMX)
      CreateWordField(BUF0, ^PB00._LEN, PBLN)
      Store(Subtract(ShiftRight(Local0,20),1), PBLN)
      //
      // Fix up all of the Option ROM areas from 0xC0000-0xFFFFF.
      //
      If(^MC.PM1L)  // \_SB.PC00
      {
        // PAMx != 0.  Set length = 0.
    
        CreateDwordField(BUF0, ^C000._LEN,C0LN)
        Store(Zero,C0LN)
      }
    
      If(LEqual(^MC.PM1L,1))
      {
        CreateBitField(BUF0, ^C000._RW,C0RW)
        Store(Zero,C0RW)
      }
    
      If(^MC.PM1H)
      {
        CreateDwordField(BUF0, ^C400._LEN,C4LN)
        Store(Zero,C4LN)
      }
    
      If(LEqual(^MC.PM1H,1))
      {
        CreateBitField(BUF0, ^C400._RW,C4RW)
        Store(Zero,C4RW)
      }
    
      If(^MC.PM2L)
      {
        CreateDwordField(BUF0, ^C800._LEN,C8LN)
        Store(Zero,C8LN)
      }
    
      If(LEqual(^MC.PM2L,1))
      {
        CreateBitField(BUF0, ^C800._RW,C8RW)
        Store(Zero,C8RW)
      }
    
      If(^MC.PM2H)
      {
        CreateDwordField(BUF0, ^CC00._LEN,CCLN)
        Store(Zero,CCLN)
      }
    
      If(LEqual(^MC.PM2H,1))
      {
        CreateBitField(BUF0, ^CC00._RW,CCRW)
        Store(Zero,CCRW)
      }
    
      If(^MC.PM3L)
      {
        CreateDwordField(BUF0, ^D000._LEN,D0LN)
        Store(Zero,D0LN)
      }
    
      If(LEqual(^MC.PM3L,1))
      {
        CreateBitField(BUF0, ^D000._RW,D0RW)
        Store(Zero,D0RW)
      }
    
      If(^MC.PM3H)
      {
        CreateDwordField(BUF0, ^D400._LEN,D4LN)
        Store(Zero,D4LN)
      }
    
      If(LEqual(^MC.PM3H,1))
      {
        CreateBitField(BUF0, ^D400._RW,D4RW)
        Store(Zero,D4RW)
      }
    
      If(^MC.PM4L)
      {
        CreateDwordField(BUF0, ^D800._LEN,D8LN)
        Store(Zero,D8LN)
      }
    
      If(LEqual(^MC.PM4L,1))
      {
        CreateBitField(BUF0, ^D800._RW,D8RW)
        Store(Zero,D8RW)
      }
    
      If(^MC.PM4H)
      {
        CreateDwordField(BUF0, ^DC00._LEN,DCLN)
        Store(Zero,DCLN)
      }
    
      If(LEqual(^MC.PM4H,1))
      {
        CreateBitField(BUF0, ^DC00._RW,DCRW)
        Store(Zero,DCRW)
      }
    
      If(^MC.PM5L)
      {
        CreateDwordField(BUF0, ^E000._LEN,E0LN)
        Store(Zero,E0LN)
      }
    
      If(LEqual(^MC.PM5L,1))
      {
        CreateBitField(BUF0, ^E000._RW,E0RW)
        Store(Zero,E0RW)
      }
    
      If(^MC.PM5H)
      {
        CreateDwordField(BUF0, ^E400._LEN,E4LN)
        Store(Zero,E4LN)
      }
    
      If(LEqual(^MC.PM5H,1))
      {
        CreateBitField(BUF0, ^E400._RW,E4RW)
        Store(Zero,E4RW)
      }
    
      If(^MC.PM6L)
      {
        CreateDwordField(BUF0, ^E800._LEN,E8LN)
        Store(Zero,E8LN)
      }
    
      If(LEqual(^MC.PM6L,1))
      {
        CreateBitField(BUF0, ^E800._RW,E8RW)
        Store(Zero,E8RW)
      }
    
      If(^MC.PM6H)
      {
        CreateDwordField(BUF0, ^EC00._LEN,ECLN)
        Store(Zero,ECLN)
      }
    
      If(LEqual(^MC.PM6H,1))
      {
        CreateBitField(BUF0, ^EC00._RW,ECRW)
        Store(Zero,ECRW)
      }
    
      If(^MC.PM0H)
      {
        CreateDwordField(BUF0, ^F000._LEN,F0LN)
        Store(Zero,F0LN)
      }
    
      If(LEqual(^MC.PM0H,1))
      {
        CreateBitField(BUF0, ^F000._RW,F0RW)
        Store(Zero,F0RW)
      }
    
      // Enable the 1MB region between 15-16MB if HENA = 1.
      //
      // If( MCHC.HENA)
      // {
      // CreateDwordField(BUF0, HOLE._LEN,H0LN)
      // Store(0x100000,H0LN)
      // }
    
      //
      // Create pointers to Memory Sizing values.
      //
      CreateDwordField(BUF0, ^PM01._MIN,M1MN)
      CreateDwordField(BUF0, ^PM01._MAX,M1MX)
      CreateDwordField(BUF0, ^PM01._LEN,M1LN)
    
      //
      // Set Memory Size Values. TLUD represents bits 31:20 of phyical
      // TOM, so shift these bits into the correct position and fix up
      // the Memory Region available to PCI.
      //
      Store (M32L, M1LN)
      Store (M32B, M1MN)
      Subtract (Add (M1MN, M1LN), 1, M1MX)
    
      //
      // Create pointers to Memory Sizing values.
      // Patch PM02 range basing on memory size and OS type
      //
      If (LEqual(M64L, 0)) {
        CreateQwordField(BUF0, ^PM02._LEN,MSLN)
        //
        // Set resource length to 0
        //
        Store (0, MSLN)
      }
      Else {
        CreateQwordField(BUF0, ^PM02._LEN,M2LN)
        CreateQwordField(BUF0, ^PM02._MIN,M2MN)
        CreateQwordField(BUF0, ^PM02._MAX,M2MX)
        //
        // Set 64bit MMIO resource Base and Length
        //
        Store (M64L, M2LN)
        Store (M64B, M2MN)
        Subtract (Add (M2MN, M2LN), 1, M2MX)
      }
      Return(BUF0)
    }
    
    //
    //Name(GUID,UUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))
    //
    Name(GUID,Buffer(){0x5b, 0x4d, 0xdb, 0x33,
              0xf7, 0x1f,
              0x1c, 0x40,
              0x96, 0x57,
              0x74, 0x41, 0xc0, 0x3d, 0xd7, 0x66})
    
    
    Name(SUPP,0)  // PCI _OSC Support Field value
    Name(CTRL,0)  // PCI _OSC Control Field value
    Name(XCNT, 0) // Variable used in _OSC for counting
    
    Method(_OSC,4,Serialized)
    {
      //
      // Check for proper UUID
      // Save the capabilities buffer
      //
      Store(Arg3,Local0)
    
      //
      // Create DWord-adressable fields from the Capabilties Buffer
      //
      CreateDWordField(Local0,0,CDW1)
      CreateDWordField(Local0,4,CDW2)
      CreateDWordField(Local0,8,CDW3)
    
      //
      // Check for proper UUID
      //
      If(LEqual(Arg0,GUID))
      {
        // Save Capabilities DWord2 & 3
        Store(CDW2,SUPP)
        Store(CDW3,CTRL)
    
        //
        // You can clear bits in CTRL here if you don't want OS to take
        // control
        //
        If(LNot(NEXP))
        {
          And(CTRL, 0xFFFFFFF8, CTRL)       // disable Native hot plug, PME
        }
    
        If(CondRefOf(ITSP)) {
          If(ITSP) {
            // \_OSC disallow only Advanced Error Reporting control
            And(CTRL, 0xFFFFFFF7, CTRL)
          }
        }
    
        If(Not(And(CDW1,1)))  // Query flag clear?
        { // Disable GPEs for features granted native control.
          Store(CTRL,OSCC)
          If (CondRefOf(SWAK)) {
            SWAK (0xFFFF, 0x0) //Reserved wake
          }
        }
    
        If(LNotEqual(Arg1,One))
        {
          //
          // Unknown revision
          //
          Or(CDW1,0x08,CDW1)
        }
    
        If(LNotEqual(CDW3,CTRL))
        {
          //
          // Capabilities bits were masked
          //
          Or(CDW1,0x10,CDW1)
        }
        //
        // Update DWORD3 in the buffer
        //
        Store(CTRL,CDW3)
        Store(CTRL,OSCC)
        Return(Local0)
      } Else {
        Or(CDW1,4,CDW1)   // Unrecognized UUID
        Return(Local0)
      }
    } // End _OSC
    
    //
    // Added code for Dual IRQ support. Two set of ACPI IRQ tables were generated.
    // Code has been added to select the appropriate IRQ table by checking the CPUID.
    //
    Scope(\_SB.PC00)
    {
      Method(AR00) {
        Return(\_SB.AR00)
      }
    
      Method(PD00) {
        Return(\_SB.PD00)
      }
    
      Method(AR04) {
        Return(\_SB.AR04)
      }
    
      Method(PD04) {
        Return(\_SB.PD04)
      }
    
      Method(AR05) {
        Return(\_SB.AR05)
      }
    
      Method(PD05) {
        Return(\_SB.PD05)
      }
    
      Method(AR06) {
        Return(\_SB.AR06)
      }
    
      Method(PD06) {
        Return(\_SB.PD06)
      }
    
      Method(AR07) {
        Return(\_SB.AR07)
      }
    
      Method(PD07) {
        Return(\_SB.PD07)
      }
    
      Method(AR08) {
        Return(\_SB.AR08)
      }
    
      Method(PD08) {
        Return(\_SB.PD08)
      }
    
      Method(AR09) {
        Return(\_SB.AR09)
      }
    
      Method(PD09) {
        Return(\_SB.PD09)
      }
    
      //
      // Add device scope definition for System Agent
      // P.E.G. Root Port D6F0
      //
      Device(PEG0) {
        Method (_ADR, 0) {
          Store (0x00060000, local0) // Initialize the Address with hardcoded value
          If (CondRefOf (\_SB.PC00.PEG0.CPRA)) {
            Store (\_SB.PC00.PEG0.CPRA (), local0)
          }
          Return (local0)
        }
        Device(PEGP) { // P.E.G. Port Slot x4
          Name(_ADR, 0x00000000)
        }
      }
      //
      // P.E.G. Root Port D1F0
      //
      Device(PEG1) {
        Method (_ADR, 0) {
          Store (0x00010000, local0) // Initialize the Address with hardcoded value
          If (CondRefOf (\_SB.PC00.PEG1.CPRA)) {
            Store (\_SB.PC00.PEG1.CPRA (), local0)
          }
          Return (local0)
        }
        Device(PEGP) { // P.E.G. Port Slot x16
          Name(_ADR, 0x00000000)
        }
      }
      //
      // P.E.G. Root Port D1F1
      //
      Device(PEG2) {
        Method (_ADR, 0) {
          Store (0x00060002, local0) // Initialize the Address with hardcoded value
          If (CondRefOf (\_SB.PC00.PEG2.CPRA)) {
            Store (\_SB.PC00.PEG2.CPRA (), local0)
          }
          Return (local0)
        }
        Device(PEGP) { // P.E.G. Port Slot x8
          Name(_ADR, 0x00000000)
        }
      }
      //If (LGreaterEqual(MPGN, 4)) {
        //
        // P.E.G. Root Port D1F2
        //
        Device(PEG3) {
          Method (_ADR, 0) {
            Store (0x00010002, local0) // Initialize the Address with hardcoded value
            If (CondRefOf (\_SB.PC00.PEG3.CPRA)) {
              Store (\_SB.PC00.PEG3.CPRA (), local0)
            }
            Return (local0)
          }
          Device(PEGP) { // P.E.G. Port Slot x4
            Name(_ADR, 0x00000000)
          }
        }
      //}
      //
      // I.G.D
      //
      Device(GFX0) {
        Name(_ADR, 0x00020000)
      }
      //
      // SA Thermal Device
      //
      Device(TCPU) {
        Method(_DSM,4,serialized){if(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return(Buffer() {0})}
        Name(_ADR, 0x00040000)
      }
      //
      // Device IPU0 is the IPU PCI device
      //
      Device(IPU0) {
        Name(_ADR, 0x00050000)
      }
      //
      // Device GNA D8F0
      //
      Device(GNA0) {
        Name(_ADR, 0x00080000)
      }
    }
    
    Scope(\)
    {
      //
      //
      //  Intel ACPI Debug utility wrapper method to communicate ACPI debug messages.
      //  Method by default will output to Kernel debugger. OEM can implement their own
      //  version on ODBG wrapper call.
      //  Arguments:
      //    Arg0:  any string or value that needs to be passed to debugger agent.
      //
      //  Return Value:
      //    Error if string cannot be processed
      //
      //
      Method(ADBG,1,Serialized)
      {
        //SDBG(Arg0)
        Return(0)
      }
    }

    } // end PC00 Bridge "Host Bridge"
  } // end _SB scope

//  Include ("TimeAndAlarmDevice.asl")
//  Include ("PmaxDev.asl")
//  Include ("AcpiAssert.asl")

  if(LEqual(ECR1,1)){
    Scope(\_SB.PC00) {
      //
      // PCI-specific method's GUID
      //
      Name(PCIG, ToUUID("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))
      //
      // PCI's _DSM - an attempt at modular _DSM implementation
      // When writing your own _DSM function that needs to include PCI-specific methods, do this:
      //
      // Method(_YOUR_DSM,4){
      //   if(Lequal(Arg0,PCIG)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }
      //   ...continue your _DSM by checking different GUIDs...
      //   else { return(0) }
      // }
      //
      Method(PCID, 4, Serialized) {
        If(LEqual(Arg0, PCIG)) {         // PCIE capabilities UUID
          If(LGreaterEqual(Arg1,3)) {                                              // revision at least 3
            If(LEqual(Arg2,0)) { Return (Buffer(2){0x01,0x03}) }                   // function 0: list of supported functions
            If(LEqual(Arg2,8)) { Return (1) }                                      // function 8: Avoiding Power-On Reset Delay Duplication on Sx Resume
            If(LEqual(Arg2,9)) { Return (Package(5){50000,Ones,Ones,50000,Ones}) } // function 9: Specifying Device Readiness Durations
          }
        }
        return (Buffer(1){0})
      }
    }//scope
  }//if

  Scope(\_SB.PC00) {
    //PciCheck, Arg0=UUID, returns true if support for 'PCI delays optimization ECR' is enabled and the UUID is correct
    Method(PCIC,1,Serialized) {
      If(LEqual(ECR1,1)) {
        If(LEqual(Arg0, PCIG)) {
          return (1)
        }
      }
      return (0)
    }

    //
    // Create I2C Bus Resource descriptor for _CRS usage
    // Arg0 - I2C bus address of the connection (Peripheral Address)
    // Arg1 - I2C controller number (Resource Source)
    // Returns buffer with 'I2cSerialBus' resource descriptor
    //
    Method (IICB, 2, Serialized) {
      Switch (ToInteger(Arg1)) {
        Case(0) { Name (IIC0, ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,
          "\\_SB.PC00.I2C0", 0x00, ResourceConsumer, DEV0,) })
          CreateWordField (IIC0, DEV0._ADR, DAD0)
          Store (Arg0, DAD0)
          Return (IIC0) }
        Case(1) { Name (IIC1 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,
          "\\_SB.PC00.I2C1", 0x00, ResourceConsumer, DEV1,) })
          CreateWordField (IIC1, DEV1._ADR, DAD1)
          Store (Arg0, DAD1)
          Return (IIC1) }
        Case(2) { Name (IIC2 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,
          "\\_SB.PC00.I2C2", 0x00, ResourceConsumer, DEV2,) })
          CreateWordField (IIC2, DEV2._ADR, DAD2)
          Store (Arg0, DAD2)
          Return (IIC2) }
        Case(3) { Name (IIC3 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,
          "\\_SB.PC00.I2C3", 0x00, ResourceConsumer, DEV3,) })
          CreateWordField (IIC3, DEV3._ADR, DAD3)
          Store (Arg0, DAD3)
          Return (IIC3) }
        Case(4) { Name (IIC4 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,
          "\\_SB.PC00.I2C4", 0x00, ResourceConsumer, DEV4,) })
          CreateWordField (IIC4, DEV4._ADR, DAD4)
          Store (Arg0, DAD4)
          Return (IIC4) }
        Case(5) { Name (IIC5 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,
          "\\_SB.PC00.I2C5", 0x00, ResourceConsumer, DEV5,) })
          CreateWordField (IIC5, DEV5._ADR, DAD5)
          Store (Arg0, DAD5)
          Return (IIC5) }
        Default {Return (0)}
      }
    }

    //
    // Create I2C Bus Resource descriptor for _CRS usage
    // Arg0 - I2C bus address of the connection (Peripheral Address)
    // Arg1 - I2C Device number
    // Returns buffer with 'I2cSerialBus' resource descriptor
    //
    Method (VIIC, 2, Serialized) {
      Switch (ToInteger (Arg1))
      {
        Case (Zero) // When virtual I2C device VIC0 is selected
        {
          Name (VI00, ResourceTemplate () {
              I2cSerialBus (0, ControllerInitiated, 400000,
                  AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HS07.VIC0",
                  0x00, ResourceConsumer, VI0P,)
          })
          Name (VI01, ResourceTemplate () {
              I2cSerialBus (0, ControllerInitiated, 400000,
                  AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HS06.VIC0",
                  0x00, ResourceConsumer, VI0M,)
          })
          // USB Port Mapping:
          // 6 :Reserved
          // 7 : ADL P
          //
          Return (ResourceTemplate () {I2cSerialBus (0, ControllerInitiated, 400000,AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HSXX.VIC0",0x00, ResourceConsumer, ,)}) // Dummy
        }
        Case (One) // When virtual I2C device VIC1 is selected
        {
          Name (VI10, ResourceTemplate () {
              I2cSerialBus (0, ControllerInitiated, 400000,
                  AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HS07.VIC1",
                  0x00, ResourceConsumer, VI1P,)
          })
          Name (VI11, ResourceTemplate () {
              I2cSerialBus (0, ControllerInitiated, 400000,
                  AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HS06.VIC1",
                  0x00, ResourceConsumer, VI1M,)
          })
          // USB Port Mapping:
          // 6 : Reserved
          // 7 : ADL P
          //
          Return (ResourceTemplate () {I2cSerialBus (0, ControllerInitiated, 400000,AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HSXX.VIC1",0x00, ResourceConsumer, ,)}) // Dummy
        }
        Default
        {
          Return (ResourceTemplate () {I2cSerialBus (0, ControllerInitiated, 400000,AddressingMode7Bit, "\\_SB.PC00.XHCI.RHUB.HSXX.VICX",0x00, ResourceConsumer, ,)}) // Dummy
        }
      }
    }

    //
    // Create Interrupt Resource descriptor for _CRS usage
    // Arg0 - GPIO Pad used as Interrupt source
    // Arg1 - Edge (1) or Level (0) interrupt triggering
    // Arg2 - Active Level: High (1) or Low (0)
    // Returns buffer with 'Interrupt' resource descriptor
    //
    Method (INTB, 3, Serialized) {
      Name (INTR, ResourceTemplate () { Interrupt (ResourceConsumer, Level, ActiveLow, ExclusiveAndWake,,,INTI) {0} })
      // Update APIC Interrupt descriptor
      CreateDWordField (INTR, INTI._INT, NUMI) // Interrupt Number
      Store (INUM(Arg0), NUMI)
      CreateBitField (INTR, INTI._HE, LEVI) // Level or Edge
      Store (Arg1, LEVI)
      CreateBitField (INTR, INTI._LL, ACTI) // Active High or Low
      Store (Arg2, ACTI)

      Return (INTR)
    }

  } // END Scope(\_SB.PC00)

  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  //
  // Since asl compiler update to 2018 version
  // Empty template will casuse warrning
  // using this Macro to replace empty ResourceTemplate with End Tag
  //
  
  
  #line 3831 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Library/PchInfoLib.h"
/** @file
  Header file for PchInfoLib.

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/



#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Uefi/UefiBaseType.h"
/** @file
  Defines data types and constants introduced in UEFI.

Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
Portions copyright (c) 2011 - 2016, ARM Ltd. All rights reserved.<BR>
Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>

SPDX-License-Identifier: BSD-2-Clause-Patent

**/






//
// Basic data type definitions introduced in UEFI.
//

///
/// 128-bit buffer containing a unique identifier value.
///
typedef GUID                      EFI_GUID;
///
/// Function return status for EFI API.
///
typedef RETURN_STATUS             EFI_STATUS;
///
/// A collection of related interfaces.
///
typedef void                      *EFI_HANDLE;
///
/// Handle to an event structure.
///
typedef void                      *EFI_EVENT;
///
/// Task priority level.
///
typedef UINTN                     EFI_TPL;
///
/// Logical block address.
///
typedef UINT64                    EFI_LBA;

///
/// 64-bit physical memory address.
///
typedef UINT64                    EFI_PHYSICAL_ADDRESS;

///
/// 64-bit virtual memory address.
///
typedef UINT64                    EFI_VIRTUAL_ADDRESS;

///
/// EFI Time Abstraction:
///  Year:       1900 - 9999
///  Month:      1 - 12
///  Day:        1 - 31
///  Hour:       0 - 23
///  Minute:     0 - 59
///  Second:     0 - 59
///  Nanosecond: 0 - 999,999,999
///  TimeZone:   -1440 to 1440 or 2047
///
typedef struct {
  UINT16  Year;
  UINT8   Month;
  UINT8   Day;
  UINT8   Hour;
  UINT8   Minute;
  UINT8   Second;
  UINT8   Pad1;
  UINT32  Nanosecond;
  INT16   TimeZone;
  UINT8   Daylight;
  UINT8   Pad2;
} EFI_TIME;


///
/// 4-byte buffer. An IPv4 internet protocol address.
///
typedef IPv4_ADDRESS EFI_IPv4_ADDRESS;

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
typedef IPv6_ADDRESS EFI_IPv6_ADDRESS;

///
/// 32-byte buffer containing a network Media Access Control address.
///
typedef struct {
  UINT8 Addr[32];
} EFI_MAC_ADDRESS;

///
/// 16-byte buffer aligned on a 4-byte boundary.
/// An IPv4 or IPv6 internet protocol address.
///
typedef union {
  UINT32            Addr[4];
  EFI_IPv4_ADDRESS  v4;
  EFI_IPv6_ADDRESS  v6;
} EFI_IP_ADDRESS;


///
/// Enumeration of EFI_STATUS.
///@{








































///@}

///
/// Define macro to encode the status code.
///




///
/// ICMP error definitions
///@{




///@}

///
/// Tcp connection status definitions
///@{



///@}

//
// The EFI memory allocation functions work in units of EFI_PAGEs that are
// 4KB. This should in no way be confused with the page size of the processor.
// An EFI_PAGE is just the quanta of memory in EFI.
//




/**
  Macro that converts a size, in bytes, to a number of EFI_PAGESs.

  @param  Size      A size in bytes.  This parameter is assumed to be type UINTN.
                    Passing in a parameter that is larger than UINTN may produce
                    unexpected results.

  @return  The number of EFI_PAGESs associated with the number of bytes specified
           by Size.

**/


/**
  Macro that converts a number of EFI_PAGEs to a size in bytes.

  @param  Pages     The number of EFI_PAGES.  This parameter is assumed to be
                    type UINTN.  Passing in a parameter that is larger than
                    UINTN may produce unexpected results.

  @return  The number of bytes associated with the number of EFI_PAGEs specified
           by Pages.

**/


///
/// PE32+ Machine type for IA32 UEFI images.
///


///
/// PE32+ Machine type for IA64 UEFI images.
///


///
/// PE32+ Machine type for EBC UEFI images.
///


///
/// PE32+ Machine type for X64 UEFI images.
///


///
/// PE32+ Machine type for ARM mixed ARM and Thumb/Thumb2 images.
///


///
/// PE32+ Machine type for AARCH64 A64 images.
///


///
/// PE32+ Machine type for RISC-V 32/64/128
///


















































#line 298 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Uefi/UefiBaseType.h"











#line 310 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Uefi/UefiBaseType.h"

#line 312 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\MdePkg\\Include\\Uefi/UefiBaseType.h"
#line 12 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Library/PchInfoLib.h"

typedef UINT8 PCH_STEPPING;


typedef UINT8 PCH_SERIES;








typedef UINT8 PCH_GENERATION;








typedef enum {
  RstUnsupported  = 0,
  RstPremium,
  RstOptane,
  RstMaxMode
} RST_MODE;

/**
  Return LPC Device Id

  @retval PCH_LPC_DEVICE_ID         PCH Lpc Device ID
**/
UINT16
PchGetLpcDid (
  void
  );

/**
  Return Pch stepping type

  @retval PCH_STEPPING            Pch stepping type
**/
PCH_STEPPING
PchStepping (
  void
  );

/**
  Determine if PCH is supported

  @retval TRUE                    PCH is supported
  @retval FALSE                   PCH is not supported
**/
BOOLEAN
IsPchSupported (
  void
  );

/**
  Return Pch Series

  @retval PCH_SERIES                Pch Series
**/
PCH_SERIES
PchSeries (
  void
  );

/**
  Check if this is PCH LP series

  @retval TRUE                It's PCH LP series
  @retval FALSE               It's not PCH LP series
**/
BOOLEAN
IsPchLp (
  void
  );

/**
  Check if this is PCH H series

  @retval TRUE                It's PCH H series
  @retval FALSE               It's not PCH H series
**/
BOOLEAN
IsPchH (
  void
  );

/**
  Check if this is PCH N series

  @retval TRUE                It's PCH N series
  @retval FALSE               It's not PCH N series
**/
BOOLEAN
IsPchN (
  void
  );

/**
  Check if this is PCH P series

  @retval TRUE                It's PCH P series
  @retval FALSE               It's not PCH P series
**/
BOOLEAN
IsPchP (
  void
  );

/**
  Check if this is PCH M series

  @retval TRUE                It's PCH M series
  @retval FALSE               It's not PCH M series
**/
BOOLEAN
IsPchM (
  void
  );

/**
  Check if this is PCH S series

  @retval TRUE                It's PCH S series
  @retval FALSE               It's not PCH S series
**/
BOOLEAN
IsPchS (
  void
  );

/**
  Check if this is Server PCH

  @retval TRUE                It's a Server PCH
  @retval FALSE               It's not a Server PCH
**/
BOOLEAN
IsPchServer (
  void
  );

/**
  Return Pch Generation

  @retval PCH_GENERATION            Pch Generation
**/
PCH_GENERATION
PchGeneration (
  void
  );

/**
  Check if this is CDF PCH generation

  @retval TRUE                It's CDF PCH
  @retval FALSE               It's not CDF PCH
**/
BOOLEAN
IsCdfPch (
  void
  );

/**
  Check if this is EBG PCH generation

  @retval TRUE                It's EBG PCH
  @retval FALSE               It's not EBG PCH
**/
BOOLEAN
IsEbgPch (
  void
  );

/**
  Check if this is CNL PCH generation

  @retval TRUE                It's CNL PCH
  @retval FALSE               It's not CNL PCH
**/
BOOLEAN
IsCnlPch (
  void
  );

/**
  Check if this is ICL PCH generation

  @retval TRUE                It's ICL PCH
  @retval FALSE               It's not ICL PCH
**/
BOOLEAN
IsIclPch (
  void
  );

/**
  Check if this is TGL PCH generation

  @retval TRUE                It's TGL PCH
  @retval FALSE               It's not TGL PCH
**/
BOOLEAN
IsTglPch (
  void
  );

/**
  Check if this is JSL PCH generation

  @retval TRUE                It's JSL PCH
  @retval FALSE               It's not JSL PCH
**/
BOOLEAN
IsJslPch (
  void
  );

/**
  Check if this is ADL PCH generation

  @retval TRUE                It's ADL PCH
  @retval FALSE               It's not ADL PCH
**/
BOOLEAN
IsAdlPch (
  void
  );

/**
  Get Maximum Sata Port Number

  @param[in]  SataCtrlIndex       SATA controller index

  @retval     Maximum Sata Port Number
**/
UINT8
MaxSataPortNum (
   UINT32      SataCtrlIndex
  );

/**
  Check if this is Server SKU

  @retval TRUE                It's PCH Server SKU
  @retval FALSE               It's not PCH Server SKU
**/
BOOLEAN
IsPchServerSku (
  void
  );

/**
  Get Pch Maximum Pcie Root Port Number

  @retval PcieMaxRootPort         Pch Maximum Pcie Root Port Number
**/
UINT8
GetPchMaxPciePortNum (
  void
  );

/**
  Get Pch Maximum Pcie Controller Number

  @retval Pch Maximum Pcie Controller Number
**/
UINT8
GetPchMaxPcieControllerNum (
  void
  );

/**
  Get Pch Maximum Pcie Clock Number

  @retval Pch Maximum Pcie Clock Number
**/
UINT8
GetPchMaxPcieClockNum (
  void
  );

/**
  Get Pch Maximum Pcie ClockReq Number

  @retval Pch Maximum Pcie ClockReq Number
**/
UINT8
GetPchMaxPcieClockReqNum (
  void
  );

/**
  Get Pch Usb2 Maximum Physical Port Number

  @retval Pch Usb2 Maximum Physical Port Number
**/
UINT8
GetPchUsb2MaxPhysicalPortNum (
  void
  );

/**
  Get Pch Maximum Usb2 Port Number of XHCI Controller

  @retval Pch Maximum Usb2 Port Number of XHCI Controller
**/
UINT8
GetPchXhciMaxUsb2PortNum (
  void
  );

/**
  Get Pch Usb3 Maximum Physical Port Number

  @retval Pch Usb3 Maximum Physical Port Number
**/
UINT8
GetPchUsb3MaxPhysicalPortNum (
  void
  );

/**
  Get Pch Maximum Usb3 Port Number of XHCI Controller

  @retval Pch Maximum Usb3 Port Number of XHCI Controller
**/
UINT8
GetPchXhciMaxUsb3PortNum (
  void
  );

/**
  Get Pch Maximum Serial IO I2C controllers number

  @retval Pch Maximum Serial IO I2C controllers number
**/
UINT8
GetPchMaxSerialIoI2cControllersNum (
  void
  );

/**
  Get Pch Maximum Serial IO SPI controllers number

  @retval Pch Maximum Serial IO SPI controllers number
**/
UINT8
GetPchMaxSerialIoSpiControllersNum (
  void
  );

/**
  Get Pch Maximum Serial IO UART controllers number

  @retval Pch Maximum Serial IO UART controllers number
**/
UINT8
GetPchMaxSerialIoUartControllersNum (
  void
  );

/**
  Get Pch Maximum Serial IO SPI Chip Selects count

  @retval Pch Maximum Serial IO SPI Chip Selects nu,ber
**/
UINT8
GetPchMaxSerialIoSpiChipSelectsNum (
  void
  );

/**
  Get Pch Maximum ISH UART Controller number

  @retval Pch Maximum ISH UART controllers number
**/
UINT8
GetPchMaxIshUartControllersNum (
  void
  );

/**
  Get Pch Maximum ISH I2C Controller number

  @retval Pch Maximum ISH I2C controllers number
**/
UINT8
GetPchMaxIshI2cControllersNum (
  void
  );

/**
  Get Pch Maximum ISH I3C Controller number

  @retval Pch Maximum ISH I3C controllers number
**/
UINT8
GetPchMaxIshI3cControllersNum (
  void
  );

/**
  Get Pch Maximum ISH SPI Controller number

  @retval Pch Maximum ISH SPI controllers number
**/
UINT8
GetPchMaxIshSpiControllersNum (
  void
  );

/**
  Get Pch Maximum ISH SPI Controller Cs pins number

  @retval Pch Maximum ISH SPI controller Cs pins number
**/
UINT8
GetPchMaxIshSpiControllerCsPinsNum (
  void
  );

/**
  Get Pch Maximum ISH GP number

  @retval Pch Maximum ISH GP number
**/
UINT8
GetPchMaxIshGpNum (
  void
  );

/**
  Get Pch Maximum ME Applet count

  @retval Pch Maximum ME Applet number
**/
UINT8
GetPchMaxMeAppletCount (
  void
  );

/**
Get Pch Maximum ME Session count

@retval Pch Maximum ME Sesion number
**/
UINT8
GetPchMaxMeSessionCount(
  void
);

/**
  Get Pch Maximum Type C Port Number

  @retval Pch Maximum Type C Port Number
**/
UINT8
GetPchMaxTypeCPortNum (
  void
  );



/**
  Get PCH stepping ASCII string.
  Function determines major and minor stepping versions and writes them into a buffer.
  The return string is zero terminated

  @param [out]     Buffer               Output buffer of string
  @param [in]      BufferSize           Buffer size.
                                        Must not be less then PCH_STEPPING_STR_LENGTH_MAX

  @retval EFI_SUCCESS                   String copied successfully
  @retval EFI_INVALID_PARAMETER         The stepping is not supported, or parameters are NULL
  @retval EFI_BUFFER_TOO_SMALL          Input buffer size is too small
**/
EFI_STATUS
PchGetSteppingStr (
      CHAR8                          *Buffer,
       UINT32                         BufferSize
  );

/**
  Get PCH series ASCII string.
  The return string is zero terminated.

  @retval Static ASCII string of PCH Series
**/
CHAR8*
PchGetSeriesStr (
  );

/**
  Get PCH Sku ASCII string
  The return string is zero terminated.

  @retval Static ASCII string of PCH Sku
**/
CHAR8*
PchGetSkuStr (
  void
  );

/**
  Check if this chipset supports eMMC controller

  @retval BOOLEAN  TRUE if supported, FALSE otherwise
**/
BOOLEAN
IsPchEmmcSupported (
  void
  );

/**
  Check if this chipset supports SD controller

  @retval BOOLEAN  TRUE if supported, FALSE otherwise
**/
BOOLEAN
IsPchSdCardSupported (
  void
  );

/**
  Check if this chipset supports THC controller

  @retval BOOLEAN  TRUE if supported, FALSE otherwise
**/
BOOLEAN
IsPchThcSupported (
  void
  );

/**
  Check if this chipset supports HSIO BIOS Sync

  @retval BOOLEAN  TRUE if supported, FALSE otherwise
**/
BOOLEAN
IsPchChipsetInitSyncSupported (
  void
  );

/**
  Gets the maximum number of UFS controller supported by this chipset.

  @return Number of supported UFS controllers
**/
UINT8
PchGetMaxUfsNum (
  void
  );

/**
  Get RST mode supported by the silicon

  @retval RST_MODE    RST mode supported by silicon
**/
RST_MODE
PchGetSupportedRstMode (
  void
  );

/**
  Check whether integrated LAN controller is supported.

  @retval TRUE                    GbE is supported in PCH
  @retval FALSE                   GbE is not supported by PCH
**/
BOOLEAN
PchIsGbeSupported (
  void
  );

/**
  Check whether integrated TSN is supported.

  @retval TRUE                    TSN is supported in current PCH
  @retval FALSE                   TSN is not supported on current PCH
**/
BOOLEAN
PchIsTsnSupported (
  void
  );

/**
  Check whether ISH is supported.

  @retval TRUE                    ISH is supported in PCH
  @retval FALSE                   ISH is not supported by PCH
**/
BOOLEAN
PchIsIshSupported (
  void
  );

/**
  Check whether ATX Shutdown (PS_ON) is supported.

  @retval    TRUE           ATX Shutdown (PS_ON) is supported in PCH
  @retval    FALSE          ATX Shutdown (PS_ON) is not supported by PCH
**/
BOOLEAN
IsPchPSOnSupported (
  void
  );

/**
  Check if link between PCH and CPU is an P-DMI

  @retval    TRUE           P-DMI link
  @retval    FALSE          Not an P-DMI link
**/
BOOLEAN
IsPchWithPdmi (
  void
  );

/**
  Check if link between PCH and CPU is an OP-DMI

  @retval    TRUE           OP-DMI link
  @retval    FALSE          Not an OP-DMI link
**/
BOOLEAN
IsPchWithOpdmi (
  void
  );

/**
  Check if link between PCH and CPU is an F-DMI

  @retval    TRUE           F-DMI link
  @retval    FALSE          Not an F-DMI link
**/
BOOLEAN
IsPchWithFdmi (
  void
  );

/**
  Get Pch Maximum THC count

  @retval Pch Maximum THC count number
**/
UINT8
GetPchMaxThcCount (
  void
  );

typedef enum {
  SataSosc125Mhz = 0,
  SataSosc120Mhz,
  SataSosc100Mhz,
  SataSosc25Mhz,
  SataSosc19p2Mhz,
  SataSoscUnsupported
} SATA_SOSC_CLK_FREQ;

/**
  Returns a frequency of the sosc_clk signal.
  All SATA controllers on the system are assumed to
  work on the same sosc_clk frequency.

  @retval Frequency of the sosc_clk signal.
**/
SATA_SOSC_CLK_FREQ
GetSataSoscClkFreq (
  void
  );

/**
  Check if SATA support should be awake after function disable

  @retval    TRUE
  @retval    FALSE
**/
BOOLEAN
IsSataSupportWakeAfterFunctionDisable (
  void
  );


//
// USB2 PHY reference frequencies values (MHz)
//
typedef enum {
  FREQ_19_2 = 0u,
  FREQ_24_0,
  FREQ_96_0,
  FREQ_MAX
} USB2_PHY_REF_FREQ;

/**
  Returns USB2 PHY Reference Clock frequency value used by PCH
  This defines what electrical tuning parameters shall be used
  during USB2 PHY initialization programming

  @retval Frequency reference clock for USB2 PHY
**/
USB2_PHY_REF_FREQ
GetUsb2PhyRefFreq (
  void
  );

/**
  return support status for P2SB PCR 20-bit addressing

  @retval    TRUE
  @retval    FALSE
**/
BOOLEAN
IsP2sb20bPcrSupported (
  void
  );

/**
  Check if SPI in a given PCH generation supports an Extended BIOS Range Decode

  @retval TRUE or FALSE if PCH supports Extended BIOS Range Decode
**/
BOOLEAN
IsExtendedBiosRangeDecodeSupported (
  void
  );

/**
  Returns DMI target for current PCH SPI

  @retval PCH SPI DMI target
**/
UINT16
GetPchSpiDmiTarget (
  void
  );
#line 754 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Library/PchInfoLib.h"
#line 3833 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsLpc.h"
/** @file
  Register names for PCH LPC/eSPI device

  Copyright (c) 2021-2022, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




















//
// Processor interface registers
//




#line 36 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsLpc.h"
#line 3834 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchPcieRpRegs.h"
/** @file
  Register names for PCH PCI-E root port devices

  Conventions:

  - Register definition format:
    Prefix_[GenerationName]_[ComponentName]_SubsystemName_RegisterSpace_RegisterName
  - Prefix:
    Definitions beginning with "R_" are registers
    Definitions beginning with "B_" are bits within registers
    Definitions beginning with "V_" are meaningful values within the bits
    Definitions beginning with "S_" are register size
    Definitions beginning with "N_" are the bit position
  - [GenerationName]:
    Three letter acronym of the generation is used (e.g. SKL,KBL,CNL etc.).
    Register name without GenerationName applies to all generations.
  - [ComponentName]:
    This field indicates the component name that the register belongs to (e.g. PCH, SA etc.)
    Register name without ComponentName applies to all components.
    Register that is specific to -H denoted by "_PCH_H_" in component name.
    Register that is specific to -LP denoted by "_PCH_LP_" in component name.
  - SubsystemName:
    This field indicates the subsystem name of the component that the register belongs to
    (e.g. PCIE, USB, SATA, GPIO, PMC etc.).
  - RegisterSpace:
    MEM - MMIO space register of subsystem.
    IO  - IO space register of subsystem.
    PCR - Private configuration register of subsystem.
    CFG - PCI configuration space register of subsystem.
  - RegisterName:
    Full register name.

  Copyright (c) 2021 - 2022, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/





































































































//
// PCIE PCRs (PID:SPA SPB SPC SPD SPE SPF)
//






//
// ICC PCR (PID: ICC)
//
#line 151 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchPcieRpRegs.h"
#line 3835 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioAcpiDefines.h"
/**@file
 Defines for GPIO ACPI Interface

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/

//
// PCH GPIO Community address
//






#line 3837 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  
  
  
  
  
  Name (PNVB, 0xFFFF0000)  // PCH NVS Base address
  Name (PNVL, 0xAA55)      // PCH NVS Length
  //
  // Automatically generated by GenNvs ver 2.4.6
  // Please DO NOT modify !!!
  //
  
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
    //
    // Define PCH NVS Area operatino region.
    //
  
  
    OperationRegion(PNVA,SystemMemory,PNVB,PNVL)
    Field(PNVA,AnyAcc,Lock,Preserve)
    {  Offset(0),      PCHS, 16, // Offset(0),     PCH Series
    Offset(2),      PCHG, 16, // Offset(2),     PCH Generation
    Offset(4),      PSTP, 16, // Offset(4),     PCH Stepping
    Offset(6),      RPA1, 32, // Offset(6),     Root Port address 1
    Offset(10),     RPA2, 32, // Offset(10),    Root Port address 2
    Offset(14),     RPA3, 32, // Offset(14),    Root Port address 3
    Offset(18),     RPA4, 32, // Offset(18),    Root Port address 4
    Offset(22),     RPA5, 32, // Offset(22),    Root Port address 5
    Offset(26),     RPA6, 32, // Offset(26),    Root Port address 6
    Offset(30),     RPA7, 32, // Offset(30),    Root Port address 7
    Offset(34),     RPA8, 32, // Offset(34),    Root Port address 8
    Offset(38),     RPA9, 32, // Offset(38),    Root Port address 9
    Offset(42),     RPAA, 32, // Offset(42),    Root Port address 10
    Offset(46),     RPAB, 32, // Offset(46),    Root Port address 11
    Offset(50),     RPAC, 32, // Offset(50),    Root Port address 12
    Offset(54),     RPAD, 32, // Offset(54),    Root Port address 13
    Offset(58),     RPAE, 32, // Offset(58),    Root Port address 14
    Offset(62),     RPAF, 32, // Offset(62),    Root Port address 15
    Offset(66),     RPAG, 32, // Offset(66),    Root Port address 16
    Offset(70),     RPAH, 32, // Offset(70),    Root Port address 17
    Offset(74),     RPAI, 32, // Offset(74),    Root Port address 18
    Offset(78),     RPAJ, 32, // Offset(78),    Root Port address 19
    Offset(82),     RPAK, 32, // Offset(82),    Root Port address 20
    Offset(86),     RPAL, 32, // Offset(86),    Root Port address 21
    Offset(90),     RPAM, 32, // Offset(90),    Root Port address 22
    Offset(94),     RPAN, 32, // Offset(94),    Root Port address 23
    Offset(98),     RPAO, 32, // Offset(98),    Root Port address 24
    Offset(102),    RPAP, 32, // Offset(102),   Root Port address 25
    Offset(106),    RPAQ, 32, // Offset(106),   Root Port address 26
    Offset(110),    RPAR, 32, // Offset(110),   Root Port address 27
    Offset(114),    RPAS, 32, // Offset(114),   Root Port address 28
    Offset(118),    NHLA, 64, // Offset(118),   HD-Audio NHLT ACPI address
    Offset(126),    NHLL, 32, // Offset(126),   HD-Audio NHLT ACPI length
    Offset(130),    ADFM, 32, // Offset(130),   HD-Audio DSP Feature Mask
    Offset(134),    SWQ0, 8,  // Offset(134),   HD-Audio SoundWire Link #1 quirk mask
    Offset(135),    SWQ1, 8,  // Offset(135),   HD-Audio SoundWire Link #2 quirk mask
    Offset(136),    SWQ2, 8,  // Offset(136),   HD-Audio SoundWire Link #3 quirk mask
    Offset(137),    SWQ3, 8,  // Offset(137),   HD-Audio SoundWire Link #4 quirk mask
    Offset(138),    ACS0, 8,  // Offset(138),   HD-Audio SoundWire Link #1 Autonomous Clock Stop
    Offset(139),    ACS1, 8,  // Offset(139),   HD-Audio SoundWire Link #2 Autonomous Clock Stop
    Offset(140),    ACS2, 8,  // Offset(140),   HD-Audio SoundWire Link #3 Autonomous Clock Stop
    Offset(141),    ACS3, 8,  // Offset(141),   HD-Audio SoundWire Link #4 Autonomous Clock Stop
    Offset(142),    DAI0, 8,  // Offset(142),   HD-Audio SoundWire Link #1 Data On Active Interval Select
    Offset(143),    DAI1, 8,  // Offset(143),   HD-Audio SoundWire Link #2 Data On Active Interval Select
    Offset(144),    DAI2, 8,  // Offset(144),   HD-Audio SoundWire Link #3 Data On Active Interval Select
    Offset(145),    DAI3, 8,  // Offset(145),   HD-Audio SoundWire Link #4 Data On Active Interval Select
    Offset(146),    DOD0, 8,  // Offset(146),   HD-Audio SoundWire Link #1 Data On Delay Select
    Offset(147),    DOD1, 8,  // Offset(147),   HD-Audio SoundWire Link #2 Data On Delay Select
    Offset(148),    DOD2, 8,  // Offset(148),   HD-Audio SoundWire Link #3 Data On Delay Select
    Offset(149),    DOD3, 8,  // Offset(149),   HD-Audio SoundWire Link #4 Data On Delay Select
    Offset(150),    SWMC, 8,  // Offset(150),   HD-Audio SoundWire Host Count
    Offset(151),    XTAL, 32, // Offset(151),   XTAL frequency: 0: 24MHz; 1: 38.4MHz; 2: Unsupported
    Offset(155),    AFDF, 8,  // Offset(155),   Audio FPGA Number of Device and Function. 0: Audio FPGA not detected
    Offset(156),    SBRG, 32, // Offset(156),   SBREG_BAR
    Offset(160),    GEI0, 8,  // Offset(160),   GPIO GroupIndex mapped to GPE_DW0
    Offset(161),    GEI1, 8,  // Offset(161),   GPIO GroupIndex mapped to GPE_DW1
    Offset(162),    GEI2, 8,  // Offset(162),   GPIO GroupIndex mapped to GPE_DW2
    Offset(163),    GED0, 8,  // Offset(163),   GPIO DW part of group mapped to GPE_DW0
    Offset(164),    GED1, 8,  // Offset(164),   GPIO DW part of group mapped to GPE_DW1
    Offset(165),    GED2, 8,  // Offset(165),   GPIO DW part of group mapped to GPE_DW2
    Offset(166),    PML1, 16, // Offset(166),   PCIE LTR max snoop Latency 1
    Offset(168),    PML2, 16, // Offset(168),   PCIE LTR max snoop Latency 2
    Offset(170),    PML3, 16, // Offset(170),   PCIE LTR max snoop Latency 3
    Offset(172),    PML4, 16, // Offset(172),   PCIE LTR max snoop Latency 4
    Offset(174),    PML5, 16, // Offset(174),   PCIE LTR max snoop Latency 5
    Offset(176),    PML6, 16, // Offset(176),   PCIE LTR max snoop Latency 6
    Offset(178),    PML7, 16, // Offset(178),   PCIE LTR max snoop Latency 7
    Offset(180),    PML8, 16, // Offset(180),   PCIE LTR max snoop Latency 8
    Offset(182),    PML9, 16, // Offset(182),   PCIE LTR max snoop Latency 9
    Offset(184),    PMLA, 16, // Offset(184),   PCIE LTR max snoop Latency 10
    Offset(186),    PMLB, 16, // Offset(186),   PCIE LTR max snoop Latency 11
    Offset(188),    PMLC, 16, // Offset(188),   PCIE LTR max snoop Latency 12
    Offset(190),    PMLD, 16, // Offset(190),   PCIE LTR max snoop Latency 13
    Offset(192),    PMLE, 16, // Offset(192),   PCIE LTR max snoop Latency 14
    Offset(194),    PMLF, 16, // Offset(194),   PCIE LTR max snoop Latency 15
    Offset(196),    PMLG, 16, // Offset(196),   PCIE LTR max snoop Latency 16
    Offset(198),    PMLH, 16, // Offset(198),   PCIE LTR max snoop Latency 17
    Offset(200),    PMLI, 16, // Offset(200),   PCIE LTR max snoop Latency 18
    Offset(202),    PMLJ, 16, // Offset(202),   PCIE LTR max snoop Latency 19
    Offset(204),    PMLK, 16, // Offset(204),   PCIE LTR max snoop Latency 20
    Offset(206),    PMLL, 16, // Offset(206),   PCIE LTR max snoop Latency 21
    Offset(208),    PMLM, 16, // Offset(208),   PCIE LTR max snoop Latency 22
    Offset(210),    PMLN, 16, // Offset(210),   PCIE LTR max snoop Latency 23
    Offset(212),    PMLO, 16, // Offset(212),   PCIE LTR max snoop Latency 24
    Offset(214),    PMLP, 16, // Offset(214),   PCIE LTR max snoop Latency 25
    Offset(216),    PMLQ, 16, // Offset(216),   PCIE LTR max snoop Latency 26
    Offset(218),    PMLR, 16, // Offset(218),   PCIE LTR max snoop Latency 27
    Offset(220),    PMLS, 16, // Offset(220),   PCIE LTR max snoop Latency 28
    Offset(222),    PNL1, 16, // Offset(222),   PCIE LTR max no snoop Latency 1
    Offset(224),    PNL2, 16, // Offset(224),   PCIE LTR max no snoop Latency 2
    Offset(226),    PNL3, 16, // Offset(226),   PCIE LTR max no snoop Latency 3
    Offset(228),    PNL4, 16, // Offset(228),   PCIE LTR max no snoop Latency 4
    Offset(230),    PNL5, 16, // Offset(230),   PCIE LTR max no snoop Latency 5
    Offset(232),    PNL6, 16, // Offset(232),   PCIE LTR max no snoop Latency 6
    Offset(234),    PNL7, 16, // Offset(234),   PCIE LTR max no snoop Latency 7
    Offset(236),    PNL8, 16, // Offset(236),   PCIE LTR max no snoop Latency 8
    Offset(238),    PNL9, 16, // Offset(238),   PCIE LTR max no snoop Latency 9
    Offset(240),    PNLA, 16, // Offset(240),   PCIE LTR max no snoop Latency 10
    Offset(242),    PNLB, 16, // Offset(242),   PCIE LTR max no snoop Latency 11
    Offset(244),    PNLC, 16, // Offset(244),   PCIE LTR max no snoop Latency 12
    Offset(246),    PNLD, 16, // Offset(246),   PCIE LTR max no snoop Latency 13
    Offset(248),    PNLE, 16, // Offset(248),   PCIE LTR max no snoop Latency 14
    Offset(250),    PNLF, 16, // Offset(250),   PCIE LTR max no snoop Latency 15
    Offset(252),    PNLG, 16, // Offset(252),   PCIE LTR max no snoop Latency 16
    Offset(254),    PNLH, 16, // Offset(254),   PCIE LTR max no snoop Latency 17
    Offset(256),    PNLI, 16, // Offset(256),   PCIE LTR max no snoop Latency 18
    Offset(258),    PNLJ, 16, // Offset(258),   PCIE LTR max no snoop Latency 19
    Offset(260),    PNLK, 16, // Offset(260),   PCIE LTR max no snoop Latency 20
    Offset(262),    PNLL, 16, // Offset(262),   PCIE LTR max no snoop Latency 21
    Offset(264),    PNLM, 16, // Offset(264),   PCIE LTR max no snoop Latency 22
    Offset(266),    PNLN, 16, // Offset(266),   PCIE LTR max no snoop Latency 23
    Offset(268),    PNLO, 16, // Offset(268),   PCIE LTR max no snoop Latency 24
    Offset(270),    PNLP, 16, // Offset(270),   PCIE LTR max no snoop Latency 25
    Offset(272),    PNLQ, 16, // Offset(272),   PCIE LTR max no snoop Latency 26
    Offset(274),    PNLR, 16, // Offset(274),   PCIE LTR max no snoop Latency 27
    Offset(276),    PNLS, 16, // Offset(276),   PCIE LTR max no snoop Latency 28
    Offset(278),    XHPC, 8,  // Offset(278),   Number of HighSpeed ports implemented in XHCI controller
    Offset(279),    XRPC, 8,  // Offset(279),   Number of USBR ports implemented in XHCI controller
    Offset(280),    XSPC, 8,  // Offset(280),   Number of SuperSpeed ports implemented in XHCI controller
    Offset(281),    XSPA, 8,  // Offset(281),   Address of 1st SuperSpeed port
    Offset(282),    HPTB, 32, // Offset(282),   HPET base address
    Offset(286),    HPTE, 8,  // Offset(286),   HPET enable
    //SerialIo block
    Offset(287),    SM00, 8,  // Offset(287),   SerialIo SPI Controller 0 Mode
    Offset(288),    SM01, 8,  // Offset(288),   SerialIo SPI Controller 1 Mode
    Offset(289),    SM02, 8,  // Offset(289),   SerialIo SPI Controller 2 Mode
    Offset(290),    SM03, 8,  // Offset(290),   SerialIo SPI Controller 3 Mode
    Offset(291),    SM04, 8,  // Offset(291),   SerialIo SPI Controller 4 Mode
    Offset(292),    SM05, 8,  // Offset(292),   SerialIo SPI Controller 5 Mode
    Offset(293),    SM06, 8,  // Offset(293),   SerialIo SPI Controller 6 Mode
    Offset(294),    SC00, 64, // Offset(294),   SerialIo SPI Controller 0 Pci Config
    Offset(302),    SC01, 64, // Offset(302),   SerialIo SPI Controller 1 Pci Config
    Offset(310),    SC02, 64, // Offset(310),   SerialIo SPI Controller 2 Pci Config
    Offset(318),    SC03, 64, // Offset(318),   SerialIo SPI Controller 3 Pci Config
    Offset(326),    SC04, 64, // Offset(326),   SerialIo SPI Controller 4 Pci Config
    Offset(334),    SC05, 64, // Offset(334),   SerialIo SPI Controller 5 Pci Config
    Offset(342),    SC06, 64, // Offset(342),   SerialIo SPI Controller 6 Pci Config
    Offset(350),    IM00, 8,  // Offset(350),   SerialIo I2C Controller 0 Mode
    Offset(351),    IM01, 8,  // Offset(351),   SerialIo I2C Controller 1 Mode
    Offset(352),    IM02, 8,  // Offset(352),   SerialIo I2C Controller 2 Mode
    Offset(353),    IM03, 8,  // Offset(353),   SerialIo I2C Controller 3 Mode
    Offset(354),    IM04, 8,  // Offset(354),   SerialIo I2C Controller 4 Mode
    Offset(355),    IM05, 8,  // Offset(355),   SerialIo I2C Controller 5 Mode
    Offset(356),    IM06, 8,  // Offset(356),   SerialIo I2C Controller 6 Mode
    Offset(357),    IM07, 8,  // Offset(357),   SerialIo I2C Controller 7 Mode
    Offset(358),    IC00, 64, // Offset(358),   SerialIo I2C Controller 0 Pci Config
    Offset(366),    IC01, 64, // Offset(366),   SerialIo I2C Controller 1 Pci Config
    Offset(374),    IC02, 64, // Offset(374),   SerialIo I2C Controller 2 Pci Config
    Offset(382),    IC03, 64, // Offset(382),   SerialIo I2C Controller 3 Pci Config
    Offset(390),    IC04, 64, // Offset(390),   SerialIo I2C Controller 4 Pci Config
    Offset(398),    IC05, 64, // Offset(398),   SerialIo I2C Controller 5 Pci Config
    Offset(406),    IC06, 64, // Offset(406),   SerialIo I2C Controller 6 Pci Config
    Offset(414),    IC07, 64, // Offset(414),   SerialIo I2C Controller 7 Pci Config
    Offset(422),    UM00, 8,  // Offset(422),   SerialIo UART Controller 0 Mode
    Offset(423),    UM01, 8,  // Offset(423),   SerialIo UART Controller 1 Mode
    Offset(424),    UM02, 8,  // Offset(424),   SerialIo UART Controller 2 Mode
    Offset(425),    UM03, 8,  // Offset(425),   SerialIo UART Controller 3 Mode
    Offset(426),    UM04, 8,  // Offset(426),   SerialIo UART Controller 4 Mode
    Offset(427),    UM05, 8,  // Offset(427),   SerialIo UART Controller 5 Mode
    Offset(428),    UM06, 8,  // Offset(428),   SerialIo UART Controller 6 Mode
    Offset(429),    UC00, 64, // Offset(429),   SerialIo UART Controller 0 Pci Config
    Offset(437),    UC01, 64, // Offset(437),   SerialIo UART Controller 1 Pci Config
    Offset(445),    UC02, 64, // Offset(445),   SerialIo UART Controller 2 Pci Config
    Offset(453),    UC03, 64, // Offset(453),   SerialIo UART Controller 3 Pci Config
    Offset(461),    UC04, 64, // Offset(461),   SerialIo UART Controller 4 Pci Config
    Offset(469),    UC05, 64, // Offset(469),   SerialIo UART Controller 5 Pci Config
    Offset(477),    UC06, 64, // Offset(477),   SerialIo UART Controller 6 Pci Config
    Offset(485),    UD00, 8,  // Offset(485),   SerialIo UART Controller 0 DmaEnable
    Offset(486),    UD01, 8,  // Offset(486),   SerialIo UART Controller 1 DmaEnable
    Offset(487),    UD02, 8,  // Offset(487),   SerialIo UART Controller 2 DmaEnable
    Offset(488),    UD03, 8,  // Offset(488),   SerialIo UART Controller 3 DmaEnable
    Offset(489),    UD04, 8,  // Offset(489),   SerialIo UART Controller 4 DmaEnable
    Offset(490),    UD05, 8,  // Offset(490),   SerialIo UART Controller 5 DmaEnable
    Offset(491),    UD06, 8,  // Offset(491),   SerialIo UART Controller 6 DmaEnable
    Offset(492),    UP00, 8,  // Offset(492),   SerialIo UART Controller 0 Power Gating
    Offset(493),    UP01, 8,  // Offset(493),   SerialIo UART Controller 1 Power Gating
    Offset(494),    UP02, 8,  // Offset(494),   SerialIo UART Controller 2 Power Gating
    Offset(495),    UP03, 8,  // Offset(495),   SerialIo UART Controller 3 Power Gating
    Offset(496),    UP04, 8,  // Offset(496),   SerialIo UART Controller 4 Power Gating
    Offset(497),    UP05, 8,  // Offset(497),   SerialIo UART Controller 5 Power Gating
    Offset(498),    UP06, 8,  // Offset(498),   SerialIo UART Controller 6 Power Gating
    Offset(499),    UI00, 8,  // Offset(499),   SerialIo UART Controller 0 Irq
    Offset(500),    UI01, 8,  // Offset(500),   SerialIo UART Controller 1 Irq
    Offset(501),    UI02, 8,  // Offset(501),   SerialIo UART Controller 2 Irq
    Offset(502),    UI03, 8,  // Offset(502),   SerialIo UART Controller 3 Irq
    Offset(503),    UI04, 8,  // Offset(503),   SerialIo UART Controller 4 Irq
    Offset(504),    UI05, 8,  // Offset(504),   SerialIo UART Controller 5 Irq
    Offset(505),    UI06, 8,  // Offset(505),   SerialIo UART Controller 6 Irq
    //end of SerialIo block
    Offset(506),    SGIR, 8,  // Offset(506),   GPIO IRQ
    Offset(507),    GPHD, 8,  // Offset(507),   Hide GPIO ACPI device
    Offset(508),    NIT1, 8,  // Offset(508),   RST PCIe Storage Cycle Router#1 Interface Type
    Offset(509),    NIT2, 8,  // Offset(509),   RST PCIe Storage Cycle Router#2 Interface Type
    Offset(510),    NIT3, 8,  // Offset(510),   RST PCIe Storage Cycle Router#3 Interface Type
    Offset(511),    NPM1, 8,  // Offset(511),   RST PCIe Storage Cycle Router#1 Power Management Capability Pointer
    Offset(512),    NPM2, 8,  // Offset(512),   RST PCIe Storage Cycle Router#2 Power Management Capability Pointer
    Offset(513),    NPM3, 8,  // Offset(513),   RST PCIe Storage Cycle Router#3 Power Management Capability Pointer
    Offset(514),    NPC1, 8,  // Offset(514),   RST PCIe Storage Cycle Router#1 PCIe Capabilities Pointer
    Offset(515),    NPC2, 8,  // Offset(515),   RST PCIe Storage Cycle Router#2 PCIe Capabilities Pointer
    Offset(516),    NPC3, 8,  // Offset(516),   RST PCIe Storage Cycle Router#3 PCIe Capabilities Pointer
    Offset(517),    NL11, 16, // Offset(517),   RST PCIe Storage Cycle Router#1 L1SS Capability Pointer
    Offset(519),    NL12, 16, // Offset(519),   RST PCIe Storage Cycle Router#2 L1SS Capability Pointer
    Offset(521),    NL13, 16, // Offset(521),   RST PCIe Storage Cycle Router#3 L1SS Capability Pointer
    Offset(523),    ND21, 8,  // Offset(523),   RST PCIe Storage Cycle Router#1 Endpoint L1SS Control Data2
    Offset(524),    ND22, 8,  // Offset(524),   RST PCIe Storage Cycle Router#2 Endpoint L1SS Control Data2
    Offset(525),    ND23, 8,  // Offset(525),   RST PCIe Storage Cycle Router#3 Endpoint L1SS Control Data2
    Offset(526),    ND11, 32, // Offset(526),   RST PCIe Storage Cycle Router#1 Endpoint L1SS Control Data1
    Offset(530),    ND12, 32, // Offset(530),   RST PCIe Storage Cycle Router#2 Endpoint L1SS Control Data1
    Offset(534),    ND13, 32, // Offset(534),   RST PCIe Storage Cycle Router#3 Endpoint L1SS Control Data1
    Offset(538),    NLR1, 16, // Offset(538),   RST PCIe Storage Cycle Router#1 LTR Capability Pointer
    Offset(540),    NLR2, 16, // Offset(540),   RST PCIe Storage Cycle Router#2 LTR Capability Pointer
    Offset(542),    NLR3, 16, // Offset(542),   RST PCIe Storage Cycle Router#3 LTR Capability Pointer
    Offset(544),    NLD1, 32, // Offset(544),   RST PCIe Storage Cycle Router#1 Endpoint LTR Data
    Offset(548),    NLD2, 32, // Offset(548),   RST PCIe Storage Cycle Router#2 Endpoint LTR Data
    Offset(552),    NLD3, 32, // Offset(552),   RST PCIe Storage Cycle Router#3 Endpoint LTR Data
    Offset(556),    NEA1, 16, // Offset(556),   RST PCIe Storage Cycle Router#1 Endpoint LCTL Data
    Offset(558),    NEA2, 16, // Offset(558),   RST PCIe Storage Cycle Router#2 Endpoint LCTL Data
    Offset(560),    NEA3, 16, // Offset(560),   RST PCIe Storage Cycle Router#3 Endpoint LCTL Data
    Offset(562),    NEB1, 16, // Offset(562),   RST PCIe Storage Cycle Router#1 Endpoint DCTL Data
    Offset(564),    NEB2, 16, // Offset(564),   RST PCIe Storage Cycle Router#2 Endpoint DCTL Data
    Offset(566),    NEB3, 16, // Offset(566),   RST PCIe Storage Cycle Router#3 Endpoint DCTL Data
    Offset(568),    NEC1, 16, // Offset(568),   RST PCIe Storage Cycle Router#1 Endpoint DCTL2 Data
    Offset(570),    NEC2, 16, // Offset(570),   RST PCIe Storage Cycle Router#2 Endpoint DCTL2 Data
    Offset(572),    NEC3, 16, // Offset(572),   RST PCIe Storage Cycle Router#3 Endpoint DCTL2 Data
    Offset(574),    NRA1, 16, // Offset(574),   RST PCIe Storage Cycle Router#1 RootPort DCTL2 Data
    Offset(576),    NRA2, 16, // Offset(576),   RST PCIe Storage Cycle Router#2 RootPort DCTL2 Data
    Offset(578),    NRA3, 16, // Offset(578),   RST PCIe Storage Cycle Router#3 RootPort DCTL2 Data
    Offset(580),    NMB1, 32, // Offset(580),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X Table BAR
    Offset(584),    NMB2, 32, // Offset(584),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X Table BAR
    Offset(588),    NMB3, 32, // Offset(588),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X Table BAR
    Offset(592),    NMV1, 32, // Offset(592),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X Table BAR value
    Offset(596),    NMV2, 32, // Offset(596),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X Table BAR value
    Offset(600),    NMV3, 32, // Offset(600),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X Table BAR value
    Offset(604),    NPB1, 32, // Offset(604),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X PBA BAR
    Offset(608),    NPB2, 32, // Offset(608),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X PBA BAR
    Offset(612),    NPB3, 32, // Offset(612),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X PBA BAR
    Offset(616),    NPV1, 32, // Offset(616),   RST PCIe Storage Cycle Router#1 Endpoint unique MSI-X PBA BAR value
    Offset(620),    NPV2, 32, // Offset(620),   RST PCIe Storage Cycle Router#2 Endpoint unique MSI-X PBA BAR value
    Offset(624),    NPV3, 32, // Offset(624),   RST PCIe Storage Cycle Router#3 Endpoint unique MSI-X PBA BAR value
    Offset(628),    NRP1, 32, // Offset(628),   RST PCIe Storage Cycle Router#1 Root Port number
    Offset(632),    NRP2, 32, // Offset(632),   RST PCIe Storage Cycle Router#2 Root Port number
    Offset(636),    NRP3, 32, // Offset(636),   RST PCIe Storage Cycle Router#3 Root Port number
    Offset(640),    EMH4, 8,  // Offset(640),   eMMC HS400 mode enabled
    Offset(641),    EMDS, 8,  // Offset(641),   eMMC Driver Strength
    Offset(642),    CSKU, 8,  // Offset(642),   CPU SKU
    Offset(643),    ITA0, 16, // Offset(643),
    Offset(645),    ITA1, 16, // Offset(645),
    Offset(647),    ITA2, 16, // Offset(647),
    Offset(649),    ITA3, 16, // Offset(649),
    Offset(651),    ITS0, 8,  // Offset(651),
    Offset(652),    ITS1, 8,  // Offset(652),
    Offset(653),    ITS2, 8,  // Offset(653),
    Offset(654),    ITS3, 8,  // Offset(654),
    Offset(655),    PMBS, 16, // Offset(655),   ACPI IO BASE address
    Offset(657),    PWRM, 32, // Offset(657),   PWRM MEM BASE address
    // CNVi specific
    Offset(661),    CNVI, 8,  // Offset(661),   CNVi mode
    Offset(662),    CBTC, 8,  // Offset(662),   CNVi BT Core
    Offset(663),    CBTA, 8,  // Offset(663),   CNVi BT Audio Offload
    Offset(664),    CVPR, 8,  // Offset(664),   CNVi vPro
    Offset(665),    CRFI, 8,  // Offset(665),   CNVi DDR RFI Mitigation
    Offset(666),    CRFP, 8,  // Offset(666),   CNVi CRF present
    // PCH Trace Hub
    Offset(667),    PTHM, 8,  // Offset(667),   PCH Trace Hub Mode
    // PCH PS_ON support
    Offset(668),    PSON, 8,  // Offset(668),   PCH PS_ON enable
    //
    // These are for PchApciTablesSelfTest use
    //
    Offset(669),    LTR1, 8,  // Offset(669),   Latency Tolerance Reporting Enable
    Offset(670),    LTR2, 8,  // Offset(670),   Latency Tolerance Reporting Enable
    Offset(671),    LTR3, 8,  // Offset(671),   Latency Tolerance Reporting Enable
    Offset(672),    LTR4, 8,  // Offset(672),   Latency Tolerance Reporting Enable
    Offset(673),    LTR5, 8,  // Offset(673),   Latency Tolerance Reporting Enable
    Offset(674),    LTR6, 8,  // Offset(674),   Latency Tolerance Reporting Enable
    Offset(675),    LTR7, 8,  // Offset(675),   Latency Tolerance Reporting Enable
    Offset(676),    LTR8, 8,  // Offset(676),   Latency Tolerance Reporting Enable
    Offset(677),    LTR9, 8,  // Offset(677),   Latency Tolerance Reporting Enable
    Offset(678),    LTRA, 8,  // Offset(678),   Latency Tolerance Reporting Enable
    Offset(679),    LTRB, 8,  // Offset(679),   Latency Tolerance Reporting Enable
    Offset(680),    LTRC, 8,  // Offset(680),   Latency Tolerance Reporting Enable
    Offset(681),    LTRD, 8,  // Offset(681),   Latency Tolerance Reporting Enable
    Offset(682),    LTRE, 8,  // Offset(682),   Latency Tolerance Reporting Enable
    Offset(683),    LTRF, 8,  // Offset(683),   Latency Tolerance Reporting Enable
    Offset(684),    LTRG, 8,  // Offset(684),   Latency Tolerance Reporting Enable
    Offset(685),    LTRH, 8,  // Offset(685),   Latency Tolerance Reporting Enable
    Offset(686),    LTRI, 8,  // Offset(686),   Latency Tolerance Reporting Enable
    Offset(687),    LTRJ, 8,  // Offset(687),   Latency Tolerance Reporting Enable
    Offset(688),    LTRK, 8,  // Offset(688),   Latency Tolerance Reporting Enable
    Offset(689),    LTRL, 8,  // Offset(689),   Latency Tolerance Reporting Enable
    Offset(690),    LTRM, 8,  // Offset(690),   Latency Tolerance Reporting Enable
    Offset(691),    LTRN, 8,  // Offset(691),   Latency Tolerance Reporting Enable
    Offset(692),    LTRO, 8,  // Offset(692),   Latency Tolerance Reporting Enable
    Offset(693),    LTRP, 8,  // Offset(693),   Latency Tolerance Reporting Enable
    Offset(694),    LTRQ, 8,  // Offset(694),   Latency Tolerance Reporting Enable
    Offset(695),    LTRR, 8,  // Offset(695),   Latency Tolerance Reporting Enable
    Offset(696),    LTRS, 8,  // Offset(696),   Latency Tolerance Reporting Enable
    Offset(697),    GBES, 8,  // Offset(697),   GbE Support
    Offset(698),    PPDS, 32, // Offset(698),   PCH xDCI Power Down Scale Value, DWC_USB3_GCTL_INIT[31:19]
    Offset(702),    EMCE, 8,  // Offset(702),   Set to indicate that eMMC is enabled
    Offset(703),    SDCE, 8,  // Offset(703),   Set to indicate that SD card is enabled
    Offset(704),    TGEA, 8,  // Offset(704),   Set to indicate that Timed GPIO 0 is enabled
    Offset(705),    TGEB, 8,  // Offset(705),   Set to indicate that Timed GPIO 1 is enabled
    Offset(706),    CR00, 8,  // Offset(706),   CLOCK index to root port index map. Used during PCIe D3Cold flows
    Offset(707),    CR01, 8,  // Offset(707),
    Offset(708),    CR02, 8,  // Offset(708),
    Offset(709),    CR03, 8,  // Offset(709),
    Offset(710),    CR04, 8,  // Offset(710),
    Offset(711),    CR05, 8,  // Offset(711),
    Offset(712),    CR06, 8,  // Offset(712),
    Offset(713),    CR07, 8,  // Offset(713),
    Offset(714),    CR08, 8,  // Offset(714),
    Offset(715),    CR09, 8,  // Offset(715),
    Offset(716),    CR10, 8,  // Offset(716),
    Offset(717),    CR11, 8,  // Offset(717),
    Offset(718),    CR12, 8,  // Offset(718),
    Offset(719),    CR13, 8,  // Offset(719),
    Offset(720),    CR14, 8,  // Offset(720),
    Offset(721),    CR15, 8,  // Offset(721),
    Offset(722),    CR16, 8,  // Offset(722),
    Offset(723),    CR17, 8,  // Offset(723),
    Offset(724),    TCOB, 16, // Offset(724),   TCO base address
    Offset(726),    ICKP, 16, // Offset(726),   Iclk PID number
    Offset(728),    PCNV, 16, // Offset(728),   CNVi sideband port id
    Offset(730),    HBSL, 32, // Offset(730),
    Offset(734),    PU2C, 8,  // Offset(734),   Number of USB2 ports in PCH
    Offset(735),    PU3C, 8,  // Offset(735),   Number of USB3 ports in PCH
    Offset(736),    SPPR, 8,  // Offset(736),   Holds information from SATA PCS register about SATA ports which recieved COMINIT from connected devices.
    Offset(737),    IPCC, 8,  // Offset(737),   PCIE CLKREQ IPC command support
    Offset(738),    CQ00, 8,  // Offset(738),   CLOCK Source index to ClkReq Number. Used during PCIe D3Cold flows
    Offset(739),    CQ01, 8,  // Offset(739),
    Offset(740),    CQ02, 8,  // Offset(740),
    Offset(741),    CQ03, 8,  // Offset(741),
    Offset(742),    CQ04, 8,  // Offset(742),
    Offset(743),    CQ05, 8,  // Offset(743),
    Offset(744),    CQ06, 8,  // Offset(744),
    Offset(745),    CQ07, 8,  // Offset(745),
    Offset(746),    CQ08, 8,  // Offset(746),
    Offset(747),    CQ09, 8,  // Offset(747),
    Offset(748),    CQ10, 8,  // Offset(748),
    Offset(749),    CQ11, 8,  // Offset(749),
    Offset(750),    CQ12, 8,  // Offset(750),
    Offset(751),    CQ13, 8,  // Offset(751),
    Offset(752),    CQ14, 8,  // Offset(752),
    Offset(753),    CQ15, 8,  // Offset(753),
    Offset(754),    CQ16, 8,  // Offset(754),
    Offset(755),    CQ17, 8,  // Offset(755),
    Offset(756),    TIN0, 32, // Offset(756),   Touch Host Controller Wake On Touch Interrupt Number - when 0 wake is disabled
    Offset(760),    TIN1, 32, // Offset(760),
    Offset(764),    TMD0, 16, // Offset(764),   Touch Host Controller Mode THC or HID over SPI
    Offset(766),    TMD1, 16, // Offset(766),
    Offset(768),    UF0E, 8,  // Offset(768),   Is UFS0 Enabled
    Offset(769),    UF1E, 8,  // Offset(769),   Is UFS1 Enabled
    Offset(770),    UAOE, 8,  // Offset(770),   Is USB Audio Offload enabled
    Offset(771),    T010, 32, // Offset(771),   Touch Host Controller HID over SPI Reset Pad
    Offset(775),    T011, 32, // Offset(775),
    Offset(779),    T020, 8,  // Offset(779),   Touch Host Controller HID over SPI Reset Pad Trigger
    Offset(780),    T021, 8,  // Offset(780),
    Offset(781),    T030, 32, // Offset(781),   Touch Host Controller HID over SPI Frequency
    Offset(785),    T031, 32, // Offset(785),
    Offset(789),    T040, 32, // Offset(789),   Touch Host Controller HID over SPI Input Report Header Address
    Offset(793),    T041, 32, // Offset(793),
    Offset(797),    T050, 32, // Offset(797),   Touch Host Controller HID over SPI Input Report Body Address
    Offset(801),    T051, 32, // Offset(801),
    Offset(805),    T060, 32, // Offset(805),   Touch Host Controller HID over SPI Output Report Address
    Offset(809),    T061, 32, // Offset(809),
    Offset(813),    T070, 32, // Offset(813),   Touch Host Controller HID over SPI Read Opcode
    Offset(817),    T071, 32, // Offset(817),
    Offset(821),    T080, 32, // Offset(821),   Touch Host Controller HID over SPI Write Opcode
    Offset(825),    T081, 32, // Offset(825),
    Offset(829),    T090, 32, // Offset(829),   Touch Host Controller HID over SPI Flags
    Offset(833),    T091, 32, // Offset(833),
    Offset(837),    T0A0, 32, // Offset(837),   Touch Host Controller Active Ltr
    Offset(841),    T0A1, 32, // Offset(841),
    Offset(845),    T0B0, 32, // Offset(845),   Touch Host Controller Idle Ltr
    Offset(849),    T0B1, 32, // Offset(849),
    Offset(853),    HBCL, 32, // Offset(853),   Cpu Root port used for hybrid storage
    Offset(857),    HBPL, 32, // Offset(857),   Pch Root port used for hybrid storage
    Offset(861),    AL6D, 32, // Offset(861),   _L6D Enable, BIOS-ACPI can verify PMEENABLE and PMESTATUS of each device that requires GPE related wake
    }

  
  //
  // Include GPIO macros and access library
  //
  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  //
  // Definition for MSPDRTREQ bits, which are used for ASL code to
  // trigger requests for ModPHY SPD gating.
  //
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  #line 4291 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"

  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  External(SIME)
  
  //
  // HSIO Library
  Scope(\_SB) {
    //
    // PCIe root port modPHY power gating enable
    // Arg0 - Index of PCIe root port(1 - based)
    //
    Method(PSD3, 1, Serialized) {
      Store(0, Local0) //Time check counter variable
  
      If (LOr (LEqual (SIME, 1), LNot(IMPS()))) {
        Return ()
      }
      Switch(Add(0, Decrement(Arg0))) {
        Case (0) {
          Store(1, RAA0)
          While (LAnd(Lequal(APA0, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (1) {
          Store(1, RAA1)
          While (LAnd(Lequal(APA1, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (2) {
          Store(1, RAA2)
          While (LAnd(Lequal(APA2, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (3) {
          Store(1, RAA3)
          While (LAnd(Lequal(APA3, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (4) {
          Store(1, RPB0)
          While (LAnd(Lequal(APB0, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (5) {
          Store(1, RPB1)
          While (LAnd(Lequal(APB1, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (6) {
          Store(1, RPB2)
          While (LAnd(Lequal(APB2, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (7) {
          Store(1, RPB3)
          While (LAnd(Lequal(APB3, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (8) {
          Store(1, RPC0)
          While (LAnd(Lequal(APC0, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (9) {
          Store(1, RPC1)
          While (LAnd(Lequal(APC1, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (10) {
          Store(1, RPC2)
          While (LAnd(Lequal(APC2, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (11) {
          Store(1, RPC3)
          While (LAnd(Lequal(APC3, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (12) {
          Store(1, RPD0)
          While (LAnd(Lequal(APD0, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (13) {
          Store(1, RPD1)
          While (LAnd(Lequal(APD1, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (14) {
          Store(1, RPD2)
          While (LAnd(Lequal(APD2, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (15) {
          Store(1, RPD3)
          While (LAnd(Lequal(APD3, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (16) {
          Store(1, RPE0)
          While (LAnd(Lequal(APE0, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (17) {
          Store(1, RPE1)
          While (LAnd(Lequal(APE1, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (18) {
          Store(1, RPE2)
          While (LAnd(Lequal(APE2, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (19) {
          Store(1, RPE3)
          While (LAnd(Lequal(APE3, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
      }
      If(LGreaterEqual(Local0, 10000)) {
        ADBG("Error: Timeout occurred")
      }
    }
  
    //
    // PCIe root port modPHY power gating disable
    // Arg0 - Index of PCIe root port(1 - based)
    //
    Method(PSD0, 1, Serialized) {
      Store(0, Local0) //Time check counter variable
  
      If (LOr (LEqual (SIME, 1), LNot(IMPS()))) {
        Return ()
      }
  
      Switch(Add(0, Decrement(Arg0))) {
        Case (0) {
          Store(0, RAA0)
          While (LAnd(Lequal(APA0, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (1) {
          Store(0, RAA1)
          While (LAnd(Lequal(APA1, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (2) {
          Store(0, RAA2)
          While (LAnd(Lequal(APA2, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (3) {
          Store(0, RAA3)
          While (LAnd(Lequal(APA3, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (4) {
          Store(0, RPB0)
          While (LAnd(Lequal(APB0, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (5) {
          Store(0, RPB1)
          While (LAnd(Lequal(APB1, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (6) {
          Store(0, RPB2)
          While (LAnd(Lequal(APB2, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (7) {
          Store(0, RPB3)
          While (LAnd(Lequal(APB3, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (8) {
          Store(0, RPC0)
          While (LAnd(Lequal(APC0, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (9) {
          Store(0, RPC1)
          While (LAnd(Lequal(APC1, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (10) {
          Store(0, RPC2)
          While (LAnd(Lequal(APC2, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (11) {
          Store(0, RPC3)
          While (LAnd(Lequal(APC3, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (12) {
          Store(0, RPD0)
          While (LAnd(Lequal(APD0, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (13) {
          Store(0, RPD1)
          While (LAnd(Lequal(APD1, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (14) {
          Store(0, RPD2)
          While (LAnd(Lequal(APD2, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (15) {
          Store(0, RPD3)
          While (LAnd(Lequal(APD3, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (16) {
          Store(0, RPE0)
          While (LAnd(Lequal(APE0, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (17) {
          Store(0, RPE1)
          While (LAnd(Lequal(APE1, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (18) {
          Store(0, RPE2)
          While (LAnd(Lequal(APE2, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (19) {
          Store(0, RPE3)
          While (LAnd(Lequal(APE3, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
      }
      If(LGreaterEqual(Local0, 10000)) {
        ADBG("Error: Timeout occurred")
      }
    }
  
    //
    //Controller SPD D3 Method
    //
    // This method sets the appropriate R_CNL_PCH_PWRM_MODPHY_PM_CFG5[MSPDRTREQ],
    // Setting the MSPDRTREQ bit for a controller implies that ASL code provides consent for
    // SPD to be gated for the corresponding controller's lanes (PMC will gate SPD for the
    // corresponding controller's lanes).
    //
    // Arg0 - PCH Controller ENUM
    //
    Method(CSD3, 1, Serialized) {
      Store(0, Local0) //Time check counter variable
  
      If (LOr (LEqual (SIME, 1), LNot(IMPS()))) {
        Return ()
      }
  
      Switch (ToInteger(arg0)) {
        Case (20) {
          Store(1, RSAT)
          While (LAnd(Lequal(ASAT, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (21) {
          Store(1, RGBE)
          While (LAnd(Lequal(AGBE, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (22) {
          Store(1, RXHC)
          While (LAnd(Lequal(AXHC, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (23) {
          Store(1, RXDC)
          While (LAnd(Lequal(AXDC, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (24) {
          Store(1, RUFS)
          While (LAnd(Lequal(AUFS, 0), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
      }
      If(LGreaterEqual(Local0, 10000)) {
        ADBG("Error: Timeout occurred")
      }
    }
  
    //
    // Controller SPD D0 Method
    //
    // This method clears the appropriate R_CNL_PCH_PWRM_MODPHY_PM_CFG5[MSPDRTREQ],
    // Clearing the MSPDRTREQ bit for a controller implies that ASL code does not provide
    // consent for SPD to be gated for the corresponding controller's lanes (PMC will "un-gate"
    // SPD for the corresponding controller's lanes).
    //
    // Arg0 - PCH Controller ENUM
    //
    Method(CSD0, 1, Serialized) {
      Store(0, Local0) //Time check counter variable
  
      If (LOr (LEqual (SIME, 1), LNot(IMPS()))) {
        Return ()
      }
  
      Switch (ToInteger(arg0)) {
        Case (20) {
          Store(0, RSAT)
          While (LAnd(Lequal(ASAT, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (21) {
          Store(0, RGBE)
          While (LAnd(Lequal(AGBE, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (22) {
          Store(0, RXHC)
          While (LAnd(Lequal(AXHC, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (23) {
          Store(0, RXDC)
          While (LAnd(Lequal(AXDC, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
        Case (24) {
          Store(0, RUFS)
          While (LAnd(Lequal(AUFS, 1), LLess(Local0, 10000))) {
            Increment(Local0)
            Sleep(1)
          }
        }
      }
      If(LGreaterEqual(Local0, 10000)) {
        ADBG("Error: Timeout occurred")
      }
    }
  }
  

  
  //
  // Trace Hub debug library
  // Include it earlier so the debug function can be used as soon as possible
  //
  /**@file
   Trace Hub debug library for ASL code.
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchReservedResources.h"
/** @file
  PCH preserved MMIO resource definitions.

  Copyright (c) 2020 - 2022, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/





/**
  Detailed recommended static allocation
  +-------------------------------------------------------------------------------+
  | PCH preserved MMIO range, 16 MB, from 0xFD800000 to 0xFE7FFFFF                |
  +-------------------------------------------------------------------------------+
  | Size        | Start       | End         | Usage                               |
  | 8 MB        | 0xFD800000  | 0xFDFFFFFF  | TraceHub SW BAR                     |
  | 64 KB       | 0xFE000000  | 0xFE00FFFF  | PMC MBAR                            |
  | 4 KB        | 0xFE010000  | 0xFE010FFF  | SPI BAR0                            |
  | 176 KB      | 0xFE020000  | 0xFE04BFFF  | SerialIo BAR in ACPI mode           |
  | 400 KB      | 0xFE04C000  | 0xFE0AFFFF  | Unused                              |
  | 64 KB       | 0xFE0B0000  | 0xFE0BFFFF  | eSPI LGMR BAR                       |
  | 64 KB       | 0xFE0C0000  | 0xFE0CFFFF  | eSPI2 SEGMR BAR                     |
  | 192 KB      | 0xFE0D0000  | 0xFE0FFFFF  | Unused                              |
  | 1 MB        | 0xFE100000  | 0xFE1FFFFF  | TraceHub MTB BAR                    |
  | 2 MB        | 0xFE200000  | 0xFE3FFFFF  | TraceHub FW BAR                     |
  | 2 MB        | 0xFE400000  | 0xFE5FFFFF  | Unused                              |
  | 2 MB        | 0xFE600000  | 0xFE7FFFFF  | Temp address                        |
  +-------------------------------------------------------------------------------+
  | SBREG MMIO range                                                              |
  +-------------------------------------------------------------------------------+
  | 16 MB OR    | 0xE0000000  | 0xE0FFFFFF  | SBREG                               |
  | 256 MB      | 0xE0000000  | 0xEFFFFFFF  | SBREG_EX (SBREG_BAR_20BITADDRESS=1) |
  +-------------------------------------------------------------------------------+
**/




#line 43 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchReservedResources.h"



#line 47 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchReservedResources.h"










#line 58 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchReservedResources.h"

#line 60 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchReservedResources.h"
#line 4753 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  External(PTHM, FieldUnitObj)
  External(\_SB.PC00.PTHT.THEN, MethodObj, IntObj)
  External(\_SB.PTHH.THEN, MethodObj, IntObj)
  
  Name (THMN, 0x48)  // Host number should align with gSiPkgTokenSpaceGuid.PcdTraceHubDebugLibMaster
  Name (THCN, 0x0E)  // Channel number could be different from gSiPkgTokenSpaceGuid.PcdTraceHubDebugLibChannel, 0~80h are available
  Name (CNPM, 0x80)  // Channel number per Host
  Name (FMSN, 0x10)  // Firmware Host start number
  
  Scope(\) {
    // Trace Hub debug address
    // This is internal helper runtine of THDS
    // Arg0 : Host number
    // Arg1 : Channel number
    Method (THDA, 2, Serialized) {
      // Local0 = PCH_TRACE_HUB_FW_BASE_ADDRESS + 0x40 * (V_TRACE_HUB_MEM_MTB_CHLCNT * (Master - V_TRACE_HUB_MEM_MTB_FTHMSTR)) + 0x40 * Channel;
      Store (0xFE200000, Local0)
      Add (Local0, Multiply (0x40, Multiply (CNPM, Subtract (Arg0, FMSN))), Local0)
      Add (Local0, Multiply (0x40, Arg1), Local0)
      Return (Local0)
    }
  
    // String to raw data
    // This is internal helper runtine of THDS
    // Arg0 : string
    // Arg1 : Index
    // Arg2 : size
    Method (STRD, 3, Serialized) {
      If (LGreater (Add (Arg1, Arg2), SizeOf (Arg0))) {
        Return (0)
      }
      // Local0 is return value
      // Lccal1 is loop index
      // Local2 is char of string
      // Local3 is buffer of string
      ToBuffer (Arg0, Local3)
      Store (0, Local0)
      Store (0, Local1)
      While (LLess (Local1, Arg2)) {
        Store (DeRefOf (Index (Local3, Add (Arg1, Local1))), Local2)
        Add (Local0, ShiftLeft (Local2, Multiply (8, Local1)), Local0)
        Increment (Local1)
      }
      Return (Local0)
    }
  
    // Trace Hub debug string
    // Arg0 : debug string
    Method (THDS, 1, Serialized) {
     //
     // Check if BIOS trace is enabled.
     //
     If (LEqual (PTHM, 0)) {
       Return
     } ElseIf (LEqual (PTHM, 1)) {
       If (LNot (\_SB.PC00.PTHT.THEN())) {
         Return
       }
     } ElseIf (LEqual (PTHM, 2)) {
       If (LNot (\_SB.PTHH.THEN())) {
         Return
       }
     } Else {
       Return
     }
      // Adding newline at the end of the string
      Concatenate (Arg0, "\n", local2)
      // Local0 is the length of string
      // Local1 is the debug base address
      // Local2 is the debug string with "\n"
      Store (Sizeof (local2), Local0)
      Store (THDA (THMN, THCN), Local1)
      OperationRegion (THBA, SystemMemory, local1, 0x40)
      Field (THBA, QWordAcc, NoLock, Preserve) {
        Offset (0x00),
        QO00, 64,
      }
      Field (THBA, DWordAcc, NoLock, Preserve) {
        Offset (0x00),
        DO00, 32,
        Offset (0x10),
        DO10, 32,
        offset (0x30),
        DO30, 32,
      }
      Field (THBA, WordAcc, NoLock, Preserve) {
        Offset (0x00),
        WO00, 16,
      }
      Field (THBA, ByteAcc, NoLock, Preserve) {
        Offset (0x00),
        BO00, 8,
      }
  
      // time stamp
      Store (0x01000242, DO10)
      // length of string
      Store (Local0, WO00)
      // string
      Store (0, Local6)
      Store (Local0, Local7)
      while (LGreaterEqual(Local7, 8)) {
        Store (STRD (local2, Local6, 8), QO00)
        Add (Local6, 8, Local6)
        Subtract (Local7, 8, Local7)
      }
      If (LGreaterEqual(Local7, 4)) {
        Store (STRD (local2, Local6, 4), DO00)
        Add (Local6, 4, Local6)
        Subtract (Local7, 4, Local7)
      }
      If (LGreaterEqual(Local7, 2)) {
        Store (STRD (local2, Local6, 2), WO00)
        Add (Local6, 2, Local6)
        Subtract (Local7, 2, Local7)
      }
      If (LGreaterEqual(Local7, 1)) {
        Store (STRD (local2, Local6, 1), BO00)
        Add (Local6, 1, Local6)
        Subtract (Local7, 1, Local7)
      }
      // flag
      Store (0, DO30)
    }
  
    // Trace Hub debug Hex string
    // Arg0 : Integer, buffer
    Method (THDH, 1, Serialized) {
      THDS (ToHexString (Arg0))
    }
  
    // Trace Hub debug decimal string
    // Arg0 : Integer, buffer
    Method (THDD, 1, Serialized) {
      THDS (ToDecimalString (Arg0))
    }
  }

  
  Name(PCHH,1)  // PCH H
  Name(PCHN,3)  // PCH N
  Name(PCHL,2) // PCH LP
  Name(PCHP,5)  // PCH P
  Name(PCHM,6)  // PCH M
  Name(PCHX,4)  // PCH S
  
  
  //
  // PME event (PCH's GPE 6Dh) is received when any PCH internal device with
  // PCI Power Management capabilities on bus 0 asserts the equivalent of the PME# signal.
  // Dedicated _L6D method is not needed if its only purpose is to notify the device.
  // Instead to properly handle this GPE event below requirements need to be fulfilled
  // - _PRW for GPE 6Dh in devices capable of generating PME (XHCI, XDCI, GbE, HDA)
  // - _S0W(3) and _DSW is present within those devices
  
  Scope (\_SB) {
    //
    // PCH RC _WAK handler
    // This method should be called from _WAK function
    // to perform necessary PCH actions upon wake
    //
    Method(PWAK, 1) {
      //
      // Arg0 - sleeping state (1 for S1, 2 for S2, etc.)
      //
      //
      // On S3 resume call S0i2/3 wake handler
      //
      If (LEqual (Arg0, 3)) {
        S23W()
      }
    }
  
    //
    // PCH S0i2/3 dynamic switching
    //
    // 0: Device inactive
    // 1: Device active
    // 2: Device statically disabled
    //
    Name (HDAA, 1)    // HD Audio Active state flag
    Name (DISA, 1)    // Display Active state flag
    Name (CIWF, 1)    // CNVi WiFi Active state flag
    Name (CIBT, 1)    // CNVi BT Active state flag
    Name (S23C, 0)    // Flag indicating if function was called and static disabling was taken into account
  
   //
   // This method should be called upon resume from S3 state
   // from _WAK method to reinitialize device state variables
   // that impact S0i2/S0i3 flow
   //
    Method(S23W, 0) {
      //
      // Upon wake from S3 reinitialize state variables to default
      // which is also safe config and one that is left after BIOS boot
      //
      Store (1, HDAA)
      Store (1, DISA)
      Store (1, CIWF)
      Store (1, CIBT)
    }
  
    //
    // PCH reserved resources
    //
    Device(PRRE) {
      Name(_HID,EISAID("PNP0C02")) // motherboard resource
      Name(_UID,"PCHRESV")
      Name(_STA,0x8) // device present and decodes its resources, but not to be displayed in OSPM
  
      Method(_CRS,0,Serialized)
      {
        Name(BUF0,ResourceTemplate(){
          //
          // PCH RESERVED MMIO RANGE
          // Refer to PchReservedResources.h for ranges used by PCH
          //
          // skip over address range that might be claimed by the Intel Serial IO, and TraceHub
          // The SerialIO ranges will be handled by SIRC device.
          // skip 0xFC800000 - 0xFCFFFFFF for PCH Trace Hub : SW BAR space
          // skip 0xFD800000 - 0xFDFFFFFF for PCH Trace Hub : SW BAR space (ADL)
          Memory32Fixed (ReadWrite, 0xFE000000, 0x00020000) // 0xFE000000 - 0xFE01FFFF
          // Skip 0xFE020000 - 0xFE04BFFF for Serial IO
          Memory32Fixed (ReadWrite, 0xFE04C000, 0x00004000) // 0xFE04C000 - 0xFE04FFFF
          Memory32Fixed (ReadWrite, 0xFE050000, 0x00060000) // 0xFE050000 - 0xFE0AFFFF
          // Skip 0xFE0B0000 - 0xFE0CFFFF for eSPI
          Memory32Fixed (ReadWrite, 0xFE0D0000, 0x00030000) // 0xFE0D0000 - 0xFE0FFFFF
          // skip 0xFE100000 - 0xFE1FFFFF for PCH Trace Hub : MTB BAR space
          Memory32Fixed (ReadWrite, 0xFE200000, 0x00600000) // 0xFE200000 - 0xFE7FFFFF
          // BIOS decoding range. Assume it's always 16MB.
          Memory32Fixed (ReadOnly, 0xFF000000, 0x1000000)
  
          // ACPI Base
          IO (Decode16,0,0,0x1,0xFF,ABAR)
        })
        // Update ACPI IO region
        CreateWordField (BUF0, ABAR._MIN,AMIN)
        CreateWordField (BUF0, ABAR._MAX,AMAX)
        Store (PMBS, AMIN)
        Store (PMBS, AMAX)
  
        //
        // Claim SBREG_MMIO range except for some GPIO communities which are used by GPIO OS driver, refer to Gpio.asl
        //
        // PID_GPIOCOM0 = 0x6E
        // PID_GPIOCOM1 = 0x6D
        // PID_GPIOCOM2 = 0x6C
        // PID_GPIOCOM3 = 0x6B
        // PID_GPIOCOM4 = 0x6A
        // PID_GPIOCOM5 = 0x69
        //
        // claim region from SBREG_BASE to first GPIO community claimed by GPIO driver.
        //
        Name(SBR0, ResourceTemplate(){ Memory32Fixed (ReadWrite, 0x0, 0x00690000, SBRR) })
        CreateDWordField (SBR0, SBRR._BAS, BAS0)
        Store (SBRG, BAS0)
        ConcatenateResTemplate(BUF0, SBR0, Local0)
        //
        // claim GPIO communities that GPIO driver does not use.
        //
  
  
        If (LOr (LEqual (PCHS, PCHH), LEqual (PCHS, 4))) {
          //
          // claim GPIO COM2
          //
          Name (SBRS, ResourceTemplate () {Memory32Fixed (ReadWrite, 0x0, 0x0, SBSA) })         // Community 2
          CreateDWordField (SBRS, SBSA._BAS, BAS1)
          CreateDWordField (SBRS, SBSA._LEN, LEN1)
          Store (Add (SBRG, 0x006c0000), BAS1)
          Store (0x10000, LEN1)
          ConcatenateResTemplate (Local0, SBRS, Local1)
        } Else {
          //
          // claim GPIO COM2 & COM3
          //
          Name (SBRL, ResourceTemplate () {Memory32Fixed (ReadWrite, 0x0, 0x0, SBSB) })       // Community 2, 3
          CreateDWordField (SBRL, SBSB._BAS, BAS2)
          CreateDWordField (SBRL, SBSB._LEN, LEN2)
          Store(Add (SBRG, 0x006b0000), BAS2)
          Store(Multiply (0x10000, 2), LEN2)
          ConcatenateResTemplate(Local0, SBRL, Local1)
        }
        //
        // claim the rest of SBREG range, from above GPIO COM0 to SBREG range upper limit
        //
        Name (SBRE, ResourceTemplate () {Memory32Fixed (ReadWrite, 0x0, 0x0, SEND) })
        CreateDWordField (SBRE, SEND._BAS, BAS3)
        CreateDWordField (SBRE, SEND._LEN, LEN3)
        Store (Add (SBRG, Add (0x006e0000, 0x10000)), BAS3)
        If (LEqual (PCHS, 4)) {
          Store (Subtract (Add (SBRG, 0x10000000), BAS3), LEN3)
        } Else {
          Store (Subtract (Add (SBRG, 0x01000000), BAS3), LEN3)
        }
        ConcatenateResTemplate (Local1, SBRE, Local2)
        return (Local2)
      } // Method (_CRS)
    } // Device (PRRE)
  
    Device(IOTR) {
      //
      // This device claims IO range reserved for IO traps
      // to prevent OS from reusing it for other purposes
      //
      Name(_HID,EISAID("PNP0C02"))
      Name(_UID,"IoTraps")
      Method(_CRS) {
        Name(BUF0,ResourceTemplate(){ Io(Decode16,0x0,0x0,0x1,0xFF,TAG0) })
        Name(BUF1,ResourceTemplate(){ Io(Decode16,0x0,0x0,0x1,0xFF,TAG1) })
        Name(BUF2,ResourceTemplate(){ Io(Decode16,0x0,0x0,0x1,0xFF,TAG2) })
        Name(BUF3,ResourceTemplate(){ Io(Decode16,0x0,0x0,0x1,0xFF,TAG3) })
        CreateWordField(BUF0,TAG0._MIN,AMI0);CreateWordField(BUF0,TAG0._MAX,AMA0)
        CreateWordField(BUF1,TAG1._MIN,AMI1);CreateWordField(BUF1,TAG1._MAX,AMA1)
        CreateWordField(BUF2,TAG2._MIN,AMI2);CreateWordField(BUF2,TAG2._MAX,AMA2)
        CreateWordField(BUF3,TAG3._MIN,AMI3);CreateWordField(BUF3,TAG3._MAX,AMA3)
  
        Store(0, Local2)
        //
        // Win7 can't store result of ConcatenateResTemplate directly into one of its input parameters
        // When ITS0, ITS1, ITS2 and ITS3 is 1. Update BUF0, BUF1, BUF2 and BUF3 then store to Local0
        //
        If(LEqual(ITS0,1)) {
          Store(ITA0,AMI0)
          Store(ITA0,AMA0)
          Store(BUF0, Local0)
          Store(1, Local2)
        }
        If(LEqual(ITS1,1)) {
          Store(ITA1,AMI1)
          Store(ITA1,AMA1)
          If (LEqual (Local2,1)){
            ConcatenateResTemplate(BUF1, Local0, Local1)
            Store(Local1, Local0)
          } Else {
            Store(BUF1, Local0)
            Store(1, Local2)
          }
        }
        If(LEqual(ITS2,1)) {
          Store(ITA2,AMI2)
          Store(ITA2,AMA2)
          If (LEqual(Local2, 1)){
            ConcatenateResTemplate(BUF2, Local0, Local1)
            Store(Local1, Local0)
          } Else {
            Store(BUF2, Local0)
            Store(1, Local2)
          }
        }
        If(LEqual(ITS3,1)) {
          Store(ITA3,AMI3)
          Store(ITA3,AMA3)
          If(LEqual(Local2, 1)){
            ConcatenateResTemplate(BUF3, Local0, Local1)
            Store(Local1, Local0)
          } Else {
            Store(BUF3, Local0)
            Store(1, Local2)
          }
        }
        If(LEqual(Local2, 1)){
          Return(Local0)
        } Else {
          Return(Buffer(){0x79, 0x00})
        }
      }
    }
  
  }
  
  Scope (\_SB.PC00) {
    Name(TEMP,0)                          // scratch variable that does not cause compiler warnings as writes to Localx variables do.
  
    //
    // LPC Bridge - Device 31, Function 0, this is only for PCH register Memory Region declare,
    // it's better to be declared as early as possible since it's widely used in whole ACPI name space.
    // Please add any code which needs to reference any register of it after this
    //
    Device(LPCB) {
      Name(_ADR, 0x001F0000)
  
      Method(_DSM,4,serialized){if(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return(Buffer() {0})}
  
      OperationRegion(LPC, PCI_Config, 0x00, 0x100)
      Field(LPC, AnyAcc, NoLock, Preserve)
      {
        Offset(0x02),
        CDID, 16,
        Offset(0x08),
        CRID,  8,
        Offset(0x80), // 0x80
        IOD0,  8,
        IOD1,  8,
        Offset(0xA0),
        , 9,
        PRBL,  1,
        Offset(0xDC), // 0xDC
        ,       2,
        ESPI,   1,
      }
    }
  
    //
    // SMBus Controller - Device 31, Function 4
    //
    Device(SBUS) {
      Name(_ADR,0x001F0004)
      Method(_DSM,4,serialized){if(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return(Buffer() {0})}
    }
  
    //
    // SPI Bridge - Device 31, Function 5
    //
    Device(SPIF) {
      Name(_ADR, 0x001F0005)
  
      // It is expected for bootloader to check and clear SPI Synchronous SMI Status bit prior to S0ix entry,
      // as this status bit might cause SPI driver unable to turn off clock source properly.
      // This method will check if Synchronous SMI Status bit is on, then reenable Write Protect Disable bit
      // and clear Synchronous SMI Status bit.
      Method(SPIS)
      {
        If (LEqual (SYNS, 0x1)) {
          store(0, WPDL)
          store(1, SYNS)
        }
      }
  
      OperationRegion(SPIC, PCI_Config, 0x00, 0x100)
      Field(SPIC, AnyAcc, NoLock, Preserve)
      {
        Offset(0xDC), // 0xDC
        WPDL,   1,
        ,       7,
        SYNS,   1,
      }
    }
  }
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchLimits.h"
/** @file
  Build time limits of PCH resources.

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/



//
// PCIe limits
//



//
// SATA limits
//







//
// SerialIo limits
//





// VMD


//
// Number of UFS controllers
//


#line 44 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PchLimits.h"
#line 5200 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsClk.h"
/** @file
  Register names for iCLK device

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/






#line 15 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsClk.h"
#line 5202 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\CommonSocPkg\\Include\\Register/TcoRegs.h"
/** @file
  Register names for PCH TCO device

  Conventions:

  - Register definition format:
    Prefix_[GenerationName]_[ComponentName]_SubsystemName_RegisterSpace_RegisterName
  - Prefix:
    Definitions beginning with "R_" are registers
    Definitions beginning with "B_" are bits within registers
    Definitions beginning with "V_" are meaningful values within the bits
    Definitions beginning with "S_" are register size
    Definitions beginning with "N_" are the bit position
  - [GenerationName]:
    Three letter acronym of the generation is used (e.g. SKL,KBL,CNL etc.).
    Register name without GenerationName applies to all generations.
  - [ComponentName]:
    This field indicates the component name that the register belongs to (e.g. PCH, SA etc.)
    Register name without ComponentName applies to all components.
    Register that is specific to -H denoted by "_PCH_H_" in component name.
    Register that is specific to -LP denoted by "_PCH_LP_" in component name.
  - SubsystemName:
    This field indicates the subsystem name of the component that the register belongs to
    (e.g. PCIE, USB, SATA, GPIO, PMC etc.).
  - RegisterSpace:
    MEM - MMIO space register of subsystem.
    IO  - IO space register of subsystem.
    PCR - Private configuration register of subsystem.
    CFG - PCI configuration space register of subsystem.
  - RegisterName:
    Full register name.

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/



//
// TCO register I/O map
//









































#line 84 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\CommonSocPkg\\Include\\Register/TcoRegs.h"
#line 5203 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  Scope(\) {
  
    Name (TMOV, 10) // Timeout Value, default = 10ms.
    //
    // Timeout Value Adjust Method
    // Arg0: Timeout Customize Value
    //
    Method (TMVA, 1, Serialized) {
      Store (10, TMOV) // Setting default value first to avoid the TMOV have been changed before.
      If (LGreater (Arg0, 10)) {
        Store (Arg0, TMOV) // Set customize Timeout Value if customize TMOV greater than 10ms.
      }
    }
    //
    // IPC Methods
    //
    // Send PMC IPC 1 Read/Write command
    // Input
    //   Arg0: Command           Command to be issued to PMC IPC 1 interface
    //   Arg1: SubCmdId          SUB_CMD_ID for provided Command
    //   Arg2: CmdSize           Total size in byte to be sent via PMC IPC 1 interface
    //   Arg3: WriteBuf0         1st DWORD Value to be issued to PMC IPC 1 interface
    //   Arg4: WriteBuf1         2nd DWORD Value to be issued to PMC IPC 1 interface
    //   Arg5: WriteBuf2         3rd DWORD Value to be issued to PMC IPC 1 interface
    //   Arg6: WriteBuf3         4th DWORD Value to be issued to PMC IPC 1 interface
    // Output
    //   Package of data in below order:
    //     Status                Status of the transaction {0 indicates success, non-zero indicates failure}
    //                           Error Code            Description
    //                           ----------            ---------------------
    //                           1                     Command Size Exceeds
    //                           2                     Device failure
    //                           3                     Timeout Occured
    //                           ----------            ---------------------
    //     ReadBuf               Structure of 4 DWORDs to be filled by PMC IPC 1 interface
    //
    Method(IPCS, 7, Serialized){
      Name(RPKG, Package (5) {
        Zero, // Status
        Zero, // ReadBuf0
        Zero, // ReadBuf1
        Zero, // ReadBuf2
        Zero  // ReadBuf3
      })
  
  
      if (LGreater(Arg2, 16))    // (CmdSize > 16)
      {
        Store(1, Index(RPKG, 0)) // Store Errorcode of Command Size Exceeds to Status
        Return(RPKG)
      }
  
      //
      // Program the Write Buffers with the Data that needs to be written to PMC
      //
      Store(Arg3,IWB0)
      Store(Arg4,IWB1)
      Store(Arg5,IWB2)
      Store(Arg6,IWB3)
  
      //
      // Program the command register with command and size
      //
      Store(0, Local0)
      Add(Local0, ShiftLeft(Arg0,0), Local0)
      Add(Local0, ShiftLeft(Arg1,12), Local0)
      Add(Local0, ShiftLeft(Arg2,16), Local0)
      Store(Local0,CMDR)
  
      ///
      /// Read the IPC_STS to get BUSY or Error status
      /// Break on 10ms/Customize timeout or error
      ///
      Store (0, Local0)
      Store (TMOV, Local1) // Store IPC1 Command Timeout Value in Local Variable to Prevent Issue Corruption of Global Variable.
      While (1) {
        If (LOr (LNot (IBSY), LEqual (IERR, 1))){
          Break
        }
        If (Lgreater (Local0, Local1)) { // Default Timeout Value Set to 10ms.
          Store (3, Index (RPKG, 0)) // Store Errorcode of Timeout Occured to Status
          Return (RPKG)
        }
        Sleep (1)
        Increment (Local0)
      }
      If(LEqual(IERR,1)) {
        Store(2, Index(RPKG, 0)) // Store Errorcode of Device Failure to Status
        Return(RPKG)
      }
  
      //
      // Fill the  ReadBuffer contents with the Data that needs to be read from PMC
      //
      Store(IRB0, Index(RPKG, 1)) // ReadBuf0
      Store(IRB1, Index(RPKG, 2)) // ReadBuf1
      Store(IRB2, Index(RPKG, 3)) // ReadBuf2
      Store(IRB3, Index(RPKG, 4)) // ReadBuf3
  
      Return(RPKG)
    }
  
    //
    // Program IGN_UFSX2 (Bit 18) of PMC MMR register LTR_IGN (Offset 0x1B0C)
    // arg0: Value to be programmed
    //
    Method (ULTR, 1, Serialized) {
      Store(Arg0, LTRU)
    }
  
    Method (TCBS, 0) {
      Return (TCOB)
    }
  
    //
    // Define PCH ACPIBASE I/O as an ACPI operating region.  The base address
    // can be found in Device 31, Function 2, Offset 40h.
    //
    OperationRegion(PMIO, SystemIo, PMBS, 0x80)
    Field(PMIO, ByteAcc, NoLock, Preserve) {
            ,  8,
        PBSS,  1,       // Power Button Status
      Offset(0x40),            // 0x40, General Purpose Event Control
            ,  17,
        GPEC,  1,       // Software GPE Control
      Offset(0x6C),     // 0x6C, General Purpose Event 0 Status [127:96]
            ,  19,
        CPWS,  1,       // CPU WAKE STATUS
      Offset(0x7C),      // 0x7C, General Purpose Event 0 Enable [127:96]
            ,  18,
        WAEN,  1,       // WADT EN
        CPWE,  1        // CPU WAKE EN
    }
  
    //
    // Define PCH TCOBASE I/O
    //
    OperationRegion(TCBA, SystemIo, TCBS, 0x10)
    Field(TCBA, ByteAcc, NoLock, Preserve) {
      Offset(0x04), // 0x04
          , 9,
      CPSC, 1,        // CPUSCI_STS
    }
  
    //
    // PWRM register definitions
    //
    OperationRegion(PWMR, SystemMemory, PWRM, 0x1E30)
    Field(PWMR, DWordAcc, NoLock, Preserve) {
      //
      // IPC definitions
      //
      Offset(0x00), // IPC Command (IPC_CMD)
      CMDR, 32,         // Command register. Includes: [7:0] Command, [8] MSI, [15:12] CMD_ID, [23:16] Size
      Offset(0x04), //  IPC Status (IPC_STS)
      IBSY, 1,          // [0]     Ready/Busy (BUSY)
      IERR, 1,          // [1]     Error (ERROR)
          , 1,          // [2]     IRQ (IRQ)
          , 1,          // [3]     Reserved
          , 4,          // [7:4]   Command ID (CMD_ID)
          , 8,          // [15:8]  Initiator ID (INIT_ID)
      IERC, 8,          // [23:16] Error Code (ERROR CODE)
          , 8,          // [31:24] Reserved
      Offset(0x80), // IPC Write Buffer (IPC_WBUF0)
      IWB0, 32,         // [31:0] Write Buffer (WBUF)
      Offset(0x84), // IPC Write Buffer (IPC_WBUF1)
      IWB1, 32,         // [31:0] Write Buffer (WBUF)
      Offset(0x88), // IPC Write Buffer (IPC_WBUF2)
      IWB2, 32,         // [31:0] Write Buffer (WBUF)
      Offset(0x8C), // IPC Write Buffer (IPC_WBUF3)
      IWB3, 32,         // [31:0] Write Buffer (WBUF)
      Offset(0x90), // IPC Read Buffer (IPC_RBUF0)
      IRB0, 32,         // [31:0] Read Buffer (RBUF)
      Offset(0x94), // IPC Read Buffer (IPC_RBUF1)
      IRB1, 32,         // [31:0] Read Buffer (RBUF)
      Offset(0x98), // IPC Read Buffer (IPC_RBUF2)
      IRB2, 32,         // [31:0] Read Buffer (RBUF)
      Offset(0x9C), // IPC Read Buffer (IPC_RBUF3)
      IRB3, 32,         // [31:0] Read Buffer (RBUF)
      Offset(0x10D0),
      RAA0, 1,          // BIT0  : PCIE A, Function 0
      RAA1, 1,          // BIT1  : PCIE A, Function 1
      RAA2, 1,          // BIT2  : PCIE A, Function 2
      RAA3, 1,          // BIT3  : PCIE A, Function 3
      RPB0, 1,          // BIT4  : PCIE B, Function 0
      RPB1, 1,          // BIT5  : PCIE B, Function 1
      RPB2, 1,          // BIT6  : PCIE B, Function 2
      RPB3, 1,          // BIT7  : PCIE B, Function 3
      RPC0, 1,          // BIT8  : PCIE C, Function 0
      RPC1, 1,          // BIT9  : PCIE C, Function 1
      RPC2, 1,          // BIT10 : PCIE C, Function 2
      RPC3, 1,          // BIT11 : PCIE C, Function 3
      RSAT, 1,          // BIT12 : SATA
      RGBE, 1,          // BIT13 : GBE
      RXHC, 1,          // BIT14 : XHCI
      RXDC, 1,          // BIT15 : XDCI
      RUFS, 1,          // BIT16 : UFS
      RPD0, 1,          // BIT17 : PCIE D, Function 0
      RPD1, 1,          // BIT18 : PCIE D, Function 1
      RPD2, 1,          // BIT18 : PCIE D, Function 2
      RPD3, 1,          // BIT20 : PCIE D, Function 3
      RPE0, 1,          // BIT21 : PCIE E, Function 0
      RPE1, 1,          // BIT22 : PCIE E, Function 1
      RPE2, 1,          // BIT23 : PCIE E, Function 2
      RPE3, 1,          // BIT24 : PCIE E, Function 3
      Offset(0x10D4),
      APA0, 1,          // BIT0  : PCIE A, Function 0
      APA1, 1,          // BIT1  : PCIE A, Function 1
      APA2, 1,          // BIT2  : PCIE A, Function 2
      APA3, 1,          // BIT3  : PCIE A, Function 3
      APB0, 1,          // BIT4  : PCIE B, Function 0
      APB1, 1,          // BIT5  : PCIE B, Function 1
      APB2, 1,          // BIT6  : PCIE B, Function 2
      APB3, 1,          // BIT7  : PCIE B, Function 3
      APC0, 1,          // BIT8  : PCIE C, Function 0
      APC1, 1,          // BIT9  : PCIE C, Function 1
      APC2, 1,          // BIT10 : PCIE C, Function 2
      APC3, 1,          // BIT11 : PCIE C, Function 3
      ASAT, 1,          // BIT12 : SATA
      AGBE, 1,          // BIT13 : GBE
      AXHC, 1,          // BIT14 : XHCI
      AXDC, 1,          // BIT15 : XDCI
      AUFS, 1,          // BIT16 : UFS
      APD0, 1,          // BIT17 : PCIE D, Function 0
      APD1, 1,          // BIT18 : PCIE D, Function 1
      APD2, 1,          // BIT18 : PCIE D, Function 2
      APD3, 1,          // BIT20 : PCIE D, Function 3
      APE0, 1,          // BIT21 : PCIE E, Function 0
      APE1, 1,          // BIT22 : PCIE E, Function 1
      APE2, 1,          // BIT23 : PCIE E, Function 2
      APE3, 1,          // BIT24 : PCIE E, Function 3
      Offset(0x1800),
      //
      // AdvancedFeaturesBegin
      //
      ACWA, 32,         // Wake Alarm Device Timer: AC
      DCWA, 32,         // Wake Alarm Device Timer: DC
      ACET, 32,         // Wake Alarm Device Expired Timer: AC
      DCET, 32,         // Wake Alarm Device Expired Timer: DC
      //
      // AdvancedFeaturesEnd
      //
      Offset(0x18E8),
          , 31,
      CECE,  1,         // PS_ON# de-assertion during SleepS0 enable
      Offset(0x1B0C),
          , 2,
      ISAT, 1,          // Ignore Sata LTR values
          , 18,
      LTRU,  1,         // Bit 18, IGN_UFSX2
      Offset(0x1B1C),
          , 22,
      XSQD,  1,         // 24MHz Crystal Shutdown Qualification Disable (XTALSDQDIS)
      Offset(0x1BD0),
          , 31,
      CPPM,  1,          // BIT31 : 1 = PMC allows stalling of the backbone, 0 = PMC does not allow stalling of the backbone
      Offset(0x1E20),
      GBED,  1,         // GBE_FDIS_PMC
      Offset(0x1E28),
          , 22,
      SCFD,  1,         // ST_FDIS_PMC (SATA)
    }
  
    //
    // PS_ON control. Enable/Disable PS_ON# de-assertion during SleepS0.
    // Arg0 - 0: Disable PS_ON# de-assertion, 1: Enable PS_ON# de-assertion
    //
    Method(PSOC, 1, Serialized) {
      If (PSON) {
        If(Arg0) {
          Store(1, CECE)
        } Else {
          Store(0, CECE)
        }
      }
    }
  
    //
    // PS_ON status.
    //
    // @retval 0 PS_ON de-assertion during SleepS0 disabled
    // @retval 1 PS_ON de-assertion during SleepS0 enabled
    //
    Method(PSOS) {
      If(CECE) {
        Return(1)
      } Else {
        Return(0)
      }
    }
  
    //
    // CPPM Forced Alignment Enable (CPPMFAEN):
    // 1 = PMC allows stalling of the backbone, enabling the CWB and blocking the DMI transmit arbiter and preventing CPU wakes (via PM_SYNC messages) when PCH idle (FAIDLEWAIT and FACSMEPGQDIS) and CPU is in the memory closed state.  It ceases the stall when the maximum wake time point is met.
    // 0 = PMC does not allow stalling of the backbone or enabling the CWB and blocking the DMI transmit arbiter.
    //
    Method(CFAE, 1, NotSerialized) {
      If(DerefOf(Index(Arg0, 0))) {
        ADBG("CPPM Forced Alignment Disable")
        Store(0, CPPM)
        Return(Buffer() {0})
      } Else {
        ADBG("CPPM Forced Alignment Enable")
        Store(1, CPPM)
        Return(Buffer() {0})
      }
    }
  
    //
    // Is MODPHY power gating supported
    // Checks if MODPHY power gating is supported on given SKU
    //
    // @retval 0 MODPHY power gating is not supported
    // @retval 1 MODPHY power gating is supported
    //
    Method (IMPS) {
      If (LEqual (PCHS, 4)) {
        Return(0)
      } Else {
        Return(1)
      }
    }
  }

  
  Scope (\_SB.PC00) {
    Name(LTEN, 0)
    Name(LMSL, 0)
    Name(LNSL, 0)
  } //scope
  
  If (LNotEqual(GBES,0)) {
    //
    // LAN Controller
    //
    Scope (\_SB.PC00) {
      Device(GLAN) { // GbE Controller
        Name(_ADR, 0x001F0006)
        Method(_DSM,4,serialized){if(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return(Buffer() {0})}
  
        Name(_S0W, 3) // Device can wake itself from D3 in S0
  
        Method(_PRW, 0) {
          Return(GPRW(0x6D, 4)) // can wakeup from S4 state
        }
  
        //
        // Define a Memory Region that will allow access to the GLAN PCI Configuration Space
        //
        OperationRegion(LANR, PCI_Config, 0x00, 0x100)
        Field(LANR,ByteAcc,NoLock,Preserve) {
          DVID, 16,
          Offset(0xCC), // R_GBE_CFG_PMCS Power management control and status PMCS_DR
          ,8,
          PMEE,1,
          ,6,
          PMES,1
        }
  
        Method(GPEH) {
          If(LEqual(^DVID,0xFFFF)) {
            Return
          }
          If(LEqual(PMES,1)) {
            Notify(\_SB.PC00.GLAN, 0x02)
          }
        }
  
        Method(_DSW, 3) {}
  
      } // end "GbE Controller"
    } //scope
  }
  
  //
  // xHCI Controller - Device 20, Function 0
  //
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/UsbRegs.h"
/** @file
  Register names for USB Host and device controller

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/








//
// xDCI (OTG) PCI Config Space Registers
//


//
// xDCI (OTG) MMIO registers
//






//
// USB2 Private Configuration Registers
// USB2 HIP design featured
// (PID:USB2)
// Doesn't apply to CPU (only USB3 functionality present)
//



#line 40 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/UsbRegs.h"
#line 5589 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  External(\_SB.PC00.XHCI.PS0X, MethodObj)
  External(\_SB.PC00.XHCI.PS3X, MethodObj)
  External(\_SB.PC00.XHCI.RHUB.PS0X, MethodObj)
  External(\_SB.PC00.XHCI.RHUB.PS2X, MethodObj)
  External(\_SB.PC00.XHCI.RHUB.PS3X, MethodObj)
  External(\_SB.PC00.XHCI.RHUB.INIR, MethodObj)
  External(DUWS)
  
  External(PU2C) // PCH USB2 Port count from NVS
  External(PU3C) // PCH USB3 Port count from NVS
  
  Scope(\_SB_.PC00) {
    Device(XHCI) {
  
      Name(_ADR, 0x00140000)
  
      OperationRegion(XPRT,PCI_Config,0x00,0x100)
      Field(XPRT,AnyAcc,NoLock,Preserve)
      {
        DVID, 16,
        Offset(0x10),
        XADL,  32,
        XADH,  32,
        Offset(0x74), //0x74 PCI Power management control/status, PM_CS
        ,8,
        PMEE,1,
        ,6,
        PMES,1,
        Offset(0xA2), // 0xA2
            ,  2,
        D3HE,  1,  // D3_hot_en
      }
  
      //
      // XHCI controller _DSM method
      //
      Method(_DSM,4,serialized){
        ADBG("XHCI _DSM")
  
        If(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }
  
        Return(Buffer() {0})
      }
  
      Method(_S3D, 0, NotSerialized)
      {
        Return(3)
      }
      Method(_S4D, 0, NotSerialized)
      {
        Return(3)
      }
      Method(_S3W, 0, NotSerialized)
      {
        Return(3)
      }
      Method(_S4W, 0, NotSerialized)
      {
        Return(3)
      }
  
      Method(_S0W, 0x0, NotSerialized)
      {
        Return(0x3)
      }
  
      Method(_PRW, 0) {
        If(CondRefOf(DUWS)) {
          Return(GPRW(0x6D, DUWS)) // can wakeup from deepest USB Sleep Wake State
        } Else {
          Return(GPRW(0x6D, 4)) // can wakeup from S4 state
        }
      }
  
      Method(GPEH) {
        If(LEqual(^DVID,0xFFFF))
        {
          Return
        }
        If(LEqual(PMES,1)) {
          Notify(\_SB.PC00.XHCI, 0x02)
        }
      }
  
      Method(_DSW, 3) {}
  
      Method(_INI) {
        If(CondRefOf(\_SB.PC00.XHCI.RHUB.INIR)) {      // _INI for RTD3
          \_SB.PC00.XHCI.RHUB.INIR()
        }
      }
  
      //
      // USRA (USbR port Address), method for calculating address of first USBR port in XHCI controller
      //  Arg0: Number of USB2 Port
      //
      Method(USRA,1,Serialized) {
        Return (Add (PU2C, Arg0))
      }
  
      //
      // SSPA (SuperSpeed Port Address), method for calculating address of first SS port in XHCI controller
      //  Arg0: Number of Super Speed Port
      //
      Method(SSPA,1,Serialized) {
        Return (Add (PU2C, Add (2, Arg0)))
      }
  
      Method(_PS0,0,Serialized)
      {
        ADBG("XHCI D0")
  
        If(LEqual(^DVID,0xFFFF))
        {
          Return()
        }
  
        //
        // Call platform XHCI PS0 method if present
        //
        If(CondRefOf(\_SB.PC00.XHCI.PS0X))
        {
          \_SB.PC00.XHCI.PS0X()
        }
      }
  
      Method(_PS3,0,Serialized)
      {
        ADBG("XHCI D3")
  
        If(LEqual(^DVID,0xFFFF))
        {
          Return()
        }
  
        //
        // Call platform XHCI PS3 method if present
        //
        If(CondRefOf(\_SB.PC00.XHCI.PS3X))
        {
          \_SB.PC00.XHCI.PS3X()
        }
      }
  
      //
      //
      // Check for XHCI switch UUID
      //
      // Arguments:
      //  Arg0 (Buffer) : UUID
      //
      // Returns:
      //  1: It's valid UUID
      //  0: Invalid UUID
      //
      Method(CUID,1,Serialized) {
        If(LEqual(Arg0,ToUUID("7c9512a9-1705-4cb4-af7d-506a2423ab71"))) {
          Return(1)
        }
        Return(0)
      }
  
      Device(RHUB)
      {
        Name(_ADR, Zero)
  
        // PS0 Method for xHCI Root Hub
        Method(_PS0,0,Serialized)
        {
          ADBG("XHCI RHUB PS0")
          If(LEqual(\_SB.PC00.XHCI.DVID,0xFFFF))
          {
            Return()
          }
          //
          // Call platform XHCI.RHUB PS0 method if present.
          //
          If(CondRefOf(\_SB.PC00.XHCI.RHUB.PS0X))
          {
            ADBG("XHCI CSD0")
            \_SB.CSD0(22)
            \_SB.PC00.XHCI.RHUB.PS0X()
          }
        }
  
        // PS2 Method for xHCI Root Hub
        Method(_PS2,0,Serialized)
        {
          ADBG("XHCI RHUB PS2")
          If(LEqual(\_SB.PC00.XHCI.DVID,0xFFFF))
          {
            Return()
          }
          //
          // Call platform XHCI.RHUB PS2 method if present.
          //
          If(CondRefOf(\_SB.PC00.XHCI.RHUB.PS2X))
          {
            \_SB.PC00.XHCI.RHUB.PS2X()
            ADBG("XHCI CSD3")
            \_SB.CSD3(22)
          }
        }
  
        // PS3 Method for xHCI Root Hub
        Method(_PS3,0,Serialized)
        {
          ADBG("XHCI RHUB PS3")
          If(LEqual(\_SB.PC00.XHCI.DVID,0xFFFF))
          {
            Return()
          }
          //
          // Call platform XHCI.RHUB PS3 method if present.
          //
          If(CondRefOf(\_SB.PC00.XHCI.RHUB.PS3X))
          {
            \_SB.PC00.XHCI.RHUB.PS3X()
            ADBG("XHCI CSD3")
            \_SB.CSD3(22)
          }
        }
      } // device rhub
    } // device xhc
  } //scope
  
  If(CondRefOf(PU2C)) {
    Scope(\_SB.PC00.XHCI.RHUB) {
      //
      // High Speed Ports (without USBR)
      //
      If (LLessEqual (1, PU2C)) {
        Device (HS01) {
          Name (_ADR, 1)
        }
      }
  
      If (LLessEqual (2, PU2C)) {
        Device (HS02) {
          Name (_ADR, 2)
        }
      }
  
      If (LLessEqual (3, PU2C)) {
        Device (HS03) {
          Name (_ADR, 3)
        }
      }
  
      If (LLessEqual (4, PU2C)) {
        Device (HS04) {
          Name (_ADR, 4)
        }
      }
  
      If (LLessEqual (5, PU2C)) {
        Device (HS05) {
          Name (_ADR, 5)
        }
      }
  
      If (LLessEqual (6, PU2C)) {
        Device (HS06) {
          Name (_ADR, 6)
        }
      }
  
      If (LLessEqual (7, PU2C)) {
        Device (HS07) {
          Name (_ADR, 7)
        }
      }
  
      If (LLessEqual (8, PU2C)) {
        Device (HS08) {
          Name (_ADR, 8)
        }
      }
  
      If (LLessEqual (9, PU2C)) {
        Device (HS09) {
          Name (_ADR, 9)
        }
      }
  
      If (LLessEqual (10, PU2C)) {
        Device (HS10) {
          Name (_ADR, 10)
        }
      }
  
      If (LLessEqual (11, PU2C)) {
        Device (HS11) {
          Name (_ADR, 11)
        }
      }
  
      If (LLessEqual (12, PU2C)) {
        Device (HS12) {
          Name (_ADR, 12)
        }
      }
  
      If (LLessEqual (13, PU2C)) {
        Device (HS13) {
          Name (_ADR, 13)
        }
      }
  
      If (LLessEqual (14, PU2C)) {
        Device (HS14) {
          Name (_ADR, 14)
        }
      }
  
      //
      // USBR ports definitions for supported PCH
      //
      Device(USR1) {
        Method(_ADR) { Return (USRA (1))}
      }
  
      Device(USR2) {
        Method(_ADR) { Return (USRA (2))}
      }
    }
  }
  
  If(CondRefOf(PU3C)) {
    Scope(\_SB.PC00.XHCI.RHUB) {
      //
      // Super Speed Ports
      //
      If (LLessEqual (1, PU3C)) {
        Device (SS01) {
          Method (_ADR) { Return (SSPA (1)) }
        }
      }
  
      If (LLessEqual (2, PU3C)) {
        Device (SS02) {
          Method (_ADR) { Return (SSPA (2)) }
        }
      }
  
      If (LLessEqual (3, PU3C)) {
        Device (SS03) {
          Method (_ADR) { Return (SSPA (3)) }
        }
      }
  
      If (LLessEqual (4, PU3C)) {
        Device (SS04) {
          Method (_ADR) { Return (SSPA (4)) }
        }
      }
  
      If (LLessEqual (5, PU3C)) {
        Device (SS05) {
          Method (_ADR) { Return (SSPA (5)) }
        }
      }
  
      If (LLessEqual (6, PU3C)) {
        Device (SS06) {
          Method (_ADR) { Return (SSPA (6)) }
        }
      }
  
      If (LLessEqual (7, PU3C)) {
        Device (SS07) {
          Method (_ADR) { Return (SSPA (7)) }
        }
      }
  
      If (LLessEqual (8, PU3C)) {
        Device (SS08) {
          Method (_ADR) { Return (SSPA (8)) }
        }
      }
  
      If (LLessEqual (9, PU3C)) {
        Device (SS09) {
          Method (_ADR) { Return (SSPA (9)) }
        }
      }
  
      If (LLessEqual (10, PU3C)) {
        Device (SS10) {
          Method (_ADR) { Return (SSPA (10)) }
        }
      }
    } // end RHUB scope
  } // end if

  
  //
  // xDCI (OTG) Controller - Device 20, Function 1
  //
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  External(\_SB.PC00.LPCB.H_EC.XDAT, MethodObj)
  
  Scope(\_SB.PC00)
  {
    Device(XDCI)
    {
      Name (_ADR, 0x00140001)  // _ADR: Address
  
      OperationRegion (OTGD, PCI_Config, 0x0, 0x100)
      Field (OTGD, DWordAcc, NoLock, Preserve)
      {
        Offset(0x0),
        DVID, 16,
        Offset(0x10),
        XDCB, 64
      }
      //
      // Byte access for PMCS field to avoid race condition on device D-state
      //
      Field (OTGD, ByteAcc, NoLock, Preserve)
      {
        Offset(0x84), // 0x84, PM_CS - Power Management Control/Status
        D0I3, 2,      // PM_CS[1:0] PowerState
        ,6,
        PMEE,1,
        ,6,
        PMES,1
      }
  
      Method(XDBA, 0)
      {
        Return(And(^XDCB, 0xFFFFFFFFFFFFFF00))
      }
  
      //
      // Arg0: UUID = {732b85d5-b7a7-4a1b-9ba0-4bbd00ffd511}
      // Arg1: Revision ID = 1
      // Arg2: Function Index
      // Arg3: Argument
      //
      Method(_DSM,4,Serialized)
      {
        If(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }
  
        ADBG("XDCI DSM")
        If(LEqual(Arg0, ToUUID("732b85d5-b7a7-4a1b-9ba0-4bbd00ffd511"))){
          If(Lequal(Arg1, 1)){
            //
            // Set PMU Power State
            // Arg0: 0x00 PMU should enter the D0 power state.
            //       0x03 PMU should enter the D3 power state.
            // Arg1: 0x03 Enable PMU PME
            //       0x00 Clear PMU PME
            //
            Method (SPPS,2,Serialized) {
              OperationRegion(XDBW, SystemMemory, XDBA(), 0x110000)
              Field(XDBW, WordAcc, NoLock, Preserve)
              {
                Offset(0x10F810), // 0x10F810
                    ,  8,
                U2CP,  2,     // USB2 core power state
                U3CP,  2,     // USB3 core power state
                Offset(0x10F818), // 0x10F818
                PUPS,  2,     // PMU power state
                    ,  1,
                PURC,  1,     // Reset PMU core
                    , 12,
                Offset(0x10F81C), // 0x10F81C
                    ,  3,
                UXPE,  2,     // U2 PME EN / U3 PME EN
                    , 11,
              }
  
              // Local 1 is power state D0 or D3
              Store(Arg0, Local1)
              // Local 2 is Enable/Clear PMU PME
              Store(Arg1, Local2)
  
              If(LEqual(Local1, 0)){
                ADBG("PMU D0")
                // Clear PMU PME
                // 0x10F81C BIT3: USB3 PME
                // 0x10F81C BIT4: USB2 PME
                Store(0, UXPE)
                // Wait for at least 100us, currently configured to 1000us
                Store(0, Local0)
                While(LLess(Local0, 10)){
                  Stall(100)
                  Increment(Local0)
                }
                // Set PMU to D0 by writing 0 to 0x10f818 Bit 1:0
                Store(0, PUPS)
                // Wait 200ms for PMU to enter D0
                // Confirm PMU being in D0 by checking 0x10f810 Bit 11:8 to be clear
                // 0x10f810 Bit 11:10 - Current power state of USB3 core
                // 0x10f810 Bit 9:8 - Current power state of USB2 core
                // both should be clear
                Store(0,Local0)
                While(LLess(Local0,2000)){
                  Stall(100)
                  If(LAnd(LEqual(U2CP,0),LEqual(U3CP,0))){
                    break
                  }
                  Increment(Local0)
                }
                If(LNotEqual(U2CP, 0)){
                  // Show warning message
                  ADBG("U2 not in D0")
                }
                If(LNotEqual(U3CP, 0)){
                  // Show warning message
                  ADBG("U3 not in D0")
                }
                Return(0)
              }
  
              If(LEqual(Local1, 3)){
                ADBG("PMU D3")
                // PMU should be in D0 at this point
                // 0x10f810 Bit 11:10 - current power state of USB3 core
                // 0x10f810 Bit 9:8   - current power state of USB2 core
                // both should be clear
                If(LNotEqual(U2CP, 0)){
                  // Show warning message
                  ADBG("U2 not in D0")
                }
                If(LNotEqual(U3CP, 0)){
                  // Show warning message
                  ADBG("U3 not in D0")
                }
                // Set PMU to D3 by writing 3 to 0x10f818 bit 1:0
                Store(3, PUPS)
                // Wait 200ms for PMU to enter D3
                // Confirm PMU being in D3 by checking 0x10f810 Bit 11:8 to be set
                // 0x10f810 Bit 11:10 - Current power state of USB3 core
                // 0x10f810 Bit 9:8 - Current power state of USB2 core
                // both should be set
                Store(0,Local0)
                While(LLess(Local0,2000)){
                  Stall(100)
                  If(LAnd(LEqual(U2CP,3),LEqual(U3CP,3))){
                    break
                  }
                  Increment(Local0)
                }
                If(LNotEqual(U2CP, 3)){
                  // Show warning message
                  ADBG("U2 not in D3")
                }
                If(LNotEqual(U3CP, 3)){
                  // Show warning message
                  ADBG("U3 not in D3")
                }
                // Set/Clear PMU PME
                // 0x10F81C BIT3: USB3 PME
                // 0x10F81C BIT4: USB2 PME
                Store(Local2, UXPE)
                Return(0)
              }
              Return(0)
            }
  
            Switch(ToInteger(Arg2)) {
              Case(0){
                // Function 0: return Bit map to indicate Function 0,1,4,5,7,8,9 supported
                ADBG("XDCI Fn0")
                Return(Buffer(){0xB3, 0x03})
              }
              Case(1){
                // Function 1: Attach/Detach and Port Detection Properties Method
                // This method is called by the USB function stack to set the power state of the PMU.
                //   Bit 0 as 1: to indicate Platform support for Attach/detach notify
                //   Bit 1 as 0:HW based charging indication
                ADBG("XDCI Fn1")
                Return(0x1)
              }
              Case(4){
                // Function 4: Set PMU Power State Method, clear PMU PME
                // Arg3: A package consisting of 1 ULONG value
                //   0x00 PMU should enter the D0 power state.
                //   0x03 PMU should enter the D3 power state.
  
                ADBG("XDCI Fn4")
                // Local 1 is power state D0 or D3
                Store(DerefOf(Index(Arg3,0)), Local1)
                ADBG(Local1)
  
                // Set PMU to Dx state and clear PMU PME
                SPPS(Local1, 0)
              }
              Case(5){
                // Function 5: Attach Notification Enabled Method
                // This method is called by the USB function stack to indicate that it has enabled ACPI attach detach notifications.
                // In response the platform may issue an notification indicating the current attach/detach state of the controller.
  
                // If device is attached, notify XDCI with 0x80
                // If device is detached, notify XDCI with 0x81
  
                ADBG("XDCI Fn5")
  
                If(CondRefOf(\_SB.PC00.LPCB.H_EC.XDAT)){
                  If(LEqual(\_SB.PC00.LPCB.H_EC.XDAT(), 1)){
                    ADBG("USB Attach")
                    Notify(\_SB.PC00.XDCI,0x80)
                  }Else{
                    ADBG("USB Detach")
                    Notify(\_SB.PC00.XDCI,0x81)
                  }
                }
  
                Return(0)
              }
              Case(7){
                // Function 7: Get PMU Power State Method
                // Return:
                //   0: PMU is in D0 state
                //   3: PMU is in D3 state
  
                ADBG("XDCI Fn7")
  
                OperationRegion(XD22, SystemMemory, XDBA(), 0x110000)
                Field(XD22, WordAcc, NoLock, Preserve)
                {
                  Offset(0x10F818), // 0x10F818
                  P2PS,  2,     // PMU power state
                      , 14,
                }
                Store(P2PS, Local0)
                Return(Local0)
              }
              Case(8){
                //
                // Function 8: Get Group ID
                // Return:
                //   0: Group ID 0 is reserved
                //   Other value: A UCHAR value indicating that the controller shares connectors with one or more other controllers.
                //
                ADBG("XDCI Fn8")
                Return(1) // Both CPU and PCH are sharing connectors.
              }
              Case(9){
                //
                // Function 9: Currently, Power Down Scale is being overwritten by driver to a value of 2.
                //             BIOS saves the value initialized by HW return the value to Driver. Driver to update the GCTL register.
                // Return:
                //   None
                //
                ADBG("XDCI Fn9")
                OperationRegion(XGCT, SystemMemory, XDBA(), 0x110000)
                Field(XGCT, WordAcc, NoLock, Preserve)
                {
                  Offset(0xC110), // 0xC110
                  GCTL, 32,                    // Power Down Scale Value [31:19]
                }
                And(PPDS, 0xFFF80000, Local1)  // Keep Bit19 - Bit31
                ShiftRight(Local1, 19, Local1)
                ADBG(Concatenate("PCH XDCI: Func9 Return Val = ", ToHexString(Local1)))
                return(Local1)
              }
            }
          }
        }
        Return(Buffer() {0})
      }
  
      Name (_DDN, "ICL PCH XDCI controller")  // _DDN: DOS Device Name
      Name (_STR, Unicode ("ICL PCH XDCI controller"))  // _STR: Description String
  
      Method(_S0W, 0)
      { // PMEs can be generated from D3(hot)
        Return(3)
      }
  
      // XDCI Wake Support
      Method(_PRW, 0) {
        Return(GPRW(0x6D, 4)) // can wakeup from S4 state
      }
  
      Method(GPEH, 0) {
        If(LEqual(^DVID,0xFFFF))
        {
          Return
        }
        If(LEqual(PMES,1)) {
          Notify(\_SB.PC00.XDCI, 0x02)
        }
      }
  
      Method(_DSW, 3) {}
    }
  }

  
  Scope(\_SB_.PC00) {
    //
    // High Definition Audio Controller - Device 31, Function 3
    //
    /** @file
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
    External(\_SB.PC00.HDAS.PS0X, MethodObj)
    External(\_SB.PC00.HDAS.PS3X, MethodObj)
    External(\_SB.PC00.HDAS.PPMS, MethodObj)
    External(HIDW, MethodObj)
    External(HIWC, MethodObj)
    
    //
    // High Definition Audio Controller - Device 31, Function 3
    //
    Device(HDAS)
    {
      Name(_ADR, 0x001F0003)
    
      //
      // Define a Memory Region that will allow access to the HDA PCI Configuration Space
      //
      OperationRegion(HDAR, PCI_Config, 0x00, 0x100)
      Field(HDAR,WordAcc,NoLock,Preserve) {
        VDID,32,      // 0x00, VID DID
        Offset(0x54), // R_HDA_CFG_PCS Power management conrol PCS
        ,8,
        PMEE,1,
        ,6,
        PMES,1
      }
    
      Name(_S0W, 3) // Device can wake itself from D3 in S0
    
      Method(_DSW, 3) {}
    
      Method(_PRW, 0) {
        Return(GPRW(0x6D, 4)) // can wakeup from S4 state
      }
    
      Method(GPEH, 0) {
        If(LEqual(^VDID,0xFFFFFFFF))
        {
          Return
        }
        If(LEqual(PMES,1)) {
          Notify(\_SB.PC00.HDAS, 0x02)
        }
      }
    
      // D0 Method for HD-A Controller
      Method(_PS0, 0, Serialized)
      {
    
        //
        // Call platform HDAS PS0 method if present
        //
        If(CondRefOf(\_SB.PC00.HDAS.PS0X)) {
          \_SB.PC00.HDAS.PS0X()
        }
      }
    
      // D3 Method for HD-A Controller
      Method(_PS3, 0, Serialized)
      {
    
        //
        // Call platform HDAS PS3 method if present
        //
        If(CondRefOf(\_SB.PC00.HDAS.PS3X)) {
          \_SB.PC00.HDAS.PS3X()
        }
      }
    
      // NHLT Table memory descriptor, returned from _DSM
      Name(NBUF, ResourceTemplate () {
        // NHLT table address (_MIN = NHLT 64bit pointer, _MAX = _MIN + _LEN - 1) and length (_LEN)
        QWordMemory (ResourceConsumer, , MinNotFixed, MaxNotFixed, NonCacheable, ReadOnly,
                    0x1,                // AddressGranularity
                    0x0000000000000000, // AddressMinimum _MIN
                    0x0000000000000000, // AddressMaximum _MAX
                    0x0,
                    0x0,                // RangeLength _LEN
                    , , NHLT, AddressRangeACPI,)
      })
    
    
      Method(_INI) {
        // Update resource according to NVS
    
        // Set NHLT base address and length
        CreateQWordField(NBUF, ^NHLT._MIN, NBAS)
        CreateQWordField(NBUF, ^NHLT._MAX, NMAS)
        CreateQWordField(NBUF, ^NHLT._LEN, NLEN)
        Store(NHLA, NBAS)
        Add(NHLA, Subtract(NHLL, 1), NMAS)
        Store(NHLL, NLEN)
    
      }
    
      Name(_DSD, Package () {
        ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
        // Properties related to HDAS
        Package () {
          Package (2) {"nhlt-version","1.8-0"}
        }
      })
    
      Method(_DSM, 0x4, NotSerialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        // Arg0 - UUID: A69F886E-6CEB-4594-A41F-7B5DCE24C553 (Buffer)
        // Arg1 - Revision ID: 0x01 (Integer)
        // Arg2 - Function Index: 0x0 - 0x3 and 0x6 (Integer) - See below for details.
        // Arg3 - Depends on Function Index - See below for details.
        // Return - Depends on Function Index - See below for details.
    
    
        if(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }
    
        // Verify UUID
        If (LEqual(Arg0, ToUUID ("A69F886E-6CEB-4594-A41F-7B5DCE24C553"))) {
    
          Switch(ToInteger(Arg2)) {
    
            // Function 0: Function Support Query
            // Arg2 - Function Index: 0x00 (Integer)
            // Arg3: Unused
            // Return: Bitmask of functions supported. (Buffer)
            Case(0) {
              // Supports function 0 - 3 and 6
              Return(Buffer(One) { 0x4F })
            }
    
            // Function 1: Query Non HD Audio Descriptor Table
            //                    Used by the Intel Offload Engine Driver to discover the
            //                    non HD Audio devices supported by the Audio DSP.
            // Arg2 - Function Index: 0x01 (Integer)
            // Arg3 - Unused
            // Return - ACPI Table describing the non HD Audio links and devices supported by the ADSP (ResourceBuffer)
            Case(1) {
              // NBUF - Memory Resource Descriptor buffer with address and length of NHLT
              Return(NBUF)
            }
    
            // Function 2: Query Feature Mask
            //                    Used by the Intel Offload Engine Driver to retrieve a bitmask
            //                    of features allowable on this platform.
            // Arg2 - Function Index: 0x02 (Integer)
            // Arg3: Unused
            // Return: Bitmask of supported features.
            Case (2) {
              // Bit 0 == '1', WoV is supported, Bit 0 == '0', WoV not supported
              // Bit 1 == '1', BT Sideband is supported, Bit 1 == '0', BT not supported
              // Bit 2 == '1', codec based VAD support allowable
              // Bit 3 - 4 Reserved
              // Bit 5 == '1', BT Intel HFP SCO is supported
              // Bit 6 == '1', BT Intel A2DP is supported
              // Bit 7 == '1', DSP based speech pre-processing disabled
              // Bit 8 == '1', Windows Voice Activation, Bit 8 == '0', Intel Wake on Voice
              // Bit 9 - 31 Reserved, shall be set to '0'
              // ADFM - NVS AudioDSP Feature Bit Mask updated from PchPolicy
              Return(ADFM)
            }
    
            // Function 3: Query Pre/Post Processing Module Support
            //                    Used by the Intel Offload Engine Driver to determine if a
            //                    specified PP Module is allowed to be supported on this platform
            // Arg2 - Function Index: 0x03 (Integer)
            // Arg3 - UUID: Specifies the UUID of the PP module to check (Buffer)
            // Return - TRUE if PP Module supported, else FALSE.
            Case (3) {
    
              If(CondRefOf(\_SB.PC00.HDAS.PPMS)) {
                // Call platform method PPMS to check if 3rd Party IP module with given GUID (Arg3) is supported
                Return(\_SB.PC00.HDAS.PPMS (Arg3))
              }
    
              Return(0) // Is not supported
            }
            Case (6) {
              Return (XTAL)
            }
            Default {
              // Function not supported (Arg2)
              Return(Buffer(One) { 0x00 })
            }
          } // Switch(Arg2) End
        } // If(Arg0, UUID) End
    
        //-------------------------------------------
        //  HID Wake up Event solution
        //-------------------------------------------
        If(CondRefOf(HIWC)) {
          If(HIWC(Arg0)) {
            If(CondRefOf(HIDW)) {
              Return (HIDW(Arg0, Arg1, Arg2, Arg3))
            }
          }
        }
    
        // UUID not supported (Arg0)
        Return(Buffer() {0})
      } // _DSM End
    } // end "High Definition Audio Controller"

  
    //
    // High Definition Audio - SoundWire Controller
    //
    /** @file
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
    // Values for XTAL 24MHz
    
    
    
    
    
    // Values for XTAL 38.4MHz
    
    
    
    
    
    // Values for XTAL 19.2MHz
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    //
    // SoundWire Link Controllers definition (up to 4 controllers can be defined)
    //
    Scope(HDAS)
    {
      //
      // Address (_ADR) encoding:
      // Bits 28-31 - Link Type
      // 0 = HD-Audio, 1 = DSP, 2 = PDM, 3 = SSP, 4 = SoundWire
      // Bits 0-3 - Device Instance ID (unique to virtual bus).
      // SoundWire:
      // 0-3 = Bus Instance 0 - 3
      // For example:
      // 1)  SWC0: _ADR(0x10000000) - LinkType[31:28] = 1 (DSP), Instance[3:0] = 0
      // 2)  SWC1: _ADR(0x40000001) - LinkType[31:28] = 4 (SW),  Instance[3:0] = 1
      // 3)  SWC2: _ADR(0x40000002) - LinkType[31:28] = 4 (SW),  Instance[3:0] = 2
      //
    
      //
      // SoundWire Link Controller (Aggregated defintion for all 4 contoller instances - LinkType = SoundWire)
      //
      Device(SNDW) {
        Name(_ADR, 0x40000000)
    
        Name(_CID, Package() {
          // Precedence order does matter for evaluation of list
          "PRP00001",  // to indicate that we want to use DeviceTree-like "compatible" matching, Linux only
          "PNP0A05"    // generic container device always placed last, makes sure entry is ignored by Windows with no yellow bangs if there is no matching driver
        })
    
        Method(_STA, 0, NotSerialized) { // _STA: Status
          Return (0x0B)
        }
    
        //
        // Update Quirk mask based on enabled SoundWire interfaces and update autonomous clock stop based on PchPolicy
        // Arg0 - Link instance (LNK[N])
        // Arg1 - SoundWire Quirk Mask
        // Arg2 - Autonomous Clock Stop
        Method(QCFG, 3,  NotSerialized) {
          // Update LNK[N] object, "intel-quirk-mask" property value
          // in accordance with SoundWire Link [N] enable/disable state in PchPolicy
          Store (Arg1, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 0)), 1))
          // Update LNK[N] object, "intel-autonomous-clock-stop" property value
          // in accordance with SoundWire Link [N] Autonomous Clock Stop enable/disable state in PchPolicy
          Store (Arg2, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 4)), 1))
        }
    
        //
        // Update Link properties (Clock, Supported frequency, Frame) based on selected XTAL
        // Arg0 - Link instance (LNK[N])
        // Arg1 - XTAL
        //
        Method(XCFG, 2,  NotSerialized) {
          If (Arg1 == 24000000) {
            Store (24000000, Local0)
            Store (6000000, Local1)
            Store (125, Local2)
            Store (2, Local3)
          }
          ElseIf (Arg1 == 38400000) {
            Store (38400000, Local0)
            Store (4800000, Local1)
            Store (50, Local2)
            Store (4, Local3)
          }
          ElseIf (Arg1 == 19200000) {
            Store (19200000, Local0)
            Store (4800000, Local1)
            Store (50, Local2)
            Store (4, Local3)
          }
          Else {
            Store (0x00, Local0)
            Store (0x00, Local1)
            Store (0x00, Local2)
            Store (0x00, Local3)
          }
    
          // Update properties values: "intel-sdw-ip-clock", "mipi-sdw-clock-frequencies-supported",
          // "mipi-sdw-default-frame-row-size", "mipi-sdw-default-frame-col-size"
          // based on detected XTAL (0: 24MHz or 1: 38.4MHz; 2: Unsupported).
          // By default assign values corresponding to XTAL 24MHz.
    
          // LNK[N] (Arg0) - update property values for selected XTAL (Arg1)
          Store (Local0, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 1)), 1))
          Store (Local1, Index (DeRefOf(Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 7)), 1)), 0))
          Store (Local2, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 9)), 1))
          Store (Local3, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 10)), 1))
        }
    
        //
        // Update  based on PchPolicy
        // Arg0 - Link instance (LNK[N])
        // Arg1 - Data On Active Interval Select (DOAIS)
        // Arg2 - Data On Delay Select (DODS)
        Method(DCFG, 3,  NotSerialized) {
          // Update LNK[N] object, "intel-sdw-doais" property value
          // in accordance with SoundWire Link [N] Data On Active Interval Select state in PchPolicy
          Store (Arg1, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 2)), 1))
          // Update LNK[N] object, "intel-sdw-dods" property value
          // in accordance with SoundWire Link [N] Data On Delay Select state in PchPolicy
          Store (Arg2, Index (DeRefOf(Index(DeRefOf(Index(Arg0, 1)), 3)), 1))
        }
    
        //
        // "mipi-sdw-master-count" update
        // Arg0 - SoundWire requester Count value
        Method(SDWU, 1,  NotSerialized) {
          Store (Arg0, Index(DeRefOf(Index(DeRefOf(Index(_DSD, 1)), 1)), 1))
        }
    
    
        Method (_INI) {
    
          // Update SoundWire requester Count
          SDWU(\SWMC)
    
          // Update Link Enable property
          // SWQx - PCH NVS variables set in accordance with PchPolicy (AudioLinkSndwX)
          QCFG(LNK0, \SWQ0, \ACS0)
          QCFG(LNK1, \SWQ1, \ACS1)
          QCFG(LNK2, \SWQ2, \ACS2)
          QCFG(LNK3, \SWQ3, \ACS3)
    
          // Update XTAL based properties
          // XTAL - PCH NVS variable with XTAL frequency (0 - 24MHz; 1 - 38.4MHz)
          XCFG(LNK0, \XTAL)
          XCFG(LNK1, \XTAL)
          XCFG(LNK2, \XTAL)
          XCFG(LNK3, \XTAL)
    
          // Update DOAIS and DODS based proparties
          // PCH NVS variables set in accordance with PchPolicy
          DCFG(LNK0, \DAI0, \DOD0)
          DCFG(LNK1, \DAI1, \DOD1)
          DCFG(LNK2, \DAI2, \DOD2)
          DCFG(LNK3, \DAI3, \DOD3)
        }
    
        Name(_DSD, Package () {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000},
            Package (2) {"mipi-sdw-master-count", 4}
            // Vendor specific parameters (optional)
          },
          // Properties for the SoundWire bus instances
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"},
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"},
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"},
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}
          }
         })
    
        Name(LNK0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            //
            // Intel specific properties
            //
            Package (2) {"intel-quirk-mask", 0}, // Quirks: [BIT0] - static clock, [BIT1] - bus instance disable (0-No, 1-Yes)
            Package (2) {"intel-sdw-ip-clock", 38400000}, //SoundWire clock value delivered to IP
            Package (2) {"intel-sdw-doais", 1}, //SoundWire Data On Active Interval Select (0 - 3 clock periods, 1 - 4 clock periods, 2 - 5 clock periods, 3 - 6 clock periods)
            Package (2) {"intel-sdw-dods", 1}, //SoundWire Data On Delay Select (0 - 2 clock periods, 1 - 3 clock periods)
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            //
            // Properties defined as per the MIPI software spec for Link controllers
            //
            Package (2) {"mipi-sdw-clock-stop-mode0-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-frequencies-supported", Package(){4800000}}, // Package
            Package (2) {"mipi-sdw-default-frame-rate", 48000}, // Integer
            Package (2) {"mipi-sdw-default-frame-row-size", 50}, // Integer
            Package (2) {"mipi-sdw-default-frame-col-size", 4}, // Integer
            Package (2) {"mipi-sdw-dynamic-frame-shape", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-command-error-threshold", 16}, // Integer
          }
        })
    
        Name(LNK1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            //
            // Intel specific properties
            //
            Package (2) {"intel-quirk-mask", 0}, // Quirks: [BIT0] - static clock, [BIT1] - bus instance disable (0-No, 1-Yes)
            Package (2) {"intel-sdw-ip-clock", 38400000}, //SoundWire clock value delivered to IP
            Package (2) {"intel-sdw-doais", 1}, //SoundWire Data On Active Interval Select (0 - 3 clock periods, 1 - 4 clock periods, 2 - 5 clock periods, 3 - 6 clock periods)
            Package (2) {"intel-sdw-dods", 1}, //SoundWire Data On Delay Select (0 - 2 clock periods, 1 - 3 clock periods)
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            //
            // Properties defined as per the MIPI software spec for Link controllers
            //
            Package (2) {"mipi-sdw-clock-stop-mode0-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-frequencies-supported", Package(){4800000}}, // Package
            Package (2) {"mipi-sdw-default-frame-rate", 48000}, // Integer
            Package (2) {"mipi-sdw-default-frame-row-size", 50}, // Integer
            Package (2) {"mipi-sdw-default-frame-col-size", 4}, // Integer
            Package (2) {"mipi-sdw-dynamic-frame-shape", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-command-error-threshold", 16}, // Integer
          }
        })
    
        Name(LNK2, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            //
            // Intel specific properties
            //
            Package (2) {"intel-quirk-mask", 0}, // Quirks: [BIT0] - static clock, [BIT1] - bus instance disable (0-No, 1-Yes)
            Package (2) {"intel-sdw-ip-clock", 38400000}, //SoundWire clock value delivered to IP
            Package (2) {"intel-sdw-doais", 1}, //SoundWire Data On Active Interval Select (0 - 3 clock periods, 1 - 4 clock periods, 2 - 5 clock periods, 3 - 6 clock periods)
            Package (2) {"intel-sdw-dods", 1}, //SoundWire Data On Delay Select (0 - 2 clock periods, 1 - 3 clock periods)
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            //
            // Properties defined as per the MIPI software spec for Link controllers
            //
            Package (2) {"mipi-sdw-clock-stop-mode0-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-frequencies-supported", Package(){4800000}}, // Package
            Package (2) {"mipi-sdw-default-frame-rate", 48000}, // Integer
            Package (2) {"mipi-sdw-default-frame-row-size", 50}, // Integer
            Package (2) {"mipi-sdw-default-frame-col-size", 4}, // Integer
            Package (2) {"mipi-sdw-dynamic-frame-shape", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-command-error-threshold", 16}, // Integer
          }
        })
    
        Name(LNK3, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            //
            // Intel specific properties
            //
            Package (2) {"intel-quirk-mask", 0}, // Quirks: [BIT0] - static clock, [BIT1] - bus instance disable (0-No, 1-Yes)
            Package (2) {"intel-sdw-ip-clock", 38400000}, //SoundWire clock value delivered to IP
            Package (2) {"intel-sdw-doais", 1}, //SoundWire Data On Active Interval Select (0 - 3 clock periods, 1 - 4 clock periods, 2 - 5 clock periods, 3 - 6 clock periods)
            Package (2) {"intel-sdw-dods", 1}, //SoundWire Data On Delay Select (0 - 2 clock periods, 1 - 3 clock periods)
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            //
            // Properties defined as per the MIPI software spec for Link controllers
            //
            Package (2) {"mipi-sdw-clock-stop-mode0-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-frequencies-supported", Package(){4800000}}, // Package
            Package (2) {"mipi-sdw-default-frame-rate", 48000}, // Integer
            Package (2) {"mipi-sdw-default-frame-row-size", 50}, // Integer
            Package (2) {"mipi-sdw-default-frame-col-size", 4}, // Integer
            Package (2) {"mipi-sdw-dynamic-frame-shape", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-command-error-threshold", 16}, // Integer
          }
        })
    
      }
    }

  
    If (LNotEqual(UAOE,0)) {
      //
      // High Definition Audio - USB Audio Offload
      //
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      //
      // USB Audio Offload SIO Controllers definition
      //
      Scope(HDAS)
      {
        //
        // Address (_ADR) encoding:
        // Bits 28-31 - Link Type
        // 0 = HD-Audio, 1 = DSP, 2 = PDM, 3 = SSP, 4 = SoundWire, 5 = SIO / USB Audio Offload
        // Bits 0-3 - Device Instance ID (unique to virtual bus).
      
        //
        // USB Audio Offload Controller
        //
        Device(UAOL) {
          Name(_ADR, 0x50000000)
      
          Name(_CID, Package() {
            // Precedence order does matter for evaluation of list
            "PRP00001",  // to indicate that we want to use DeviceTree-like "compatible" matching, Linux only
            "PNP0A05"    // generic container device always placed last, makes sure entry is ignored by Windows with no yellow bangs if there is no matching driver
          })
      
          Method(_STA, 0, NotSerialized) { // _STA: Status
            Return (0x0B)
          }
      
          //
          // UAOL _DSM method
          //
          Method(_DSM, 0x4, NotSerialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
            // Arg0 - UUID: 2E60AEFC-1BA8-467A-B8CC-5727B98CECB7 (Buffer)
            // Arg1 - Revision ID: 0x01 (Integer)
            // Arg2 - Function Index: 0x0 - 0x3 (Integer) - See below for details.
            // Arg3 - Depends on Function Index - See below for details.
            // Return - Depends on Function Index - See below for details.
      
            ADBG("UAOL _DSM")
      
            // Verify UUID
            If (LEqual(Arg0, ToUUID ("2E60AEFC-1BA8-467A-B8CC-5727B98CECB7"))) {
              Switch(ToInteger(Arg2)) {
                Case(0) {
                  // Supports function 0 - 1
                  Return(Buffer(One) { 0x03 })
                }
                Case(1) {
                  Return(CFAE(Arg3))
                }
              }
            }
            Return(Buffer() {0})
          }
      
          Name(_DSD, Package () {
            ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
            Package () {
              Package (2) {"uaol-ctrl-count", 2}
            },
            // Properties for the USB Audio Offload link instances
            ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
            Package () {
              Package (2) {"uaol-descriptor-0", "UAO0"}, // Link Descriptor 0
              Package (2) {"uaol-descriptor-1", "UAO1"}, // Link Descriptor 1
              // Package (2) {"uaol-descriptor-N", "UAO[N]"}, // Link Descriptor N
            }
          }) // END Name(_DSD)
      
          Name(UAO0, Package() {
            ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
            Package () {
              Package (2) {"uaol-instance-number", 0}, // Integer
              Package (2) {"bdf-routing-enabled", 0}, // Integer/Boolean
              // When the bdf-routing-enabled is set to true, peer-integrated-controller-identifier field is invalid.
              Package (2) {"peer-integrated-controller-identifier", 0x98ED}, // Type/Value: TBD
            }
          }) // END Name(UAO0)
      
          Name(UAO1, Package() {
            ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
            Package () {
              Package (2) {"uaol-instance-number", 1}, // Integer
              Package (2) {"bdf-routing-enabled", 0}, // Integer/Boolean
              // When the bdf-routing-enabled is set to true, peer-integrated-controller-identifier field is invalid.
              Package (2) {"peer-integrated-controller-identifier", 0xABCD}, // Type/Value: TBD
            }
          }) // END Name(UAO1)
        } // END Device(UAOL)
      
      } // END Scope(HDAS)

    }
  
    //
    // High Definition Audio - Intel Display Audio
    //
    /** @file
    
      Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    //
    // Intel Display Audio Controllers definition
    //
    Scope(HDAS)
    {
      //
      // Address (_ADR) encoding:
      // Bits 28-31 - Link Type
      // 0 = HD-Audio, 1 = DSP, 2 = PDM, 3 = SSP, 4 = SoundWire, 5 = SIO / USB Audio Offload
      // Bits 0-3 - Device Instance ID (unique to virtual bus).
    
      //
      // Intel Display Audio
      //
      Device(IDA) {
        Name(_ADR, 0x10000000)
      } // END Device(IDA)
    
    } // END Scope(HDAS)

  }
  
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  //
  // Serial Io Block
  //
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\SerialIoAcpiDefinesAdl.h"
/** @file

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

//
// Definition for Pch Serial IO Controllers
//




























#line 40 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\SerialIoAcpiDefinesAdl.h"
#line 6958 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  Scope(\_SB.PC00) {
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/SerialIoRegs.h"
/** @file
  Register names for Serial IO Controllers

  Conventions:

  - Register definition format:
    Prefix_[GenerationName]_[ComponentName]_SubsystemName_RegisterSpace_RegisterName
  - Prefix:
    Definitions beginning with "R_" are registers
    Definitions beginning with "B_" are bits within registers
    Definitions beginning with "V_" are meaningful values within the bits
    Definitions beginning with "S_" are register size
    Definitions beginning with "N_" are the bit position
  - [GenerationName]:
    Three letter acronym of the generation is used (e.g. SKL,KBL,CNL etc.).
    Register name without GenerationName applies to all generations.
  - [ComponentName]:
    This field indicates the component name that the register belongs to (e.g. PCH, SA etc.)
    Register name without ComponentName applies to all components.
    Register that is specific to -H denoted by "_PCH_H_" in component name.
    Register that is specific to -LP denoted by "_PCH_LP_" in component name.
  - SubsystemName:
    This field indicates the subsystem name of the component that the register belongs to
    (e.g. PCIE, USB, SATA, GPIO, PMC etc.).
  - RegisterSpace:
    MEM - MMIO space register of subsystem.
    IO  - IO space register of subsystem.
    PCR - Private configuration register of subsystem.
    CFG - PCI configuration space register of subsystem.
  - RegisterName:
    Full register name.

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/



//
// Serial IO Controllers PCI Configuration Registers
// registers accessed using PciD21FxRegBase + offset
//









//
// Serial IO Controllers MMIO Registers
// registers accessed : BAR0 + offset
//






#line 64 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/SerialIoRegs.h"
#line 6968 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  
  
  
  //
  // Include PchSerialIo ACPI macros
  //
  
  Scope(\_SB.PC00) {
  
  
    //
    //  Serial IO D3
    //  Common code for D3 entry for all SerialIo devices including PCI mode
    //
    //  @param[in]  Arg0      PCI CFG address
    //  @param[in]  Arg1      Boolean - Place Device in D3 (SERIAL_IO_D3)
    //  @param[in]  Arg2      Boolean - Reset BAR0 (SERIAL_IO_BAR_RESET) or leave BAR0 unchanged (0)
    //                                  depends on Arg1 equal to SERIAL_IO_D3 - device placed in D3
    //
    Method (SOD3, 3, Serialized) {
      OperationRegion(ICB1, SystemMemory, Add(\_SB.PC00.GPCB(), Arg0), Add (0x84, 4))
      If (Arg1) { // SERIAL_IO_D3
        Field(ICB1, ByteAcc, NoLock, Preserve) {
          Offset(0x84),
          PMEC, 8 //Note: SerialIO Does Not Support PME
        }
        Store (0x3, PMEC) // Set BIT[1:0] = 11b - Power State D3
        Or (PMEC, 0, PMEC) // perform a read to avoid ordering and noncoherency problems
      }
      If (LAnd(Arg1, Arg2)) { //SERIAL_IO_BAR_RESET only if device is placed in D3
        Field(ICB1, AnyAcc, NoLock, Preserve) {
          Offset(0x10),
          BAR0, 64
        }
        Store(0, BAR0)
      }
    }
  } //End Scope(\_SB.PC00)
  

  /**@file
  
    Serial IO I2C Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  
    //
    //  I2C Hidden Resource allocation
    //  Returns resource buffer with memory ranges used but not explicitely claimed by the device
    //
    //  @param[in]  Arg0      Pci Config Base
    //
    //  @retval               Resource buffer with memory ranges
    //
    Method (I2CH, 1, Serialized) {
      OperationRegion (ICB1, SystemMemory, Arg0, Add(0x10, 16))
      Field (ICB1, AnyAcc, NoLock, Preserve) {
        Offset(0x10),
        BAR0, 64,
        BAR1, 64
      }
      Name (BUF0, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 0x1000, BFR0) })
      Name (BUF1, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 0x1000, BFR1) })
      CreateDWordField (BUF0, BFR0._BAS, ADR0)
      CreateDWordField (BUF1, BFR1._BAS, ADR1)
      Store (And (BAR0, 0xFFFFFFFFFFFFF000), ADR0) // BAR0
      Store (And (BAR1, 0xFFFFFFFFFFFFF000), ADR1) // BAR1 - PCI CFG SPACE
      ConcatenateResTemplate (BUF0, BUF1, Local0)
      Return (Local0)
    } // End I2CH

  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Device (I2C0) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM00, 2)) {
        Method (_CRS) { Return (I2CH (IC00)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM00, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC00, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM00, 1), LEqual (IM00, 0))) {
        Method (_ADR) { Return (0x00150000) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C1) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM01, 2)) {
        Method (_CRS) { Return (I2CH (IC01)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM01, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC01, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM01, 1), LEqual (IM01, 0))) {
        Method (_ADR) { Return (0x00150001) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C2) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM02, 2)) {
        Method (_CRS) { Return (I2CH (IC02)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM02, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC02, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM02, 1), LEqual (IM02, 0))) {
        Method (_ADR) { Return (0x00150002) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C3) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM03, 2)) {
        Method (_CRS) { Return (I2CH (IC03)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM03, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC03, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM03, 1), LEqual (IM03, 0))) {
        Method (_ADR) { Return (0x00150003) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C4) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM04, 2)) {
        Method (_CRS) { Return (I2CH (IC04)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM04, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC04, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM04, 1), LEqual (IM04, 0))) {
        Method (_ADR) { Return (0x00190000) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C5) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM05, 2)) {
        Method (_CRS) { Return (I2CH (IC05)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM05, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC05, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM05, 1), LEqual (IM05, 0))) {
        Method (_ADR) { Return (0x00190001) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C6) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM06, 2)) {
        Method (_CRS) { Return (I2CH (IC06)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM06, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC06, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM06, 1), LEqual (IM06, 0))) {
        Method (_ADR) { Return (0x00100000) }
      }

  }
  
  
  
  
  
  
  
  Device (I2C7) {
  /**@file
  
    Serial IO I2C Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
      If(LEqual(IM07, 2)) {
        Method (_CRS) { Return (I2CH (IC07)) }
        Name (_STA, 0x8)
      }
      If(LEqual(IM07, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (IC07, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (IM07, 1), LEqual (IM07, 0))) {
        Method (_ADR) { Return (0x00100001) }
      }

  }

  /**@file
  
    Serial IO SPI Common ACPI
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  
    //
    //  SPI Hidden Resource allocation
    //  Returns resource buffer with memory ranges used but not explicitely claimed by the device
    //
    //  @param[in]  Arg0      Pci Config Base
    //
    //  @retval               Resource buffer with memory ranges
    //
    Method (SPIH, 1, Serialized) {
      OperationRegion (ICB1, SystemMemory, Arg0, Add(0x10, 16))
      Field (ICB1, AnyAcc, NoLock, Preserve) {
        Offset(0x10),
        BAR0, 64,
        BAR1, 64
      }
      Name (BUF0, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 0x1000, BFR0) })
      Name (BUF1, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 0x1000, BFR1) })
      CreateDWordField (BUF0, BFR0._BAS, ADR0)
      CreateDWordField (BUF1, BFR1._BAS, ADR1)
      Store (And (BAR0, 0xFFFFFFFFFFFFF000), ADR0) // BAR0
      Store (And (BAR1, 0xFFFFFFFFFFFFF000), ADR1) // BAR1 - PCI CFG SPACE
      ConcatenateResTemplate (BUF0, BUF1, Local0)
      Return (Local0)
    } // End SPIH

  /**@file
  
    Serial IO SPI ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Device (SPI0) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM00, 2)) {
        Method (_CRS) { Return (SPIH (SC00)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM00, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC00, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM00, 1), LEqual (SM00, 0))) {
        Method (_ADR) { Return (0x001E0002) }
      }

  }
  
  
  
  
  
  
  
  Device (SPI1) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM01, 2)) {
        Method (_CRS) { Return (SPIH (SC01)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM01, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC01, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM01, 1), LEqual (SM01, 0))) {
        Method (_ADR) { Return (0x001E0003) }
      }

  }
  
  
  
  
  
  
  
  Device (SPI2) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM02, 2)) {
        Method (_CRS) { Return (SPIH (SC02)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM02, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC02, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM02, 1), LEqual (SM02, 0))) {
        Method (_ADR) { Return (0x00120006) }
      }

  }
  
  
  
  
  
  
  
  Device (SPI3) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM03, 2)) {
        Method (_CRS) { Return (SPIH (SC03)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM03, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC03, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM03, 1), LEqual (SM03, 0))) {
        Method (_ADR) { Return (0x00130000) }
      }

  }
  
  
  
  
  
  
  
  Device (SPI4) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM04, 2)) {
        Method (_CRS) { Return (SPIH (SC04)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM04, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC04, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM04, 1), LEqual (SM04, 0))) {
        Method (_ADR) { Return (0x00130001) }
      }

  }
  
  
  
  
  
  
  
  Device (SPI5) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM05, 2)) {
        Method (_CRS) { Return (SPIH (SC05)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM05, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC05, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM05, 1), LEqual (SM05, 0))) {
        Method (_ADR) { Return (0x00130002) }
      }

  }
  
  
  
  
  
  
  
  Device (SPI6) {
  /**@file
  
    Serial IO SPI Controller ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
      If(LEqual(SM06, 2)) {
        Method (_CRS) { Return (SPIH (SC06)) }
        Name (_STA, 0x8)
      }
      If(LEqual(SM06, 1)) {
        Method (_DSM,4,Serialized){if(PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }; Return (Buffer(){0})}
        Method (_PS3) { SOD3 (SC06, 1, 1) }
        Method (_PS0) {  }
      }
      If (LOr (LEqual (SM06, 1), LEqual (SM06, 0))) {
        Method (_ADR) { Return (0x00130003) }
      }

  }
  

  }
  /**@file
  
    Serial IO UART Common ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/SerialIoUartRegs.h"
/** @file
  Register names for Serial IO UART Controllers

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




//
//  MMIO Convergance Layer
//








#line 24 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/SerialIoUartRegs.h"
#line 7606 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
  
    //
    //  Checks if UART specific DMA check _DSM is called
    //
    //  @param[in]  Arg0      UART mode
    //
    //  @retval               1 if true, 0 otherwise
    //
    Method (UDSM, 1 ,Serialized) {
      If (LEqual(Arg0, ToUUID ("F7AF8347-A966-49FE-9022-7A9DEEEBDB27"))) {
        return (1)
      }
      return (0)
    }
  
    //
    //  Uart DMA check _DSM
    //
    //  @param[in]  Arg0      Function Index
    //  @param[in]  Arg1      DMA/PIO support
    //
    //  @retval    case 0     Buffer with coresponding data
    //             case 1     Integer [0:PIO; 1:DMA]
    //             other      Empty Buffer
    //
    Method (UDMA, 2, Serialized) {
      Switch (ToInteger(Arg0)) {
        Case (0) {
          Return (ToBuffer(0x3)) // Supports Function 1.
        }
        // Function 1, Return UART operating mode [0:PIO; 1:DMA]
        Case (1) {
          Return (ToInteger(Arg1))
        }
      } // End Switch statement
      Return (ToBuffer(0x0))
    }
  
  } //End Scope(\_SB.PC00)
  
  Scope(\_SB) {
    //
    // Uart Resources
    //
    Device (URSC) {
      Name (_HID, EISAID("PNP0C02"))
      Name (_STA, 0x3)
      Name (_UID, 5)
      //
      //  Allocates remaining memory for Hidden/Com UART devices
      //
      //  @param[in]  Arg0      Mode
      //  @param[in]  Arg1      PciCfgBase
      //
      //  @retval               Resource buffer with memory ranges
      //
      Method (UARB, 2, Serialized) {
        If (LOr (LEqual (Arg0, 2), LEqual (Arg0, 3))) {
          OperationRegion (UACF, SystemMemory, Arg1, Add (0x10, 16))
          Field (UACF, AnyAcc, NoLock, Preserve) {
            Offset(0x10),
            BAR0, 64,
            BAR1, 64
          }
          Name (BUF1, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 0xFF8, BFR1) }) //4096 - 8 bytes, allocate remaining 4088 for BAR0 (MMIO BAR0)
          Name (BUF2, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 0x1000, BFR2) }) // allocate additional 4096 for BAR1 (PCI CFG SPACE)
  
          CreateDWordField (BUF1, BFR1._BAS, ADR1)
          CreateDWordField (BUF2, BFR2._BAS, ADR2)
  
          Store (And (BAR0, 0xFFFFFFFFFFFFF000), Local1)
          Store (Add (Local1, 8), ADR1)                // Add 8 bytes to the address offset. First 8 bytes are allocated by the UAHx _CRS
          Store (And (BAR1, 0xFFFFFFFFFFFFF000), ADR2) // BAR1 (PCI CFG SPACE) Address
  
          ConcatenateResTemplate (BUF1, BUF2, Local0)
          Return (Local0)
        }
        Return (Buffer(){0x79, 0x00})
      }
    } // END Device(URSC)
  
    //
    //  UART Hidden Resource allocation
    //  Returns resource buffer with memory ranges used but not explicitely claimed by the device
    //
    //  @param[in]  Arg0      Pci Config Base
    //  @param[in]  Arg1      Interrupt number
    //
    //  @retval               Resource buffer with memory ranges
    //
    Method (UARH, 2, Serialized) {
      OperationRegion (UACF, SystemMemory, Arg0, Add(0x10, 8))
      Field (UACF, AnyAcc, NoLock, Preserve) {
        Offset (0x10),
        BAR0, 64
      }
      Name (BUF0, ResourceTemplate () { Memory32Fixed (ReadWrite, 0, 8, BFR0) }) // UAHx allocates only first 8 bytes
      Name (IBUF, ResourceTemplate () { Interrupt( ResourceConsumer, Level, ActiveLow, Shared, , , SIRQ) {20}})
  
      CreateDWordField (BUF0, BFR0._BAS, ADR0)
      CreateDWordField (IBUF, SIRQ._INT, IRQN)
  
      Store (And (BAR0, 0xFFFFFFFFFFFFF000), Local0)
      Store (Local0, ADR0) // BAR0 first 8 bytes
      Store (Arg1, IRQN)   // Interrupt Number
      ConcatenateResTemplate (BUF0, IBUF, Local1)
      Return (Local1)
    }
  
    //
    //  Uart Power Gating Detection
    //  - If UART is in PCI mode PG will be set to autonomous with _PS0/PS3 support
    //  - Other modes:
    //      If UART_PG_AUTO is applied function checks if LCR is programmed
    //      Value different then 0 means that UART was used by the OS/SMM and PG should be OFF
    //      If it is 0 PG is ON
    //
    //  @param[in]  Arg0      UART mode
    //  @param[in]  Arg1      UART PG mode
    //  @param[in]  Arg2      Pci Config Base
    //
    //  @retval               Final PG mode
    //
    Method (UAPG, 3, Serialized) {
      If (LNotEqual (Arg1, 2)) {
        Return (Arg1)
      }
      OperationRegion (UACF, SystemMemory, Arg2, Add (0x10, 8))
      Field (UACF, AnyAcc, NoLock, Preserve) {
        Offset(0x10),
        BAR0, 64
      }
      OperationRegion (UAB0, SystemMemory, And (BAR0, 0xFFFFFFFFFFFFF000), 0x10)
      Field (UAB0, ByteAcc, Lock, Preserve) {
        DLL, 8,
        DLH, 8,
        FCR, 8,
        LCR, 8
      }
      Store (LCR, Local0)
      If (LAnd (Local0, 0x7F)) {
        Return (0) // Disable D0 and D3 transitions
      }
      Return (1)  // Enable D0 and D3 transitions
    }
  
    //
    //  Returns UART HID
    //
    //  @param[in]  Arg0      UART mode
    //
    //  @retval               HID value
    //
    Method (UHID, 1, Serialized) {
      If (LEqual (Arg0, 3)) { Return (EISAID("PNP0501")) }
      Return (EISAID("PNP0C02"))
    }
  
    //
    //  Uart _PS3 handler
    //
    //  @param[in]  Arg0      UART PG mode
    //  @param[in]  Arg1      UART Pci Config Base
    //
    Method (UPS3, 2, Serialized) {
      If (LEqual (Arg0, 1)) {
        OperationRegion (UACF, SystemMemory, Arg1, Add (0x84, 4))
        Field (UACF, AnyAcc, NoLock, Preserve) {
          Offset(0x10),
          BAR0, 64
        }
        Field (UACF, ByteAcc, NoLock, Preserve) {
          Offset(0x84),
          PMEC, 8
        }
        OperationRegion (UAB0, SystemMemory,  And (BAR0, 0xFFFFFFFFFFFFF000), Add (0x81, 1))
        Field (UAB0, ByteAcc, NoLock, Preserve) {
          Offset (0x81),
          PPRR, 8
        }
        Store (0x0, PPRR)  // Place In reset state
        Store (0x3, PMEC)
        Or (PMEC, 0, PMEC) // perform a read to avoid ordering and noncoherency problems
      }
      //UART_PG_OFF - no action
    }
  
    //
    //  Uart _PS0 handler
    //
    //  @param[in]  Arg0      UART PG mode
    //  @param[in]  Arg1      UART Pci Config Base
    //
    Method (UPS0, 2, Serialized) {
      If (LEqual (Arg0, 1)) {
        OperationRegion (UACF, SystemMemory, Arg1, Add (0x84, 4))
        Field (UACF, AnyAcc, NoLock, Preserve) {
          Offset(0x10),
          BAR0, 64
        }
        Field (UACF, ByteAcc, NoLock, Preserve) {
          Offset(0x84),
          PMEC, 8
        }
        Store (0x0, PMEC)
        Or (PMEC, 0, PMEC) // perform a read to avoid ordering and noncoherency problems
        OperationRegion (UAB0, SystemMemory,  And (BAR0, 0xFFFFFFFFFFFFF000), Add (0x81, 1))
        Field (UAB0, ByteAcc, NoLock, Preserve) {
          Offset (0x81),
          PPRR, 8
        }
        Store(0x7, PPRR)  // Out of reset
      }
      //UART_PG_OFF - no action
    }
  
    //
    //  Uart _PSC handler
    //
    //  @param[in]  Arg0      UART Pci Config Base
    //
    Method (UPSC, 1, Serialized) {
      OperationRegion (UACF, SystemMemory, Add (Arg0, 0x84), 4)
      Field (UACF, ByteAcc, NoLock, Preserve) {
        PMEC, 8
      }
      Return (And (PMEC, 0x3))
    }
  } //End Scope (\_SB)

  /**@file
  
    Serial IO UART Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.URSC) {
      Method (_CRS, 0x0, Serialized) {
        Store (UARB (UM00, UC00), Local0)
        ConcatenateResTemplate(Local0, UARB (UM01, UC01), Local1)
        Store(Local1, Local0)
        ConcatenateResTemplate(Local0, UARB (UM02, UC02), Local1)
        Store(Local1, Local0)
        ConcatenateResTemplate(Local0, UARB (UM03, UC03), Local1)
        Store(Local1, Local0)
        ConcatenateResTemplate(Local0, UARB (UM04, UC04), Local1)
        Store(Local1, Local0)
        ConcatenateResTemplate(Local0, UARB (UM05, UC05), Local1)
        Store(Local1, Local0)
        ConcatenateResTemplate(Local0, UARB (UM06, UC06), Local1)
        Store(Local1, Local0)
        Return (Local0)
      }
  } // END Device(URSC)
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA00) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD00)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x001E0000) }
      Method (_PS3) { SOD3 (UC00, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM00, 2), LEqual (UM00, 3))) {
      Device (UAH0) {
        Name (_DDN, "SerialIoUart0")
        Name (_UID, "SerialIoUart0")
        Method (_HID) { Return (UHID (UM00)) }
        Method (_CRS) { Return (UARH (UC00, UI00)) }
        Method (_STA) {
          If (LEqual (UM00, 3)) {
            If (LEqual (UP00, 2)) {
              Store (UAPG (UM00, UP00, UC00), UP00)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM00, 3)) {
          Method (_PSC) { Return (UPSC (UC00)) }
          Method (_PS3) { UPS3 (UP00, UC00) }
          Method (_PS0) { UPS0 (UP00, UC00) }
        }
      }
    }
  
  } //End Scope (\_SB)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA01) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD01)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x001E0001) }
      Method (_PS3) { SOD3 (UC01, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM01, 2), LEqual (UM01, 3))) {
      Device (UAH1) {
        Name (_DDN, "SerialIoUart1")
        Name (_UID, "SerialIoUart1")
        Method (_HID) { Return (UHID (UM01)) }
        Method (_CRS) { Return (UARH (UC01, UI01)) }
        Method (_STA) {
          If (LEqual (UM01, 3)) {
            If (LEqual (UP01, 2)) {
              Store (UAPG (UM01, UP01, UC01), UP01)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM01, 3)) {
          Method (_PSC) { Return (UPSC (UC01)) }
          Method (_PS3) { UPS3 (UP01, UC01) }
          Method (_PS0) { UPS0 (UP01, UC01) }
        }
      }
    }
  
  } //End Scope (\_SB)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA02) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD02)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x00190002) }
      Method (_PS3) { SOD3 (UC02, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM02, 2), LEqual (UM02, 3))) {
      Device (UAH2) {
        Name (_DDN, "SerialIoUart2")
        Name (_UID, "SerialIoUart2")
        Method (_HID) { Return (UHID (UM02)) }
        Method (_CRS) { Return (UARH (UC02, UI02)) }
        Method (_STA) {
          If (LEqual (UM02, 3)) {
            If (LEqual (UP02, 2)) {
              Store (UAPG (UM02, UP02, UC02), UP02)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM02, 3)) {
          Method (_PSC) { Return (UPSC (UC02)) }
          Method (_PS3) { UPS3 (UP02, UC02) }
          Method (_PS0) { UPS0 (UP02, UC02) }
        }
      }
    }
  
  } //End Scope (\_SB)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA03) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD03)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x00110000) }
      Method (_PS3) { SOD3 (UC03, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM03, 2), LEqual (UM03, 3))) {
      Device (UAH3) {
        Name (_DDN, "SerialIoUart3")
        Name (_UID, "SerialIoUart3")
        Method (_HID) { Return (UHID (UM03)) }
        Method (_CRS) { Return (UARH (UC03, UI03)) }
        Method (_STA) {
          If (LEqual (UM03, 3)) {
            If (LEqual (UP03, 2)) {
              Store (UAPG (UM03, UP03, UC03), UP03)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM03, 3)) {
          Method (_PSC) { Return (UPSC (UC03)) }
          Method (_PS3) { UPS3 (UP03, UC03) }
          Method (_PS0) { UPS0 (UP03, UC03) }
        }
      }
    }
  
  } //End Scope (\_SB)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA04) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD04)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x00110001) }
      Method (_PS3) { SOD3 (UC04, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM04, 2), LEqual (UM04, 3))) {
      Device (UAH4) {
        Name (_DDN, "SerialIoUart4")
        Name (_UID, "SerialIoUart4")
        Method (_HID) { Return (UHID (UM04)) }
        Method (_CRS) { Return (UARH (UC04, UI04)) }
        Method (_STA) {
          If (LEqual (UM04, 3)) {
            If (LEqual (UP04, 2)) {
              Store (UAPG (UM04, UP04, UC04), UP04)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM04, 3)) {
          Method (_PSC) { Return (UPSC (UC04)) }
          Method (_PS3) { UPS3 (UP04, UC04) }
          Method (_PS0) { UPS0 (UP04, UC04) }
        }
      }
    }
  
  } //End Scope (\_SB)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA05) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD05)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x00110002) }
      Method (_PS3) { SOD3 (UC05, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM05, 2), LEqual (UM05, 3))) {
      Device (UAH5) {
        Name (_DDN, "SerialIoUart5")
        Name (_UID, "SerialIoUart5")
        Method (_HID) { Return (UHID (UM05)) }
        Method (_CRS) { Return (UARH (UC05, UI05)) }
        Method (_STA) {
          If (LEqual (UM05, 3)) {
            If (LEqual (UP05, 2)) {
              Store (UAPG (UM05, UP05, UC05), UP05)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM05, 3)) {
          Method (_PSC) { Return (UPSC (UC05)) }
          Method (_PS3) { UPS3 (UP05, UC05) }
          Method (_PS0) { UPS0 (UP05, UC05) }
        }
      }
    }
  
  } //End Scope (\_SB)

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Device (UA06) {
  /**@file
  
    Serial IO UART Pci Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC (Arg0)) { Return (PCID (Arg0,Arg1,Arg2,Arg3)) }
        If (UDSM (Arg0)) { Return (UDMA (Arg2, UD06)) }
        Return (Buffer(){0})
      }
      Method (_ADR) { Return (0x00110003) }
      Method (_PS3) { SOD3 (UC06, 1, 1) }
      Method (_PS0) {  }
    }

  }
  /**@file
  
    Serial IO UART Hidden Controllers ACPI definitions
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB) {
    If (LOr (LEqual(UM06, 2), LEqual (UM06, 3))) {
      Device (UAH6) {
        Name (_DDN, "SerialIoUart6")
        Name (_UID, "SerialIoUart6")
        Method (_HID) { Return (UHID (UM06)) }
        Method (_CRS) { Return (UARH (UC06, UI06)) }
        Method (_STA) {
          If (LEqual (UM06, 3)) {
            If (LEqual (UP06, 2)) {
              Store (UAPG (UM06, UP06, UC06), UP06)
            }
            Return (0xF)
          }
          Return (0x8)
        }
        If (LEqual (UM06, 3)) {
          Method (_PSC) { Return (UPSC (UC06)) }
          Method (_PS3) { UPS3 (UP06, UC06) }
          Method (_PS0) { UPS0 (UP06, UC06) }
        }
      }
    }
  
  } //End Scope (\_SB)


  /**@file
   GPIO ASL library
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
    /**@file
     ACPI definition for GPIO controller for ADL
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
    #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioAcpiDefinesAdl.h"
/**@file
 VER4 GPIO ASL header

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/

//
// Definition for GPIO groups and pads
//



#line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioPinsVer4S.h"
/** @file
  GPIO pins for ADL-PCH-S,

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/



///
/// Unique ID used in GpioPad defines
///


///
/// ADL S GPIO Groups
/// Use below for functions from PCH GPIO Lib which
/// require GpioGroup as argument
///
















///
/// ADL S GPIO pins
/// Use below for functions from PCH GPIO Lib which
/// require GpioPad as argument. Encoding used here
/// has all information required by library functions
///






























































































































#line 170 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioPinsVer4S.h"
#line 15 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioAcpiDefinesAdl.h"



//
// ADL-PCH-S
//






























#line 52 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioAcpiDefinesAdl.h"
#line 8441 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
    
    Scope(\_SB) {
      //----------------------------
      //  GPIO Controller
      //----------------------------
      Device (GPI0)
      {
        Method (_HID) {
          // Return motherboard reserved resources HID when GPIO is hidden
          If (LEqual (GPHD, 1)) {
            Return ("PNP0C02")
          }
          Return ("INTC1056")
        }
    
        Name (LINK,"\\_SB.GPI0")
    
        Method (_CRS, 0x0, NotSerialized) {
          Name(RBFS,ResourceTemplate(){
            Interrupt (ResourceConsumer, Level, ActiveLow, Shared, , , IRQH) { 14 } //Interrupt IRQ_EN
            Memory32Fixed (ReadWrite, 0x00000000, 0x00010000, RBS0)
            Memory32Fixed (ReadWrite, 0x00000000, 0x00010000, RBS1)
            Memory32Fixed (ReadWrite, 0x00000000, 0x00010000, RBS3)
            Memory32Fixed (ReadWrite, 0x00000000, 0x00010000, RBS4)
            Memory32Fixed (ReadWrite, 0x00000000, 0x00010000, RBS5)
          })
          CreateDWordField(RBFS,IRQH._INT,INTH)
          Store(SGIR,INTH)
          CreateDWordField(RBFS,RBS0._BAS,CMH0)
          Store( Add(SBRG,0x006e0000), CMH0)
          CreateDWordField(RBFS,RBS1._BAS,CMH1)
          Store( Add(SBRG,0x006d0000), CMH1)
          CreateDWordField(RBFS,RBS3._BAS,CMH3)
          Store( Add(SBRG,0x006b0000), CMH3)
          CreateDWordField(RBFS,RBS4._BAS,CMH4)
          Store( Add(SBRG,0x006a0000), CMH4)
          CreateDWordField(RBFS,RBS5._BAS,CMH5)
          Store( Add(SBRG,0x00690000), CMH5)
          Return (RBFS)
        }
    
        Method (_STA, 0x0, NotSerialized) {
          If(LEqual(GPHD, 1)) { // Hide GPIO ACPI device
            Return(0x8)
          }
          Return(0xF)
        }
      } // END Device(GPIO)
    } // END Scope(\_SB.PC00)

    /**@file
     VER4 GPIO data for use with GPIO ASL lib
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
    #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\GpioAcpiDefines.h"
/**@file
 Defines for GPIO ACPI Interface

  Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/

//
// PCH GPIO Community address
//






#line 8499 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
    
    
    #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsGpio.h"
/** @file
  Register names for PCH GPIO

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/





//
// PADCFG register is split into multiple DW registers
// S_GPIO_PCR_PADCFG refers to number of bytes used by all those registers for one pad
//



//Interrupt number



//
// GPIO native features pins data
//



#line 31 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsGpio.h"
#line 8502 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
    #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsGpioVer4.h"
/** @file
  Register names for Ver4 GPIO

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/




//
// PCH-S GPIO
//
























//
// PCH-S GPIO registers
//
//
// GPIO Community Common Private Configuration Registers
//
















//
// GPIO Community 0 Private Configuration Registers
//













































































//
// GPIO Community 1 Private Configuration Registers
//



















































//
// GPIO Community 2 Private Configuration Registers
//





















//
// GPIO Community 3 Private Configuration Registers
//































































//
// GPIO Community 4 Private Configuration Registers
//
































































//
// GPIO Community 5 Private Configuration Registers
//



















































#line 407 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\Register/PchRegsGpioVer4.h"
#line 8503 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
    
    //
    // If in GPIO_GROUP_INFO structure certain register doesn't exist
    // it will have value equal to NO_REGISTER_FOR_PROPERTY
    //
    
    
    //
    // If in GPIO_GROUP_INFO structure certain group should not be used
    // by GPIO OS driver then "Gpio base number" field should be set to below value
    //
    
    
    //
    // GPIO Library objects
    //
    Scope(\_SB)
    {
      //
      // GPIO information data structure
      //
    
      //
      // GPIO information data structure for PCH-S
      //
      Name(GPCS, Package(){
        Package(){ // GPP_I
          0x006e0000,
          25,
          0x0700,
          0x0150,
          0x00A0,
          0x0240,
          0
        },
        Package(){ // GPP_R
          0x006e0000,
          23,
          0x0890,
          0x0154,
          0x00B0,
          0x0244,
          32
        },
        Package(){ // GPP_J
          0x006e0000,
          12,
          0x0A00,
          0x0158,
          0x00BC,
          0x0248,
          160
        },
        Package(){ // VGPIO
          0x006e0000,
          27,
          0x0AC0,
          0x015C,
          0x00C4,
          0x024C,
          96
        },
        Package(){ // VGPIO_0
          0x006e0000,
          8,
          0x0C70,
          0x0160,
          0x00D4,
          0x0250,
          128
        },
        Package(){ // GPP_B
          0x006d0000,
          24,
          0x0700,
          0x0150,
          0x00A0,
          0x0240,
          160
        },
        Package(){ // GPP_G
          0x006d0000,
          8,
          0x0880,
          0x0154,
          0x00AC,
          0x0244,
          192
        },
        Package(){ // GPP_H
          0x006d0000,
          24,
          0x0900,
          0x0158,
          0x00B0,
          0x0248,
          224
        },
        Package(){ // GPD
          0x006c0000,
          17,
          0x700,
          0x0150,
          0x00A0,
          0x0240,
          0 // TBD
        },
        Package(){ // SPI
          0x006b0000,
          9,
          0x0700,
          0x0150,
          0x00A0,
          0x0240,
          0 // TBD
        },
        Package(){ // GPP_A
          0x006b0000,
          16,
          0x0790,
          0x0154,
          0x00A8,
          0x0244,
          256
        },
        Package(){ // GPP_C
          0x006b0000,
          24,
          0x0890,
          0x0158,
          0x00B0,
          0x0248,
          288
        },
        Package(){ // VGPIO_3
          0x006b0000,
          84,
          0x0A10,
          0x015C,
          0x00BC,
          0x024C,
          115
        },
        Package(){ // GPP_S
          0x006a0000,
          8,
          0x0700,
          0x0150,
          0x00A0,
          0x0240,
          320
        },
        Package(){ // GPP_E
          0x006a0000,
          23,
          0x0780,
          0x0154,
          0x00A4,
          0x0244,
          352
        },
        Package(){ // GPP_K
          0x006a0000,
          15,
          0x08F0,
          0x0158,
          0x00B0,
          0x0248,
          384
        },
        Package(){ // GPP_F
          0x006a0000,
          24,
          0x09E0,
          0x015C,
          0x00B8,
          0x024C,
          416
        },
        Package(){ // GPP_D
          0x00690000,
          25,
          0x0700,
          0x0150,
          0x00A0,
          0x0240,
          448
        }
      })
    
      //
      // Object for storing RX Level/Edge Configuration for all pads.
      // One fields contains data for one pad.
      //   00b = Level
      //   01b = Edge (RxInv=0 for rising edge; 1 for falling edge)
      //   10b = Disabled
      //   11b = Either rising edge or falling edge
      //
      // Each row has data for one group. Buffer size needs
      // to equal to number of pads
      Name(RXEV, Package(){
        Buffer(25){},   // PCH-S: GPP_I
        Buffer(23){},   // PCH-S: GPP_R
        Buffer(12){},   // PCH-S: GPP_J
        Buffer(27){},   // PCH-S: VGPIO
        Buffer(8){}, // PCH-S: VGPIO0
        Buffer(24){},   // PCH-S: GPP_B
        Buffer(8){},   // PCH-S: GPP_G
        Buffer(24){},   // PCH-S: GPP_H
        Buffer(17){},     // PCH-S: GPD
        Buffer(9){},     // PCH-S: SPI
        Buffer(16){},   // PCH-S: GPP_A
        Buffer(24){},   // PCH-S: GPP_C
        Buffer(84){}, // PCH-S: VGPIO3
        Buffer(8){},   // PCH-S: GPP_S
        Buffer(23){},   // PCH-S: GPP_E
        Buffer(15){},   // PCH-S: GPP_K
        Buffer(24){},   // PCH-S: GPP_F
        Buffer(25){}    // PCH-S: GPP_D
      })
    }

    /**@file
     GPIO ASL library
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
    /**@file
     GPIO Common file with defines for ACPI GpioLibCommon and GpioXXX.asl (XXX - platform TGL, ADL, ...)
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
    //
    // Macro to retrieve data from GPIO information data structure (GpioLibObjects*.asl)
    //
    







    
    






    
    //
    // Check if group belongs to 2-Tier GPE
    //
    








    
    //
    // Get PADCFG_DW0 GpioPad register address
    //
    








    
    //
    // Get GPIO register address
    // If group has more DW registers for certain feature
    // below macro will return address of the first one.
    //
    
    
    
    
    
    
    //
    // Arg1 possible values for internal GINF function
    //
    
    
    
    
    
    
    

    
    //
    // GPIO Access Library
    //
    Scope(\_SB)
    {
      //
      // Get GPIO group information
      // This is internal library function
      //
      Method(GINF, 0x2, NotSerialized)
      {
        //
        // Arg0 - GPIO Group index
        // Arg1 - GPIO field type
        //
        Return (( DeRefOf(Index( DeRefOf(Index( GPCS, Arg0)), Arg1)) ))
      }
    
      //
      // Get GPIO maximal group
      // This is internal library function
      //
      Method(GMXG, 0x0, NotSerialized)
      {
        Return (19)
      }
    } // \_SB Scope
    
    /**@file
     GPIO Common library
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    **/
    
    //
    // GPIO Access Library
    //
    Scope(\_SB)
    {
      //
      // Get GPIO register address
      // This is internal library function
      //
      Method(GADR, 0x2, NotSerialized)
      {
        //
        // Arg0 - GPIO Group index
        // Arg1 - GPIO register type, must match what is used by GINF method
        //
        //Local0 = GpioCommunityAddress
        Store( Add(GINF(Arg0,0), SBRG), Local0)
    
        //Local1 = Register Offset
        Store(GINF(Arg0,Arg1), Local1)
    
        Return( Add (Local0, Local1))
      }
    
      //
      // Get GPIO absolute number for selected GpioPad
      //
      Method(GNUM, 0x1, NotSerialized)
      {
        //
        // Arg0 - GpioPad
        //
    
        // Local0 - Gpio pad number
        Store (GNMB(Arg0), Local0)
        // Local1 - Gpio group index for GpioPad
        Store (GGRP(Arg0), Local1)
    
        Return (Add(GINF(Local1,6),Local0))
      }
    
      //
      // Get interrupt number for selected GpioPad
      //
      Method(INUM, 0x1, NotSerialized)
      {
        //
        // Arg0 - GpioPad
        //
        return (And(GPC1(Arg0),0x7F))
      }
    
      //
      // Get GPIO group index for GpioPad
      //
      Method(GGRP,1,serialized) {
        //
        // Arg0 - GpioPad
        //
        ShiftRight( And(Arg0,0x00FF0000), 16, Local0)
        return (Local0)
      }
    
      //
      // Get GPIO pin number for GpioPad
      //
      Method(GNMB,1,serialized) {
        //
        // Arg0 - GpioPad
        //
        return (And(Arg0,0x0000FFFF))
      }
    
      //
      // GEI0/1/2 and GED0/1/2 (part of PCH NVS) are objects for informing how GPIO groups are mapped to GPE0.
      // If Group is mapped to 1-Tier GPE information is also stored on what Group DW
      // is mapped to GPE_DWx. Because GPE_DWx register is 32 bits large if groups have more than
      // 32 pads only part of it can be mapped.
      //
      //  GEIx - GroupIndex mapped to GPE0_DWx
      //  GEDx - DoubleWorld part of Group: 0 - pins 31-0, 1 - pins 63-32, ...
      //
    
      //
      // Get GPE number for selected GpioPad
      //
      Method(GGPE, 0x1, NotSerialized)
      {
        //
        // Arg0 - GPIO pad
        //
    
        //Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        //Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
        //Local2 - GPIO group DW
        Store(ShiftRight (Local1,5), Local2)
    
        If (( LNot( Or( Or( ( LAnd( LEqual(GEI0, Local0), LEqual(GED0, Local2) ) ), ( LAnd( LEqual(GEI1, Local0), LEqual(GED1, Local2) ) )), ( LAnd( LEqual(GEI2, Local0), LEqual(GED2, Local2) ) ))) )) {
          //
          // Pads mapped to 2-tier GPE will all generate GPE_111
          //
          Return (0x6F)
        } Else {
          //
          // Get mapping for certain group, Local3 = GPE0_DWx
          //
          If (( LAnd( LEqual(GEI0, Local0), LEqual(GED0, Local2) ) )) {
            Store(0, Local3)
          } ElseIf (( LAnd( LEqual(GEI1, Local0), LEqual(GED1, Local2) ) )) {
            Store(1, Local3)
          } ElseIf (( LAnd( LEqual(GEI2, Local0), LEqual(GED2, Local2) ) )) {
            Store(2, Local3)
          } Else {
            // Code should never get here
            BreakPoint
            Return (0)
          }
    
          //
          // For 1-tier GPE calculate GPE number
          // GPE number = Local1 + 32 * (Local3 - Local2)
          //
          Return (Add(Multiply(Subtract (Local3, Local2),32),Local1))
        }
      }
    
      //
      // Get Pad Configuration DW0 register value
      //
      Method(GPC0, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store(( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
        Return(TEMP)
      }
    
      //
      // Set Pad Configuration DW0 register value
      //
      Method(SPC0, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value for DW0 register
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Get Pad Configuration DW1 register value
      //
      Method(GPC1, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG) + 0x4
        Store( Add( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),0x4),Local2)
        OperationRegion(PDW1, SystemMemory, Local2, 4)
        Field(PDW1, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
        Return(TEMP)
      }
    
      //
      // Set Pad Configuration DW1 register value
      //
      Method(SPC1, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value for DW1 register
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local0 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG) + 0x4
        Store( Add( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),0x4),Local2)
        OperationRegion(PDW1, SystemMemory, Local2, 4)
        Field(PDW1, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Set RX Override
      //
      Method(SRXO, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - 0=no override, 1=drive RX to 1 internally
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
                ,28,
            TEMP,1,
                ,3
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Get GPI Input Value
      //
      Method(GGIV, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    1,
            TEMP,1,
            ,    30
        }
        Return(TEMP)
      }
    
      //
      // Get GPO Output Value
      //
      Method(GGOV, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,1,
            ,    31
        }
        Return(TEMP)
      }
    
      //
      // Set GPO Output Value
      //
      Method(SGOV, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value of GPIO Tx State
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,1,
            ,    31
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Get GPI Input Invert Bit
      //
      Method(GGII, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    23,
            TEMP,1,
            ,    8
        }
        Return(TEMP)
      }
    
      //
      // Set GPI Input Invert Bit
      //
      Method(SGII, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value of RXINV bit for selected pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    23,
            TEMP,1,
            ,    8
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Get GPIO Pad Mode
      //
      Method(GPMV, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    10,
            TEMP,3,
            ,    19
        }
        Return(TEMP)
      }
    
      //
      // Set GPIO Pad Mode
      //
      Method(SPMV, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value for Pad Mode for selected pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    10,
            TEMP,3,
            ,    19
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Get GPIO Host Software Pad Ownership
      //
      Method(GHPO, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
        // Local3 - Register offset = HostSwOwnRegOffset + (GpioPadNumber >> 5)*0x4
        Add (GADR(Local0,3), Multiply (ShiftRight(Local1,5), 0x4), Local3)
        // Local4 - Pad bit position within register, Local4 = GpioPad & 0x1F = GpioPad % 32
        And (Local1, 0x1F, Local4)
    
        OperationRegion(PREG, SystemMemory, Local3, 4)
        Field(PREG, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
        // HostSwOwnValue = (TEMP >> Local4) & 0x1
        Return( And( ShiftRight(TEMP,Local4),0x1))
      }
    
      //
      // Set GPIO Host Software Pad Ownership
      //
      Method(SHPO, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value for GPIO Host Software Pad Ownership
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
        // Local3 - Register offset = HostSwOwnRegOffset + (GpioPadNumber >> 5)*0x4
        Add (GADR(Local0,3), Multiply (ShiftRight(Local1,5), 0x4), Local3)
        // Local4 - Pad bit position within register, Local4 = GpioPad & 0x1F = GpioPad % 32
        And (Local1, 0x1F, Local4)
    
        OperationRegion(PREG, SystemMemory, Local3, 4)
        Field(PREG, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
    
        If (Arg1) {
          //TEMP = TEMP | (1 << PadBitPosition)
          Or(TEMP, ShiftLeft(1,Local4), TEMP)
        } Else {
          //TEMP = TEMP & ~(1 << PadBitPosition)
          And(TEMP, Not(ShiftLeft(1,Local4)),TEMP)
        }
      }
    
      //
      // Get GPIO Pad Ownership
      //
      Method(GGPO, 0x1, Serialized)
      {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = PadOwnAddress + (PadNumber >> 3) * 0x4
        Store( Add( GADR(Local0,4) , Multiply( ShiftRight(Local1,3),0x4)),Local2)
        OperationRegion(PREG, SystemMemory, Local2, 4)
        Field(PREG, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            TEMP,32
        }
        // PadOwnValue = (TEMP >> ((Local1 & 0x7) * 4)) & 0x3
        Return( And( ShiftRight(TEMP,Multiply(And(Local1,0x7),0x4)),0x3))
      }
    
      //
      // Set GPIO GPIRoutIOxAPIC value
      //
      Method(SGRA, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value for GPIRoutIOxAPIC
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    20,
            TEMP,1,
            ,    11
        }
        Store(Arg1,TEMP)
      }
    
      //
      // Set GPIO weak pull-up/down value
      //
      Method(SGWP, 0x2, Serialized)
      {
        //
        // Arg0 - GPIO pad
        // Arg1 - Value for weak pull-up/down
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + 0x4 + (GPIn * S_GPIO_PCR_PADCFG)
        Store( Add( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),0x4),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    10,
            TEMP,4,
            ,    18
        }
        Store(Arg1,TEMP)
      }
    
      //
      // ISME and CAGS methods are used to properly handle 2-tier GPE
      // Example:
      /*
        Method(_L6F, 0) // Method which is called for all 2-tier GPE, must be within _GPE scope
        {
          If (\_SB.ISME(GpioPad))
            {
              \_SB.DeviceXYZ.GPEH() // Custom function to handle GPE for certain GPIO pad
              \_SB.CAGS(GpioPad)    // Clear 2-Tier GPE status
            }
        }
      */
    
      //
      // Clear a particular GPE status for 2-tier
      //
      Method(CAGS, 0x1, Serialized) {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
        //Local4 - GPIO group DW
        Store(ShiftRight (Local1,5), Local4)
    
        //Check if 2-tier
        If (( LNot( Or( Or( ( LAnd( LEqual(GEI0, Local0), LEqual(GED0, Local4) ) ), ( LAnd( LEqual(GEI1, Local0), LEqual(GED1, Local4) ) )), ( LAnd( LEqual(GEI2, Local0), LEqual(GED2, Local4) ) ))) )) {
          //Get GPI_GPE_STS for GPP_x
          Store (GADR(Local0,5), Local3)
          If (LNotEqual(And(Local3,0xFFFF), 0xFFFF))  {
            OperationRegion(GPPX, SystemMemory, Add(Local3,Multiply(Local4,4)), 4)
            Field(GPPX, AnyAcc, NoLock, Preserve) {
              Offset(0x0),
              STSX,32,
            }
            // Local2 - GpioPad bit mask within register
            ShiftLeft(1, Mod(Local1,32), Local2)
            // Clear GPIO status by writing 1b for a pad
            Store(Local2, STSX)
          }
        }
      }
    
      //
      // Check if GPIO pad was source of 2-Tier GPE event
      //
      Method(ISME, 0x1, Serialized) {
        //
        // Arg0 - GPIO pad
        //
    
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
        //Local4 - GPIO group DW
        Store(ShiftRight (Local1,5), Local4)
    
        If (LNot(( LNot( Or( Or( ( LAnd( LEqual(GEI0, Local0), LEqual(GED0, Local4) ) ), ( LAnd( LEqual(GEI1, Local0), LEqual(GED1, Local4) ) )), ( LAnd( LEqual(GEI2, Local0), LEqual(GED2, Local4) ) ))) ))) {
          Return(0)
        }
    
        If (LEqual(And(GADR(Local0,5),0xFFFF), 0xFFFF))  {
          Return(0)
        }
    
        // Local2 - Register offset = GpeStsRegOffset + GpioGroupDw*0x4
        Add (GADR(Local0,5), Multiply (Local4, 0x4), Local2)
        // Local3 - Pad bit position within register, Local3 = GpioPadNumber & 0x1F = GpioPadNumber % 32
        And (Local1, 0x1F, Local3)
    
        OperationRegion(GPPX, SystemMemory, Local2, 0x24)
        Field(GPPX, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            STSX,32,
          Offset(0x20),
            GENX,32
        }
    
        //Return result of GPI_GPE_EN&GPI_GPE_STS for this pad
        Return(And(ShiftRight(And(STSX,GENX),Local3),0x1))
      }
    
      //
      // Do Interrupt Pin Isolation
      // This method should be called before power gating external device
      // which uses Gpio pad as an interrupt
      //
      Method(DIPI, 0x1, Serialized) {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    9,
            RDIS,1,
            ,   15,
            RCFG,2,
            ,    5
        }
        If(LNotEqual(RCFG,2)) {
          // Save RxEvCfg state in RXEV object:
          // RXEV[GroupIndex][PadNumber] =  RCFG
          Store(RCFG, Index( DeRefOf(Index(RXEV,Local0)), Local1))
          // Set RxEvCfg to 2
          Store(2,RCFG)
          // Set GPIORxDis to 1
          Store(1,RDIS)
        }
      }
    
      //
      // Undo Interrupt Pin Isolation
      // This method should be called after un-power gating external device
      // which uses Gpio pad as an interrupt
      //
      Method(UIPI, 0x1, Serialized) {
        //
        // Arg0 - GPIO pad
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,    9,
            RDIS,1,
            ,   15,
            RCFG,2,
            ,    5
        }
        // Get RxEvCfg original value from RXEV object
        // Local3 = RXEV[GroupIndex][PadNumber]
        Store( DeRefOf(Index( DeRefOf(Index (RXEV, Local0)), Local1)), Local3)
    
        If(LNotEqual(Local3,2)) {
          // Set GPIORxDis to 0
          Store(0,RDIS)
          // Set RxEvCfg to original value
          Store(Local3,RCFG)
        }
      }
    
      //
      // RX Level/Edge Configuration
      //
      Method(GRXE, 0x2, Serialized) {
        //
        // Arg0 - GPIO pad
        // Arg1 - RxEvCfg Value
        //        0h = Level
        //        1h = Edge
        //        2h = Disable
        //        3h = Either rising edge or failing edge
        //
        // Local0 - GPIO group index
        Store (GGRP(Arg0), Local0)
        // Local1 - GPIO pad number
        Store (GNMB(Arg0), Local1)
    
        // Local2 = (GpioCommunityAddress + PadCfgOffset) + (GPIn * S_GPIO_PCR_PADCFG)
        Store( ( Add( GADR(Local0,2), Multiply( Local1, 0x10) ) ),Local2)
        OperationRegion(PDW0, SystemMemory, Local2, 4)
        Field(PDW0, AnyAcc, NoLock, Preserve) {
          Offset(0x0),
            ,   25,
            RCFG,2,
            ,    5
        }
        // Set RxEvCfg
        Store(Arg1, RCFG)
      }
    }


  





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 10768 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"

  //
  // SCS UFS controllers
  //
  /**@file
    ACPI DSDT table for SCS UFS Controllers
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  External(UF0E)
  External(UF1E)
  External(ULTR, MethodObj)
  External(PCRA, MethodObj)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
    Method (OCPD, 0, Serialized) {
      PCRA (0x50, 0x4020, 0x0)
      PCRA (0x50, 0x4820, 0x0)
      PCRA (0x50, 0x5C20, 0x0)
      PCRA (0x50, 0x5820, 0x0)
      PCRA (0x50, 0x1078, 0x0)
    }
  
    If (LEqual (UF0E, 1)) {
      //
      // SCS UFS0 (PCI Mode)
      //
      Device(PUF0) {
        Name(_ADR, 0x00120005)
        Name (_DDN, "Intel(R) UFS Controller 0")
  
        // Memory Region to access to the UFS PCI Configuration Space
        OperationRegion(SCSR, PCI_Config, 0x00, 0x100)
        Field(SCSR, ByteAcc, NoLock, Preserve) {
          Offset(0x84),         // 0x84, PMCSR - Power Management Control and Status
          PSTA,32,
          Offset(0xA2),   // 0xA2, Device PG config
              , 2,
          PGEN, 1         // [BIT2] PGE - PG Enable
        }
  
        Method(_PS0, 0, Serialized) {
          Store(0, PGEN) // Disable PG
  
          And(PSTA, 0xFFFFFFFC, PSTA) // Set BIT[1:0] = 00b - Power State D0
          Store(PSTA, TEMP) // Read Back PMCSR
          //
          // Remove UFS LTR disqualification
          // Clear IGN_UFS2x bit of PMC GCR space has register LTR_IGN
          //
          ULTR (0)
          //
          // Disable OCP Timer in SCS UFS IOSF Bridge
          //
          OCPD ()
        }
  
        Method(_PS3, 0, Serialized) {
          //
          // Add UFS LTR disqualification
          // Set IGN_UFS2x bit of PMC GCR space has register LTR_IGN
          //
          ULTR (1)
          Store(1, PGEN) // Enable PG
        }
  
        Device (CARD) {
          Name (_ADR, 0x00000008) // Slot 0, Function 8
          Method(_RMV, 0x0, NotSerialized) { Return (0) } // Device cannot be removed
        }
      }
    } //UF0E
  
    If (LEqual (\UF1E, 1)) {
      //
      // SCS UFS1 (PCI Mode)
      //
      Device(PUF1) {
        Name(_ADR, 0x00120007)
        Name (_DDN, "Intel(R) UFS Controller 1")
  
        // Memory Region to access to the UFS PCI Configuration Space
        OperationRegion(SCSR, PCI_Config, 0x00, 0x100)
        Field(SCSR, ByteAcc, NoLock, Preserve) {
          Offset(0x84),         // 0x84, PMCSR - Power Management Control and Status
          PSTA,32,
          Offset(0xA2),   // 0xA2, Device PG config
              , 2,
          PGEN, 1         // [BIT2] PGE - PG Enable
        }
  
        Method(_PS0, 0, Serialized) {
          Store(0, PGEN) // Disable PG
  
          And(PSTA, 0xFFFFFFFC, PSTA) // Set BIT[1:0] = 00b - Power State D0
          Store(PSTA, TEMP) // Read Back PMCSR
          //
          // Remove UFS LTR disqualification
          // Clear IGN_UFS2x bit of PMC GCR space has register LTR_IGN
          //
          ULTR (0)
          //
          // Disable OCP Timer in SCS UFS IOSF Bridge
          //
          OCPD ()
        }
  
        Method(_PS3, 0, Serialized) {
          //
          // Add UFS LTR disqualification
          // Set IGN_UFS2x bit of PMC GCR space has register LTR_IGN
          //
          ULTR (1)
  
          Store(1, PGEN) // Enable PG
        }
  
        Device (CARD) {
          Name (_ADR, 0x00000008) // Slot 0, Function 8
          Method(_RMV, 0x0, NotSerialized) { Return (0) } // Device cannot be removed
        }
      }
    } //UF1E
  }

  //
  // Integrated Connectivity definition
  //
  //Include ("CnviCommon.asl")
  //Include ("CnviAdl.asl")
  
  //
  // PCI Express definition
  //
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  External(VMDE)
  External(VMR1)
  External(VMR2)
  External(VMR3)
  External(VMR4)
  External(PINI, MethodObj) // Platform specific PCIe root port initialization.
  External(\STD3, FieldUnitObj) // 1: D3Cold support for Storage 0: D3Hot support for Storage.
  
  Scope(\_SB.PC00) {
  
    Name (SIPV, 0)
  
    //
    // Method returns SIP version
    //
    Method (GSIP, 0) {
      If (LEqual (PCHS, 5)) {
        Return (14)
      } Else {
        Return (17)
      }
    }
  
  
    //
    // PCIE Root Port #01
    //
    Device (RP01) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA1, 0)) {
          Return (RPA1)
        } Else {
          Return (0x001C0000)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 1)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR1, LTEN)
        Store (PML1, LMSL)
        Store (PNL1, LNSL)
        If (HBSL & 0x01) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x01), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP01.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP01.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP01.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP01)) {
                If(LNotEqual(\_SB.PC00.RP01.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP01.PRMV)) {
                      If (LEqual (\_SB.PC00.RP01.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP01.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP01.PXSX.PNVM(),\_SB.PC00.RP01.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP01.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 11455 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#01"
  
    //
    // PCIE Root Port #02
    //
    Device (RP02) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA2, 0)) {
          Return (RPA2)
        } Else {
          Return (0x001C0001)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 2)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR2, LTEN)
        Store (PML2, LMSL)
        Store (PNL2, LNSL)
        If (HBSL & 0x01) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x02), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP02.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP02.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP02.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP02)) {
                If(LNotEqual(\_SB.PC00.RP02.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP02.PRMV)) {
                      If (LEqual (\_SB.PC00.RP02.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP02.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP02.PXSX.PNVM(),\_SB.PC00.RP02.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP02.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 11972 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port #02"
  
    //
    // PCIE Root Port #03
    //
    Device (RP03) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA3, 0)) {
          Return (RPA3)
        } Else {
          Return (0x001C0002)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 3)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR3, LTEN)
        Store (PML3, LMSL)
        Store (PNL3, LNSL)
        If (HBSL & 0x01) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x04), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP03.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP03.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP03.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP03)) {
                If(LNotEqual(\_SB.PC00.RP03.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP03.PRMV)) {
                      If (LEqual (\_SB.PC00.RP03.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP03.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP03.PXSX.PNVM(),\_SB.PC00.RP03.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP03.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 12489 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#03"
  
    //
    // PCIE Root Port #04
    //
    Device (RP04) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA4, 0)) {
          Return (RPA4)
        } Else {
          Return (0x001C0003)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 4)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR4, LTEN)
        Store (PML4, LMSL)
        Store (PNL4, LNSL)
        If (HBSL & 0x01) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x08), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP04.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP04.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP04.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP04)) {
                If(LNotEqual(\_SB.PC00.RP04.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP04.PRMV)) {
                      If (LEqual (\_SB.PC00.RP04.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP04.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP04.PXSX.PNVM(),\_SB.PC00.RP04.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP04.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 13006 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#04"
  
    //
    // PCIE Root Port #05
    //
    Device (RP05) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA5, 0)) {
          Return (RPA5)
        } Else {
          Return (0x001C0004)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 5)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR5, LTEN)
        Store (PML5, LMSL)
        Store (PNL5, LNSL)
        If (HBSL & 0x02) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x10), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP05.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP05.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP05.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP05)) {
                If(LNotEqual(\_SB.PC00.RP05.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP05.PRMV)) {
                      If (LEqual (\_SB.PC00.RP05.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP05.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP05.PXSX.PNVM(),\_SB.PC00.RP05.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP05.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#05"
  
    //
    // PCIE Root Port #06
    //
    Device (RP06) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA6, 0)) {
          Return (RPA6)
        } Else {
          Return (0x001C0005)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 6)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR6, LTEN)
        Store (PML6, LMSL)
        Store (PNL6, LNSL)
        If (HBSL & 0x02) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x20), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP06.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP06.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP06.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP06)) {
                If(LNotEqual(\_SB.PC00.RP06.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP06.PRMV)) {
                      If (LEqual (\_SB.PC00.RP06.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP06.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP06.PXSX.PNVM(),\_SB.PC00.RP06.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP06.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 14025 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#06"
  
    //
    // PCIE Root Port #07
    //
    Device (RP07) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA7, 0)) {
          Return (RPA7)
        } Else {
          Return (0x001C0006)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 7)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR7, LTEN)
        Store (PML7, LMSL)
        Store (PNL7, LNSL)
        If (HBSL & 0x02) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x40), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP07.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP07.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP07.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP07)) {
                If(LNotEqual(\_SB.PC00.RP07.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP07.PRMV)) {
                      If (LEqual (\_SB.PC00.RP07.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP07.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP07.PXSX.PNVM(),\_SB.PC00.RP07.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP07.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 14542 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#07"
  
    //
    // PCIE Root Port #08
    //
    Device (RP08) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA8, 0)) {
          Return (RPA8)
        } Else {
          Return (0x001C0007)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 8)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR8, LTEN)
        Store (PML8, LMSL)
        Store (PNL8, LNSL)
        If (HBSL & 0x02) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR1),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR1, 0x80), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP08.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP08.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP08.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP08)) {
                If(LNotEqual(\_SB.PC00.RP08.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP08.PRMV)) {
                      If (LEqual (\_SB.PC00.RP08.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP08.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP08.PXSX.PNVM(),\_SB.PC00.RP08.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP08.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 15059 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#08"
  
    //
    // PCIE Root Port #09
    //
    Device (RP09) {
      Method (_ADR, 0) {
        If (LNotEqual (RPA9, 0)) {
          Return (RPA9)
        } Else {
          Return (0x001D0000)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 9)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTR9, LTEN)
        Store (PML9, LMSL)
        Store (PNL9, LNSL)
        If (HBSL & 0x04) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x01), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP09.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP09.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP09.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP09)) {
                If(LNotEqual(\_SB.PC00.RP09.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP09.PRMV)) {
                      If (LEqual (\_SB.PC00.RP09.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP09.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP09.PXSX.PNVM(),\_SB.PC00.RP09.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP09.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#09"
  
    //
    // PCIE Root Port #10
    //
    Device (RP10) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAA, 0)) {
          Return (RPAA)
        } Else {
          Return (0x001D0001)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 10)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRA, LTEN)
        Store (PMLA, LMSL)
        Store (PNLA, LNSL)
        If (HBSL & 0x04) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x02), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP10.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP10.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP10.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP10)) {
                If(LNotEqual(\_SB.PC00.RP10.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP10.PRMV)) {
                      If (LEqual (\_SB.PC00.RP10.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP10.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP10.PXSX.PNVM(),\_SB.PC00.RP10.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP10.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 16078 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#10"
  
    //
    // PCIE Root Port #11
    //
    Device (RP11) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAB, 0)) {
          Return (RPAB)
        } Else {
          Return (0x001D0002)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 11)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRB, LTEN)
        Store (PMLB, LMSL)
        Store (PNLB, LNSL)
        If (HBSL & 0x04) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x04), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP11.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP11.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP11.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP11)) {
                If(LNotEqual(\_SB.PC00.RP11.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP11.PRMV)) {
                      If (LEqual (\_SB.PC00.RP11.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP11.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP11.PXSX.PNVM(),\_SB.PC00.RP11.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP11.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 16595 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#11"
  
    //
    // PCIE Root Port #12
    //
    Device (RP12) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAC, 0)) {
          Return (RPAC)
        } Else {
          Return (0x001D0003)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 12)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRC, LTEN)
        Store (PMLC, LMSL)
        Store (PNLC, LNSL)
        If (HBSL & 0x04) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x08), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP12.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP12.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP12.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP12)) {
                If(LNotEqual(\_SB.PC00.RP12.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP12.PRMV)) {
                      If (LEqual (\_SB.PC00.RP12.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP12.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP12.PXSX.PNVM(),\_SB.PC00.RP12.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP12.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 17112 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#12"
  
    //
    // PCIE Root Port #13
    //
    Device (RP13) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAD, 0)) {
          Return (RPAD)
        } Else {
          Return (0x001D0004)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 13)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRD, LTEN)
        Store (PMLD, LMSL)
        Store (PNLD, LNSL)
        If (HBSL & 0x08) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x10), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP13.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP13.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP13.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP13)) {
                If(LNotEqual(\_SB.PC00.RP13.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP13.PRMV)) {
                      If (LEqual (\_SB.PC00.RP13.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP13.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP13.PXSX.PNVM(),\_SB.PC00.RP13.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP13.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 17629 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#13"
  
    //
    // PCIE Root Port #14
    //
    Device (RP14) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAE, 0)) {
          Return (RPAE)
        } Else {
          Return (0x001D0005)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 14)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRE, LTEN)
        Store (PMLE, LMSL)
        Store (PNLE, LNSL)
        If (HBSL & 0x08) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x20), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP14.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP14.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP14.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP14)) {
                If(LNotEqual(\_SB.PC00.RP14.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP14.PRMV)) {
                      If (LEqual (\_SB.PC00.RP14.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP14.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP14.PXSX.PNVM(),\_SB.PC00.RP14.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP14.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 18146 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#14"
  
    //
    // PCIE Root Port #15
    //
    Device (RP15) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAF, 0)) {
          Return (RPAF)
        } Else {
          Return (0x001D0006)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 15)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRF, LTEN)
        Store (PMLF, LMSL)
        Store (PNLF, LNSL)
        If (HBSL & 0x08) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x40), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP15.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP15.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP15.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP15)) {
                If(LNotEqual(\_SB.PC00.RP15.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP15.PRMV)) {
                      If (LEqual (\_SB.PC00.RP15.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP15.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP15.PXSX.PNVM(),\_SB.PC00.RP15.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP15.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 18663 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#15"
  
    //
    // PCIE Root Port #16
    //
    Device (RP16) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAG, 0)) {
          Return (RPAG)
        } Else {
          Return (0x001D0007)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 16)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRG, LTEN)
        Store (PMLG, LMSL)
        Store (PNLG, LNSL)
        If (HBSL & 0x08) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR2),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR2, 0x80), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP16.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP16.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP16.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP16)) {
                If(LNotEqual(\_SB.PC00.RP16.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP16.PRMV)) {
                      If (LEqual (\_SB.PC00.RP16.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP16.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP16.PXSX.PNVM(),\_SB.PC00.RP16.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP16.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 19180 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#16"
  
    //
    // PCIE Root Port #17
    //
    Device (RP17) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAH, 0)) {
          Return (RPAH)
        } Else {
          Return (0x001B0000)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 17)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRH, LTEN)
        Store (PMLH, LMSL)
        Store (PNLH, LNSL)
        If (HBSL & 0x10) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x01), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP17.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP17.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP17.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP17)) {
                If(LNotEqual(\_SB.PC00.RP17.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP17.PRMV)) {
                      If (LEqual (\_SB.PC00.RP17.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP17.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP17.PXSX.PNVM(),\_SB.PC00.RP17.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP17.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 19697 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#17"
  
    //
    // PCIE Root Port #18
    //
    Device (RP18) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAI, 0)) {
          Return (RPAI)
        } Else {
          Return (0x001B0001)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 18)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRI, LTEN)
        Store (PMLI, LMSL)
        Store (PNLI, LNSL)
        If (HBSL & 0x10) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x02), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP18.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP18.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP18.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP18)) {
                If(LNotEqual(\_SB.PC00.RP18.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP18.PRMV)) {
                      If (LEqual (\_SB.PC00.RP18.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP18.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP18.PXSX.PNVM(),\_SB.PC00.RP18.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP18.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 20214 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#18"
  
    //
    // PCIE Root Port #19
    //
    Device (RP19) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAJ, 0)) {
          Return (RPAJ)
        } Else {
          Return (0x001B0002)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 19)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRJ, LTEN)
        Store (PMLJ, LMSL)
        Store (PNLJ, LNSL)
        If (HBSL & 0x10) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x04), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP19.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP19.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP19.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP19)) {
                If(LNotEqual(\_SB.PC00.RP19.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP19.PRMV)) {
                      If (LEqual (\_SB.PC00.RP19.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP19.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP19.PXSX.PNVM(),\_SB.PC00.RP19.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP19.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 20731 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#19"
  
    //
    // PCIE Root Port #20
    //
    Device (RP20) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAK, 0)) {
          Return (RPAK)
        } Else {
          Return (0x001B0003)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 20)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRK, LTEN)
        Store (PMLK, LMSL)
        Store (PNLK, LNSL)
        If (HBSL & 0x10) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x08), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP20.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP20.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP20.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP20)) {
                If(LNotEqual(\_SB.PC00.RP20.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP20.PRMV)) {
                      If (LEqual (\_SB.PC00.RP20.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP20.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP20.PXSX.PNVM(),\_SB.PC00.RP20.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP20.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 21248 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#20"
  
    //
    // PCIE Root Port #21
    //
    Device (RP21) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAL, 0)) {
          Return (RPAL)
        } Else {
          Return (0x001B0004)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 21)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRL, LTEN)
        Store (PMLL, LMSL)
        Store (PNLL, LNSL)
        If (HBSL & 0x20) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x10), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP21.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP21.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP21.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP21)) {
                If(LNotEqual(\_SB.PC00.RP21.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP21.PRMV)) {
                      If (LEqual (\_SB.PC00.RP21.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP21.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP21.PXSX.PNVM(),\_SB.PC00.RP21.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP21.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#21"
  
    //
    // PCIE Root Port #22
    //
    Device (RP22) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAM, 0)) {
          Return (RPAM)
        } Else {
          Return (0x001B0005)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 22)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRM, LTEN)
        Store (PMLM, LMSL)
        Store (PNLM, LNSL)
        If (HBSL & 0x20) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x20), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP22.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP22.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP22.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP22)) {
                If(LNotEqual(\_SB.PC00.RP22.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP22.PRMV)) {
                      If (LEqual (\_SB.PC00.RP22.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP22.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP22.PXSX.PNVM(),\_SB.PC00.RP22.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP22.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 22267 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#22"
  
    //
    // PCIE Root Port #23
    //
    Device (RP23) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAN, 0)) {
          Return (RPAN)
        } Else {
          Return (0x001B0006)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 23)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRN, LTEN)
        Store (PMLN, LMSL)
        Store (PNLN, LNSL)
        If (HBSL & 0x20) {
          Store (1, HBCS)
        }
        If(LAnd(CondRefOf(VMR3),CondRefOf(VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x40), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP23.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP23.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP23.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP23)) {
                If(LNotEqual(\_SB.PC00.RP23.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP23.PRMV)) {
                      If (LEqual (\_SB.PC00.RP23.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP23.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP23.PXSX.PNVM(),\_SB.PC00.RP23.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP23.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 22784 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#23"
  
    //
    // PCIE Root Port #24
    //
    Device (RP24) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAO, 0)) {
          Return (RPAO)
        } Else {
          Return (0x001B0007)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 24)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRO, LTEN)
        Store (PMLO, LMSL)
        Store (PNLO, LNSL)
        If (HBSL & 0x20) {
          Store (1, HBCS)
        }
        If (LAnd (CondRefOf (VMR3), CondRefOf (VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR3, 0x80), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP24.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP24.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP24.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP24)) {
                If(LNotEqual(\_SB.PC00.RP24.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP24.PRMV)) {
                      If (LEqual (\_SB.PC00.RP24.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP24.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP24.PXSX.PNVM(),\_SB.PC00.RP24.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP24.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 23301 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#24"
  
    //
    // PCIE Root Port #25
    //
    Device (RP25) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAP, 0)) {
          Return (RPAP)
        } Else {
          Return (0x001A0000)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 25)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRP, LTEN)
        Store (PMLP, LMSL)
        Store (PNLP, LNSL)
        If (HBSL & 0x40) {
          Store (1, HBCS)
        }
        If (LAnd (CondRefOf (VMR4), CondRefOf (VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR4, 0x01), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP25.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP25.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP25.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP25)) {
                If(LNotEqual(\_SB.PC00.RP25.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP25.PRMV)) {
                      If (LEqual (\_SB.PC00.RP25.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP25.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP25.PXSX.PNVM(),\_SB.PC00.RP25.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP25.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 23818 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR04)
          }                                          // APIC mode
        }
        Return (PD04)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#21"
  
    //
    // PCIE Root Port #26
    //
    Device (RP26) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAQ, 0)) {
          Return (RPAQ)
        } Else {
          Return (0x001A0001)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 26)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRQ, LTEN)
        Store (PMLQ, LMSL)
        Store (PNLQ, LNSL)
        If (HBSL & 0x40) {
          Store (1, HBCS)
        }
        If (LAnd (CondRefOf (VMR4), CondRefOf (VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR4, 0x02), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP26.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP26.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP26.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP26)) {
                If(LNotEqual(\_SB.PC00.RP26.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP26.PRMV)) {
                      If (LEqual (\_SB.PC00.RP26.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP26.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP26.PXSX.PNVM(),\_SB.PC00.RP26.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP26.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 24335 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR05)
          }                                          // APIC mode
        }
        Return (PD05)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#26"
  
    //
    // PCIE Root Port #27
    //
    Device (RP27) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAR, 0)) {
          Return (RPAR)
        } Else {
          Return (0x001A0002)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 27)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRR, LTEN)
        Store (PMLR, LMSL)
        Store (PNLR, LNSL)
        If (HBSL & 0x40) {
          Store (1, HBCS)
        }
        If (LAnd (CondRefOf (VMR4), CondRefOf (VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR4, 0x04), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP27.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP27.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP27.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP27)) {
                If(LNotEqual(\_SB.PC00.RP27.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP27.PRMV)) {
                      If (LEqual (\_SB.PC00.RP27.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP27.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP27.PXSX.PNVM(),\_SB.PC00.RP27.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP27.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 24852 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR06)
          }                                          // APIC mode
        }
        Return (PD06)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#27"
  
    //
    // PCIE Root Port #28
    //
    Device (RP28) {
      Method (_ADR, 0) {
        If (LNotEqual (RPAS, 0)) {
          Return (RPAS)
        } Else {
          Return (0x001A0003)
        }
      }
      //
      // Pass LTRx to LTEN so PchPcieCommon.asl can be reused for PCIes.
      //
      Name (SLOT, 28)
      Name (LTEN, 0)
      Name (LMSL, 0)
      Name (LNSL, 0)
      Method (_INI)
      {
        Store (LTRS, LTEN)
        Store (PMLS, LMSL)
        Store (PNLS, LNSL)
        If (HBSL & 0x40) {
          Store (1, HBCS)
        }
        If (LAnd (CondRefOf (VMR4), CondRefOf (VMDE))) {
          If (LAnd (LEqual (VMDE, 1), LNotEqual (And (VMR4, 0x08), 0))) {
            Store (1, PRMV)
          }
        }
        If (PRES()) {
          If(CondRefOf(PINI)) {
            PINI()
          }
        }
  
        //
        // RP D3Cold/D3hot support status for Storage devices
        //
        
        /**@file
        
          ACPI D3Cold/D3hot support for Storage device connected to PCIE Root Port
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
              External(\_SB.PC00.RP28.PXSX.PNVM, MethodObj, IntObj)
              External(\_SB.PC00.RP28.PXSX.PAHC, MethodObj, IntObj)
              External(\_SB.PC00.RP28.VDID, FieldUnitObj)
        
              //
              // 1. Check if Root Port exists.
              // 2. Check if Root Port is mapped under VMD.
              // 2. Check for a storage device.
              //
              If (CondRefOf(\_SB.PC00.RP28)) {
                If(LNotEqual(\_SB.PC00.RP28.VDID,0xFFFFFFFF)) {
                  If (CondRefOf(\STD3)) {
                    If (CondRefOf(\_SB.PC00.RP28.PRMV)) {
                      If (LEqual (\_SB.PC00.RP28.PRMV, 1)) {
                        Store(\STD3, \_SB.PC00.RP28.RD3C)
                      }
                    }
        
                    If(LOr(\_SB.PC00.RP28.PXSX.PNVM(),\_SB.PC00.RP28.PXSX.PAHC())) {
                      Store(\STD3, \_SB.PC00.RP28.RD3C)
                    }
                  }
                }
              }

        
      }
      Store (GSIP (), SIPV)
      /** @file
        This file contains the PCIe Root Port Common configuration
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      **/
      
        External(PINI, MethodObj) // Platform specific PCIe root port initialization.
        External(\_SB.PC00.PC2M, MethodObj)
        External(PPBA, MethodObj) // PCIe power budget allocation
        External(UPRD, MethodObj) // PCIe update PERST# assertion delay
        External(PPS0, MethodObj) // Platform specific PCIe root port _PS0 Hook Function.
        External(PPS3, MethodObj) // Platform specific PCIe root port _PS3 Hook Function.
      
        Name (PRTP, 0x02) // PCIE RP TYPE
      
        OperationRegion(PXCS,SystemMemory,\_SB.PC00.PC2M(_ADR()),0x480)
        Field(PXCS,AnyAcc, NoLock, Preserve)
        {
          Offset(0),
          VDID, 32,
          Offset(0x50),                      // LCTL - Link Control Register
          L0SE, 1,                           // 0, L0s Entry Enabled
          , 3,
          LDIS, 1,
          , 3,
          Offset(0x52),                      // LSTS - Link Status Register
          , 13,
          LASX, 1,                           // 0, Link Active Status
          Offset(0x5A),                      // SLSTS[7:0] - Slot Status Register
          ABPX, 1,                           // 0, Attention Button Pressed
          , 2,
          PDCX, 1,                           // 3, Presence Detect Changed
          , 2,
          PDSX, 1,                           // 6, Presence Detect State
          , 1,
          Offset(0x60),                      // RSTS - Root Status Register
          , 16,
          PSPX, 1,                           // 16,  PME Status
          Offset(0xA4),                      // PMCSR
          D3HT, 2,                           // PowerState
          Offset(0xD8),        // 0xD8, MPC - Miscellaneous Port Configuration Register
          , 30,
          HPEX, 1,                           // 30,  Hot Plug SCI Enable
          PMEX, 1,                           // 31,  Power Management SCI Enable
          Offset(0xE0),        // 0xE0, SPR - Scratch Pad Register
          SCB0, 1,                           // Scratchpad register SPR[0] (SCB)
          , 6,
          NCB7, 1,                           // Non-Sticky Scratch Pad Bit (NSCB)[7]
          Offset(0xE2),     // 0xE2, RPPGEN - Root Port Power Gating Enable
          , 2,
          L23E, 1,                           // 2,   L23_Rdy Entry Request (L23ER)
          L23R, 1,                           // 3,   L23_Rdy to Detect Transition (L23R2DT)
          Offset(0x328),                     // 0x328, PCI Express Status 1
          , 19,
          LNKS, 4,                           // Link Status
        }
        Field(PXCS,AnyAcc, NoLock, WriteAsZeros)
        {
          Offset(0xDC),      // 0xDC, SMSCS - SMI/SCI Status Register
          , 30,
          HPSX, 1,                           // 30,  Hot Plug SCI Status
          PMSX, 1                            // 31,  Power Management SCI Status
        }
      
        //
        // L23D method recovers link from L2 or L3 state. Used for RTD3 flows, right after endpoint is powered up and exits reset.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (L23D, 0, Serialized) {
          If (LLess (SIPV, 16)) {
            If(LNotEqual(NCB7,0x1)) {
              Return()
            }
          } Else {
            If(LNotEqual(SCB0,0x1)) {
              Return()
            }
          }
          /// Set L23_Rdy to Detect Transition  (L23R2DT)
          Store(1, L23R)
          Store(0, Local0)
          /// Wait for transition to Detect
          While(L23R) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
          If (LLess (SIPV, 16)) {
            Store(0, NCB7)
          } Else {
            Store(0, SCB0)
          }
      
          /// Once in Detect, wait up to 124 ms for Link Active (typically happens in under 70ms)
          /// Worst case per PCIe spec from Detect to Link Active is:
          /// 24ms in Detect (12+12), 72ms in Polling (24+48), 28ms in Config (24+2+2+2+2)
          Store(0, Local0)
          While(LEqual(LASX,0)) {
            If(Lgreater(Local0, 8))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
        }
      
        //
        // DL23 method puts link to L2 or L3 state. Used for RTD3 flows, before endpoint is powered down.
        // This flow is implemented in ASL because rootport registers used for L2/L3 entry/exit
        // are proprietary and OS drivers don't know about them.
        //
        Method (DL23, 0, Serialized) {
          Store(1, L23E)
          Sleep(16)
          Store(0, Local0)
          While(L23E) {
            If(Lgreater(Local0, 4))
            {
              Break
            }
            Sleep(16)
            Increment(Local0)
          }
      
          If (LLess (SIPV, 16)) {
            Store(1, NCB7)
          } Else {
            Store(1, SCB0)
          }
        }
      
        Name(LTRV, Package(){0,0,0,0})
        Name(HBCS, 0) // Hybrid connection status
        Name(PRMV, 0) // PCIE Rp Mapped under VMD
        Name(RD3C, 1) // 1: D3Cold support for Storage connected to PCIE port, 0: D3Hot support for Storage connected to PCIE port. By default this is set as 1 for other EndPoints
      
        //
        // Check if root port is present.
        // @return 0: root port is disabled, 1: root port is enabled
        //
        Method(PRES) {
          If (LEqual (VDID, 0xFFFFFFFF)) {
            Return(0)
          } Else {
            Return(1)
          }
        }
      
        //
        // _DSM Device Specific Method
        //
        // Arg0: UUID Unique function identifier
        // Arg1: Integer Revision Level
        // Arg2: Integer Function Index (0 = Return Supported Functions)
        // Arg3: Package Parameters
        Method(_DSM, 4, Serialized) {
          //
          // Switch based on which unique function identifier was passed in
          //
          If (LEqual(Arg0, ToUUID ("E5C937D0-3553-4d7a-9117-EA4D19C3434D"))) {
            //
            // _DSM Definitions for Latency Tolerance Reporting
            //
            // Arguments:
            // Arg0: UUID: E5C937D0-3553-4d7a-9117-EA4D19C3434D
            // Arg1: Revision ID: 2
            // Arg2: Function Index: 1, 6
            // Arg3: Empty Package
            //
            // Return:
            // A Package of four integers corresponding with the LTR encoding defined
            // in the PCI Express Base Specification, as follows:
            // Integer 0: Maximum Snoop Latency Scale
            // Integer 1: Maximum Snoop Latency Value
            // Integer 2: Maximum No-Snoop Latency Scale
            // Integer 3: Maximum No-Snoop Latency Value
            // These values correspond directly to the LTR Extended Capability Structure
            // fields described in the PCI Express Base Specification.
            //
            //
            // Switch by function index
            //
            Switch(ToInteger(Arg2)) {
              //
              // Function Index:0
              // Standard query - A bitmask of functions supported
              //
              Case (0) {
                Name(OPTS,Buffer(2){0,0})
                CreateBitField(OPTS,0,FUN0)
                CreateBitField(OPTS,6,FUN6)
                CreateBitField(OPTS,8,FUN8)
                CreateBitField(OPTS,9,FUN9)
                CreateBitField(OPTS,10,FUNA)
                CreateBitField(OPTS,11,FUNB)
      
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(1,FUN0)
                  if (LNotEqual (LTEN, 0)) {
                    Store(1,FUN6)
                  }
      
                  If(CondRefOf(ECR1)) {
                    if(LEqual(ECR1,1)){
                      if (LGreaterEqual(Arg1, 3)){ // test Arg1 for Revision ID: 3
                        Store(1,FUN8)
                        Store(1,FUN9)
                      }
                    }
                  }
                }
      
                If (LGreaterEqual(Arg1, 4)) { //test Arg1 for Revision ID: 4
                  If(CondRefOf(PPBA)) {
                    Store(1,FUNA)
                  }
                  If(CondRefOf(UPRD)) {
                    Store(1,FUNB)
                  }
                }
                Return (OPTS)
              }
      
              //
              // Function Index: 6
              // LTR Extended Capability Structure
              //
              Case(6) {
                if (LGreaterEqual(Arg1, 2)){ // test Arg1 for Revision ID: 2
                  Store(And(ShiftRight(LMSL,10),7), Index(LTRV, 0))
                  Store(And(LMSL,0x3FF), Index(LTRV, 1))
                  Store(And(ShiftRight(LNSL,10),7), Index(LTRV, 2))
                  Store(And(LNSL,0x3FF), Index(LTRV, 3))
                  Return (LTRV)
                }
              }
              Case(8) { //ECR ACPI additions for FW latency optimizations, DSM for Avoiding Power-On Reset Delay Duplication on Sx Resume
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return (1)
                    }
                  }
                }
              }
              Case(9) { //ECR ACPI additions for FW latency optimizations, DSM for Specifying Device Readiness Durations
                If(CondRefOf(ECR1)) {
                  if(LEqual(ECR1,1)){
                    if (LGreaterEqual(Arg1, 3)) { // test Arg1 for Revision ID: 3
                      return(Package(5){50000,Ones,Ones,50000,Ones})
                    }
                  }
                }
              }
              //
              //  Function index 10 - negotiate device auxilary power consumption.
              //
              Case(10) {
                If(CondRefOf(PPBA)) {
                  Return(PPBA(Arg3))
                }
              }
              //
              // Function index 11 update delay between PME_TO_Ack and PERST# assertion
              //
              Case(11) {
                If(CondRefOf(UPRD)) {
                  Return(UPRD(Arg3))
                }
              }
            } // End of switch(Arg2)
          } // End of if
          return (Buffer() {0x00})
        } // End of _DSM
      
        Device(PXSX)
        {
          Name(_ADR, 0x00000000)
          /** @file
            ACPI Support for PCIe SSD
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
            // Include PciEpSel.asl for PCIe SSD support
            // Input parameters:
            OperationRegion(PCCX,PCI_Config,0x0,16) // PCI Config Space Class Code
            Field(PCCX, ByteAcc, NoLock, Preserve) {
              DVID, 32, // Vendor&Device ID,
              Offset(9),
              PIXX, 8, // Programming Interface
              SCCX, 8, // Sub Class Code
              BCCX, 8, // Base Class Code
            }
          
            Method(PAHC, Zero, Serialized) // Check if PCIe AHCI Controller
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x06)){
                  If(LEqual(PIXX, 0x01)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            Method(PNVM, Zero, Serialized) // Check if PCIe NVMe
            {
              If(LEqual(BCCX, 0x01)){ // Check Sub Class Code and Base Class Code
                If(LEqual(SCCX, 0x08)){
                  If(LEqual(PIXX, 0x02)){
                    Return(0x01)
                  }
                }
              }
              Return(0x00)
            }
          
            //
            // Check if  EP(End Point) is present.
            // Arguments: (0)
            // Return: EP presence status
            //     0->EP is absent; 1->EP is present
            //
            Method(PRES, Zero, Serialized) {
              If(LEqual (DVID, 0xFFFFFFFF)) {
                Return(0)
              } Else {
                Return(1)
              }
            }
          
            //
            // Check if EP (End Point) is GFX.
            // Arguments: (0)
            // Return:
            //     0->EP is not Gfx; 1->EP is GFX
            //
            Method (ISGX, Zero, Serialized) // Check if PCIe GFX device
            {
              If (LEqual (BCCX, 0x03)){ // Check Base Class Code
                Return (0x01)
              }
              Return (0x00)
            }
          
            Method (_DSD, 0)
            {
              If (LOr (PAHC (), PNVM ())) {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    // Enable D3 Support for NVMe Storage
                    Package () {
                      Package (2) {"StorageD3Enable", 1}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              } Else {
                Return (
                  Package () {
                    ToUUID ("5025030F-842F-4AB4-A561-99A5189762D0"),
                    Package () {
                      Package (2) {"StorageD3Enable", 0}  // 1 - Enable; 0 - Disable
                    }
                  }
                )
              }
            }
          

          // NOTE:  Any PCIE Hot-Plug dependency for this port is
          // specific to the CRB.  Please modify the code based on
          // your platform requirements.
      
          Method(_PRW, 0) {
            Return(GPRW(0x69, 4)) // can wakeup from S4 state
          }
        }
      
        Method (_PS0, 0, Serialized)
        {
          If (CondRefOf (PPS0)) {
            PPS0 ()
          }
        }
        Method (_PS3, 0, Serialized)
        {
          If (CondRefOf (PPS3)) {
            PPS3 ()
          }
        }
      
        //
        // PCI_EXP_STS Handler for PCIE Root Port
        //
      
        Method(HPME,0,Serialized) {
          If(LAnd(LNotEqual(VDID,0xFFFFFFFF), LEqual(PMSX,1))) { //if port exists and has PME SCI Status set...
            Notify (PXSX, 0x2) //notify child device; this will cause its driver to clear PME_Status from device
            Store(1,PMSX) // clear rootport's PME SCI status
            Store(1,PSPX) // consume one pending PME notification to prevent it from blocking the queue
          }
        }
      

  













#line 25369 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Method (_PRT, 0) {
        If (CondRefOf (PICM)) {
          If (PICM) {
            Return (AR07)
          }                                          // APIC mode
        }
        Return (PD07)                                // PIC Mode
      }                                              // end _PRT
    }                                                // end "PCIE Root Port#28"
  }

  /**@file
    IPU IMG Clock Output Control
    Set of ACPI methods to enable, disable and select frequency of IMG Clock Output
    In Specs please refer to IMGCLKOUT_x where x is Clock Output index
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB)
  {
    Device (ICLK) {
      Name(_HID, EISAID("PNP0C02"))
      Name(_UID, "ISCLK")
  
      OperationRegion (CKOR, SystemMemory, Add(SBRG, Add(ShiftLeft(ICKP, 16), 0x8000)), 0x40)
      Field(CKOR,AnyAcc,Lock,Preserve) {
        CLK0, 8,
        Offset(0x0C),
        CLK1, 8,
        Offset(0x18),
        CLK2, 8,
        Offset(0x24),
        CLK3, 8,
        Offset(0x30),
        CLK4, 8,
        Offset(0x3C),
        CLK5, 8,
      }
  
      //
      // Number Of Clocks
      //
      Method(NCLK, 0x0, NotSerialized)
      {
        If(LEqual(PCHS, PCHP)) {
          Return (6) // IMGCLKOUT_0, IMGCLKOUT_1, IMGCLKOUT_2, IMGCLKOUT_3, IMGCLKOUT_4, IMGCLKOUT_5
        } Else {
          Return (0) // ADL S does not have IMGCLKOUT GPIO pin
        }
      }
  
      //
      // Clock Control
      //
      Method (CLKC, 0x2, NotSerialized)
      {
        //
        // Arg0 - Clock number (0:IMGCLKOUT_0, etc)
        // Arg1 - Desired state (0:Disable, 1:Enable)
        //
        If(LAnd (LLess(Arg0, NCLK()), LEqual(PCHS, PCHP)))
        {
          Switch(ToInteger(Arg0)) {
            Case (0) {
              Store(CLK0, Local0)
              Store(Or(And(Local0, Not(0x00000002)), ShiftLeft(Arg1, 1)), CLK0)
            }
            Case (1) {
              Store(CLK1, Local0)
              Store(Or(And(Local0, Not(0x00000002)), ShiftLeft(Arg1, 1)), CLK1)
            }
            Case (2) {
              Store(CLK2, Local0)
              Store(Or(And(Local0, Not(0x00000002)), ShiftLeft(Arg1, 1)), CLK2)
            }
            Case (3) {
              Store(CLK3, Local0)
              Store(Or(And(Local0, Not(0x00000002)), ShiftLeft(Arg1, 1)), CLK3)
            }
            Case (4) {
              Store(CLK4, Local0)
              Store(Or(And(Local0, Not(0x00000002)), ShiftLeft(Arg1, 1)), CLK4)
            }
            Case (5) {
              Store(CLK5, Local0)
              Store(Or(And(Local0, Not(0x00000002)), ShiftLeft(Arg1, 1)), CLK5)
            }
          }
        }
      }
  
      //
      // Clock Frequency
      //
      Method (CLKF, 0x2, NotSerialized)
      {
        //
        // Arg0 - Clock number (0:IMGCLKOUT_0, etc)
        // Arg1 - Clock frequency (0:24MHz, 1:19.2MHz)
        //
        If(LAnd (LLess(Arg0, NCLK()), LEqual(PCHS, PCHP)))
        {
          Switch(ToInteger(Arg0)) {
            Case (0) {
              Store(CLK0, Local0)
              Store(Or(And(Local0, Not(0x00000001)), Arg1), CLK0)
            }
            Case (1) {
              Store(CLK1, Local0)
              Store(Or(And(Local0, Not(0x00000001)), Arg1), CLK1)
            }
            Case (2) {
              Store(CLK2, Local0)
              Store(Or(And(Local0, Not(0x00000001)), Arg1), CLK2)
            }
            Case (3) {
              Store(CLK3, Local0)
              Store(Or(And(Local0, Not(0x00000001)), Arg1), CLK3)
            }
            Case (4) {
              Store(CLK4, Local0)
              Store(Or(And(Local0, Not(0x00000001)), Arg1), CLK4)
            }
            Case (5) {
              Store(CLK5, Local0)
              Store(Or(And(Local0, Not(0x00000001)), Arg1), CLK5)
            }
          }
        }
      }
  
      Method (_STA)
      {
        // Device is present, enabled and decoding it's resources
        // and should not be shown in UI
        Return (0x3)
      }
    }
  }
  
  //
  // PCIe clock runtime control methods.
  //
  Scope (\) {
    //
    // Modify clock using IPC message
    // Arg0: Clock number
    // Arg1: Enable(1)/Disable(0) Clock
    //
    Method (MCUI, 2, Serialized) {
      Name(PRPI, 0) // PCIe root port index
      ShiftLeft(0x1, Arg0, Local0)
      ShiftLeft(Arg1, Arg0, Local1)
      Store(CTRP(Arg0), PRPI)
      If(LLess (PRPI, 28)) {
        ShiftLeft(0x1, PRPI, Local2)
        ShiftLeft(Arg1, PRPI, Local3)
      } Else {
        //
        // Todo: CPU Code needs to be updated. As Clock usage value for CPU is greater than
        // or equal to 0.
        //
        ShiftLeft(0x1, PRPI, Local2)
        ShiftLeft(Arg1, PRPI, Local3)
        //
        // Feature HAS - IPC1 0xAC command update for RTD3 flows v0p60.docx says
        // Note that bits 23:0 apply to the PCH clocks and bits 31:24 apply to the CPU clocks.
        // So left shift by 24 bits for CPU PCIe
        //
        ShiftLeft(Local2, 24, Local2)
        ShiftLeft(Local3, 24, Local3)
      }
      //
      // PMC IPC command to disale PCIe source clock
      // WBUF0 - PCIe source clock mask. Each set bit in this mask tells
      //         PMC FW to act on this clock according to WBUF1 settings
      // WBUF1 - PCIe source clock enable/disable. Each bit represents the
      //         target state of the source clock
      // WBUF2 - PCIe root port CLKREQ mapping mask. Each set bit in this mask
      //         tells PMC FW to act on this root port accordingly to WBUF3 settings
      // WBUF3 - PCIe root port CLKREQ mapping state mask. Each bit represents the
      //         target state of the PCIe root port CLKREQ mapping.
      //
      ADBG("Calling IPCS method with command V_PMC_PWRM_IPC_SRC_CLK_PORT_MAPPING_CMD")
      ADBG(Concatenate("Local0 =", Local0))
      ADBG(Concatenate("Local1 =", Local1))
      ADBG(Concatenate("Local2 =", Local2))
      ADBG(Concatenate("Local3 =", Local3))
      IPCS(0xAC, 0, 16, Local0, Local1, Local2, Local3)
    }
  
    //
    // Configure PCIe ClkReq Override
    // Arg0: Clock number
    // Arg1: Enable(1)/Disable(0) Clock
    //
    Method (SPCO, 2, Serialized) {
      ADBG("Calling SPCO method to configure PCIe ClkReq Override")
      Name(CLKU, 0) // CLK REQ Usage
      If (LNotEqual(IPCC,0)) {
        TMVA (10)
        MCUI(Arg0, Arg1)
      } Else {
        Store(CTRP(Arg0), CLKU)
        If (LEqual(Arg1,1)) {
          //
          // Unmask the isCLK DBUFF_SRC
          //
          If(LGreater(Arg0, 6)) {
            ADD(Arg0,1, Local1)
            Subtract(Local1, 7, Local1)
            PCRO(0xAD, 0x8084,(ShiftLeft(1, Local1)))
          } Else {
            ADD(Arg0,2, Local1)
            PCRO(0xAD, 0x8080,(ShiftLeft(1, Local1)))
          }
        } Else {
          //
          // Disable the Clock
          // Mask the isCLK DBUFF_SRC
          //
          If(LGreater(Arg0, 6)) {
            ADD(Arg0, 1, Local1)
            Subtract(Local1, 7, Local1)
            PCRA(0xAD, 0x8084, Not(ShiftLeft(1, Local1)))
          } Else {
            ADD(Arg0, 2, Local1)
            PCRA(0xAD, 0x8080, Not(ShiftLeft(1, Local1)))
          }
        }
      }
    }
  
    //
    // Configure PCIe ClkReq and IPC1 Command Timeout Override
    // Arg0: Clock number
    // Arg1: Enable(1)/Disable(0) Clock
    // Arg2: Timeout Value Override (<=10ms: Keep default setting, >10ms: Using customize timeout value)
    //
    Method (SPCX, 3, Serialized) {
      ADBG("Calling SPCX method to configure PCIe ClkReq Override")
      If (LNotEqual(IPCC,0)) {
        ADBG("Calling TMVA method to override IPC1 Command Timeout Value")
        TMVA (Arg2) // Configuring/Overriding IPC1 Command Timeout Value
        MCUI (Arg0, Arg1)
      } Else {
        SPCO (Arg0, Arg1)
      }
    }
  
    //
    // WA to Mask/UnMask Hybrid Partner CLKREQ using IPC message
    // Arg0: Hybrid device partner port number
    // Arg1: UnMask(1)/Mask(0) Clock
    //
    Method (HBCM, 2, Serialized) {
      ADBG("mask/unmask Hybrid Partner CLKREQ")
      Name(HPRI, 0) // Hybrid Partner root port index
      Store(Arg0, HPRI)
      If(LLess (HPRI, 28)) {
        ShiftLeft(0x1, HPRI, Local0)
        ShiftLeft(Arg1, HPRI, Local1)
      }
      Else {
        Store(0, Local0)
        Store(0, Local1)
      }
  
      ADBG("Calling IPCS method for Hybrid Partner with command V_PMC_PWRM_IPC_SRC_CLK_PORT_MAPPING_CMD")
      ADBG(Concatenate("Port number of Hybrid Partner =", HPRI))
      ADBG(Concatenate("Local0 of Hybrid Partner =", Local0))
      ADBG(Concatenate("Local1 of Hybrid Partner =", Local1))
      IPCS(0xAC, 0, 16, 0, 0, Local0, Local1)
    }
  
    //
    // Clock index to root port number method
    // Arg0: Clock index
    //
    Method(CTRP, 1) {
      Switch(ToInteger(Arg0)) {
        Case(0) {Return(CR00)}
        Case(1) {Return(CR01)}
        Case(2) {Return(CR02)}
        Case(3) {Return(CR03)}
        Case(4) {Return(CR04)}
        Case(5) {Return(CR05)}
        Case(6) {Return(CR06)}
        Case(7) {Return(CR07)}
        Case(8) {Return(CR08)}
        Case(9) {Return(CR09)}
        Case(10) {Return(CR10)}
        Case(11) {Return(CR11)}
        Case(12) {Return(CR12)}
        Case(13) {Return(CR13)}
        Case(14) {Return(CR14)}
        Case(15) {Return(CR15)}
        Case(16) {Return(CR16)}
        Case(17) {Return(CR17)}
        Default {Return(0xFF)}
      }
    }
  
    //
    // Clock Source index to ClkReq number method
    // Arg0: Clock index
    //
    Method(CTRQ, 1) {
      Switch(ToInteger(Arg0)) {
        Case(0) {Return(CQ00)}
        Case(1) {Return(CQ01)}
        Case(2) {Return(CQ02)}
        Case(3) {Return(CQ03)}
        Case(4) {Return(CQ04)}
        Case(5) {Return(CQ05)}
        Case(6) {Return(CQ06)}
        Case(7) {Return(CQ07)}
        Case(8) {Return(CQ08)}
        Case(9) {Return(CQ09)}
        Case(10) {Return(CQ10)}
        Case(11) {Return(CQ11)}
        Case(12) {Return(CQ12)}
        Case(13) {Return(CQ13)}
        Case(14) {Return(CQ14)}
        Case(15) {Return(CQ15)}
        Case(16) {Return(CQ16)}
        Case(17) {Return(CQ17)}
        Default {Return(0xFF)}
      }
    }
  }

  /**@file
    Integrated SATA ADL controller ACPI methods
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  Scope (\_SB.PC00) {
    Device (SAT0) {
      Name(_ADR, 0x00170000)
  
      Method(_PS0,0,Serialized) {
        //
        // Call CSD0 only if ST_FDIS_PMC == 0
        //
        If(LEqual(PCHS, PCHP)) {
          If(LNot(SCFD)){
            \_SB.CSD0(20)
          }
        }
        //
        // Clear LTR ignore bit for Sata on D0
        //
        Store(0, ISAT)
      }
  
      Method(_PS3,0,Serialized) {
        //
        // Set LTR ignore bit for Sata on D3
        //
        Store(1, ISAT)
        If(LEqual(PCHS, PCHP)) {
          \_SB.CSD3(20)
        }
      }
  
      /** @file
        Integrated SATA controller ACPI methods
      
        Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      //
      // Include this file in SATA device scope. This file requires following variables to be defined
      // \SPPR - sata port present status - contains bitmask of SATA ports that are present on the system
      //
      
      //
      // Platform hooks for SATA _DSM method.
      // SATC - check if platform code supports given _DSM GUID
      // SATD - execute _DSM method
      //
      External(SATC, MethodObj)
      External(SATD, MethodObj)
      
      //
      // Windows defined _DSD that informs the OS
      // that it should support D3 on this storage device.
      //
      Name (_DSD, Package () {
        ToUUID("5025030F-842F-4AB4-A561-99A5189762D0"),
        Package () {
            Package (2) {"StorageD3Enable", 1}
        }
      })
      
      Method(_DSM,4,serialized) {
        If(PCIC(Arg0)) {
          Return(PCID(Arg0,Arg1,Arg2,Arg3))
        }
      
        // If _DSM GUID doesn't match any of the GUIDs supported by reference code
        // check if platform code supports it by calling SATC method. If platform code supports
        // given GUID call SATD which contains _DSM implementation.
        If(LAnd(CondRefOf(SATC), CondRefOf(SATD))) {
          If(SATC(Arg0)) {
            Return(SATD(Arg0, Arg1, Arg2, Arg3))
          }
        }
      
        Return(Buffer() {0})
      }
      
      Method(_S0W) {
        Return(3)
      }
      
      Device(PRT0)
      {
        Name(_ADR,0x0000FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x1)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT1)
      {
        Name(_ADR,0x0001FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x2)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT2)
      {
        Name(_ADR,0x0002FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x4)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT3)
      {
        Name(_ADR,0x0003FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x8)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT4)
      {
        Name(_ADR,0x0004FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x10)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT5)
      {
        Name(_ADR,0x0005FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x20)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT6)
      {
        Name(_ADR,0x0006FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x40)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      
      Device(PRT7)
      {
        Name(_ADR,0x0007FFFF)
      
        //
        // Check if drive is connected to the port.
        //
        // @retval 1  Drive is connected to the port
        // @retval 0  Drive is not connected to the port
        //
        Method(PRES) {
          If(And(SPPR, 0x80)) {
            Return(1)
          } Else {
            Return(0)
          }
        }
      }
      

    }
  }

  
  Scope (\) {
    /**@file
      Intel ACPI Reference Code for PCR
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
    //
    // PCR Register Access Methods
    // Include this file into a device scope which implements private configuration register access.
    // Required variables:
    // SBRG - holds the value of the sideband MMIO base addres.
    //
    //  SBREG_BAR_20BITADDRESS is configured by SoC
    //
    //  SBREG_BAR_20BITADDRESS=1, the format has included 16b addressing.
    //  +---------------------------------------------------------------------------------------------+
    //  | Addr[63:28]    | Addr[27:24]           | Addr[23:16]     | Addr[15:2]           | Addr[1:0] |
    //  +----------------+-----------------------+-----------------+----------------------------------+
    //  | REG_BAR[63:28] | TargetRegister[19:16] | TargetPort[7:0] | TargetRegister[15:2]             |
    //  +---------------------------------------------------------------------------------------------+
    //
    //  SBREG_BAR_20BITADDRESS=0
    //  +---------------------------------------------------------------------------------------------+
    //  | Addr[63:24]    | Addr[27:24]           | Addr[23:16]     | Addr[15:2]           | Addr[1:0] |
    //  +----------------+-----------------------+-----------------+----------------------------------+
    //  | REG_BAR[63:24] | REG_BAR[27:24]        | TargetPort[7:0] | TargetRegister[15:2]             |
    //  +---------------------------------------------------------------------------------------------+
    //
    
    //
    // PCR Dword Read
    // arg0: PID
    // arg1: Offset
    //
    Method (PCRR, 2, Serialized) {
      And (arg1, 0xffff, Local1)
      ShiftLeft (And (arg1, 0x0f0000), 8, Local2)
      Add (ShiftLeft (arg0, 16), Local1, Local0)
      Add (Add (Local2, Local0), SBRG, Local0)
      OperationRegion (PCR0, SystemMemory, Local0, 0x4)
      Field(PCR0,DWordAcc,Lock,Preserve) {
        Offset(0x00),
        DAT0, 32
      } // End Field PCR0
      Return (DAT0)
    } // End Method PCRR
    
    //
    // PCR Dword Write
    // arg0: PID
    // arg1: Offset
    // arg2: write data
    //
    Method (PCRW, 3, Serialized) {
      And (arg1, 0xffff, Local1)
      ShiftLeft (And (arg1, 0x0f0000), 8, Local2)
      Add (ShiftLeft (arg0, 16), Local1, Local0)
      Add (Add (Local2, Local0), SBRG, Local0)
      OperationRegion (PCR0, SystemMemory, Local0, 0x4)
      Field(PCR0,DWordAcc,Lock,Preserve) {
        Offset(0x00),
        DAT0, 32
      } // End Field PCR0
      Store (arg2, DAT0)
    } // End Method PCRW
    
    //
    // PCR Dword Or
    // arg0: PID
    // arg1: Offset
    // arg2: Or data
    //
    Method (PCRO, 3, Serialized) {
      Store(PCRR(arg0,arg1),Local0)    // Store PCR Read data in Local0
      Store(Or(Local0,arg2),Local1)    // Or data
      PCRW(arg0,arg1,Local1)           // Write data back
    }
    
    //
    // PCR Dword And
    // arg0: PID
    // arg1: Offset
    // arg2: And data
    //
    Method (PCRA, 3, Serialized) {
      Store(PCRR(arg0,arg1),Local0)    // Store PCR Read data in Local0
      Store(And(Local0,arg2),Local1)   // And data
      PCRW(arg0,arg1,Local1)           // Write data back
    }
    
    //
    // PCR Dword AndThenOr
    // arg0: PID
    // arg1: Offset
    // arg2: And data
    // arg3: Or data
    //
    Method (PCAO, 4, Serialized) {
      Store(PCRR(arg0,arg1),Local0)           // Store PCR Read data in Local0
      Store(Or(And(Local0,arg2),arg3),Local1) // AndThenOr
      PCRW(arg0,arg1,Local1)                  // Write data back
    }

  }

  
  //
  // MEI 1 definition
  //
  /**@file
    ACPI DSDT table for MEI1
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  External(HIDW, MethodObj)
  External(HIWC, MethodObj)
  
  Scope(\_SB.PC00) {
    //
    // Management Engine Interface 1 - Device 22, Function 0
    //
    Device(HECI) {
      Name(_ADR, 0x00160000)
  
      Method(_DSM, 0x4, NotSerialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        if(PCIC(Arg0)) { return(PCID(Arg0,Arg1,Arg2,Arg3)) }
  
        //-------------------------------------------
        //  HID Wake up Event solution
        //-------------------------------------------
        If(CondRefOf(HIWC)) {
          If(HIWC(Arg0)) {
            If(CondRefOf(HIDW)) {
              Return (HIDW(Arg0, Arg1, Arg2, Arg3))
            }
          }
        }
  
        Return(Buffer() {0})
      } // End _DSM
    } // Device(HECI)
  
    //
    // Management Engine Interface 3 - Device 22, Function 4
    //
    Device(HEC3) {
      Name(_ADR, 0x00160004)
  
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
        If (PCIC(Arg0)) { Return(PCID(Arg0,Arg1,Arg2,Arg3)) }
  
        Return(Buffer() {0})
      } // End _DSM
    } // End Device HEC3
  }
  

  
  /** @file
    PCH Trace Hub Device
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  External(PTHM, FieldUnitObj)
  
  
  Scope (\_SB.PC00)
  {
    //
    // Declare PCH TH device for target debugger mode
    //
    Device(PTHT)
    {
      Name(_ADR, 0x001F0007)
  
      Method(_STA, 0, Serialized)
      {
         If (LEqual (PTHM, 1)) {
           Return (0xF)
         } Else {
           Return (0x0)
         }
      }
  
      OperationRegion (PTHR, PCI_Config, 0x00, 0x20)
      Field(PTHR, AnyAcc, NoLock, Preserve)
      {
        Offset (0x10),
        MTBL,  32,
        MTBH,  32,
      }
  
      Method (THEN, 0, Serialized, 0, UnknownObj)
      {
        OperationRegion(RMTB, SystemMemory, Add (ShiftLeft (MTBH, 32), And (MTBL, 0xFFF00000)), 0x100)
        Field(RMTB, AnyAcc, NoLock, Preserve) {
          Offset (0xE8),
          BTTH,  1,
        }
        //
        // Check SCRPD2[0] if BIOS trace to TraceHub is enabled
        //
        If (LEqual (BTTH, 1)) {
          Return (1)
        } Else {
          Return (0)
        }
      }
    }
  }
  
  Scope (\_SB) {
    //
    // Declare PCH TH device for host debugger mode
    //
    Device(PTHH)
    {
      Name(_HID, "INTC1001")
  
      Method(_STA,0,Serialized)
      {
        If (LEqual (PTHM, 2)) {
          Return(0xF)
        } Else {
          Return (0x0)
        }
      }
  
      Name(_CRS, ResourceTemplate() {
          Memory32Fixed(ReadWrite, 0xFE100000, 0x00100000) // MTB BAR
          Memory32Fixed(ReadWrite, 0xFD800000, 0x00800000)   // SW BAR
          })
  
      OperationRegion(MTBR, SystemMemory, 0xFE100000, 0x100)
      Field(MTBR, AnyAcc, NoLock, Preserve) {
        Offset (0xE8),
        BHTH,  1,
      }
  
      Method (THEN, 0, Serialized, 0, UnknownObj)
      {
        //
        // Check SCRPD2[0] if BIOS trace to TraceHub is enabled
        //
        If (LEqual (BHTH, 1)) {
          Return (1)
        } Else {
          Return (0)
        }
      }
    }
  }

  
  //
  // Timed GPIO
  //
  /**@file
    ACPI definition for Timed GPIO controller
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
    //----------------------------
    //  Timed GPIO
    //----------------------------
  
  
  Scope (\_SB) {
    Device (TGI0){
      Name(_HID, "INTC1023")
      Name(_STR, Unicode ("Timed GPIO 1"))
      Method (_STA, 0x0, NotSerialized) {
        if(LEqual(TGEA, 0x01)) {
          Return(0x0F)
        } else {
          Return(0x00)
        }
      }
      Method (_CRS, 0x0, NotSerialized) {
        Name(TGRA,ResourceTemplate(){
          Memory32Fixed (ReadWrite, 0x0,0x38, TGA1)
        })
        CreateDWordField(TGRA,TGA1._BAS,TMH1)
        Store( Add(PWRM,0x1210), TMH1)
        Return(TGRA)
      }
    } // END Device(TGI0)
  
    Device (TGI1){
      Name(_HID, "INTC1024")
      Name(_STR, Unicode ("Timed GPIO 2"))
      Method (_STA, 0x0, NotSerialized) {
        if(LEqual(TGEB, 0x01)) {
          Return(0x0F)
        } else {
          Return(0x00)
        }
      }
      Method (_CRS, 0x0, NotSerialized) {
        Name(TGRB,ResourceTemplate(){
          Memory32Fixed (ReadWrite, 0x0,0x38, TGA2)
        })
        CreateDWordField(TGRB,TGA2._BAS,TMH2)
        Store( Add(PWRM,0x1310), TMH2)
        Return(TGRB)
      }
    }// END Device(TGI1)
  }// END Scope

  //
  // GBE TSN
  //
  /**@file
    ACPI definition for Tsn
  
    Copyright (c) 2020 Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
    //----------------------------
    //  TSN Controller
    //----------------------------
  Scope(\_SB.PC00) {
    //
    // GBE TSN (PCI Mode)
    //
    Device(GTSN) {
      Name(_ADR, 0x001E0004)
      OperationRegion(TSRT,PCI_Config,0x00,0x100)
      Field(TSRT,AnyAcc,NoLock,Preserve)
      {
        DVID, 16,
        Offset(0x10),
        TADL,  32,
        TADH,  32,
      }
    } // Device(GTSN)
  }


  /** @file
  
    Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  // LPC Bridge - Device 31, Function 0
  scope (\_SB.PC00.LPCB) {
  
        /** @file
        
          Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        
        **/
        
        
        
        
        Device(HPET)  // High Performance Event Timer
        {
          Name(_HID,EISAID("PNP0103"))
          Name(_UID, 0)
        
          Name(BUF0,ResourceTemplate()
          {
            Memory32Fixed(ReadWrite,0xFED00000,0x400,FED0)
          })
        
          Method(_STA,0)
          {
            // Show this Device only if the OS is WINXP or beyond.
            If(HPTE)
            {
              Return(0x000F)  // Enabled, do Display.
            }
        
            Return(0x0000)      // Return Nothing.
          }
        
          Method(_CRS,0,Serialized)
          {
            If(HPTE)
            {
              // Check if HPETimer Base should be modified.
              CreateDwordField(BUF0,^FED0._BAS,HPT0)
              Store(HPTB,HPT0)
            }
        
            Return(BUF0)
          }
          OperationRegion(ETDI,SystemMemory,0xFED00000,0x1FF)
          Field(ETDI, AnyAcc, NoLock, Preserve)
          {
            Offset(0),
            GEID, 64,
            Offset(0x10),
            GECF, 64,
            Offset(0x20),
            GEST, 64,
            Offset(0xF0),
            MAIN, 64,
            Offset(0x100),
            TCN0, 8,
            Offset(0x108),
            TCM0, 8,
            Offset(0x120),
            TCN1, 8,
            Offset(0x128),
            TCM1, 8,
          }
        }
        
        Device(IPIC)  // 8259 PIC
        {
          Name(_HID,EISAID("PNP0000"))
        
          Name(_CRS,ResourceTemplate()
          {
            IO(Decode16,0x20,0x20,0x01,0x02)
            IO(Decode16,0x24,0x24,0x01,0x02)
            IO(Decode16,0x28,0x28,0x01,0x02)
            IO(Decode16,0x2C,0x2C,0x01,0x02)
            IO(Decode16,0x30,0x30,0x01,0x02)
            IO(Decode16,0x34,0x34,0x01,0x02)
            IO(Decode16,0x38,0x38,0x01,0x02)
            IO(Decode16,0x3C,0x3C,0x01,0x02)
            IO(Decode16,0xA0,0xA0,0x01,0x02)
            IO(Decode16,0xA4,0xA4,0x01,0x02)
            IO(Decode16,0xA8,0xA8,0x01,0x02)
            IO(Decode16,0xAC,0xAC,0x01,0x02)
            IO(Decode16,0xB0,0xB0,0x01,0x02)
            IO(Decode16,0xB4,0xB4,0x01,0x02)
            IO(Decode16,0xB8,0xB8,0x01,0x02)
            IO(Decode16,0xBC,0xBC,0x01,0x02)
            IO(Decode16,0x4D0,0x4D0,0x01,0x02)
            IRQNoFlags() {2}
          })
        }
        
        
        Device(MATH)  // Math Co-Processor
        {
          Name(_HID,EISAID("PNP0C04"))
        
          Name(_CRS,ResourceTemplate()
          {
            IO(Decode16,0xF0,0xF0,0x01,0x01)
            IRQNoFlags() {13}
          })
        
          //
          // Report device present for LPT-H.
          //
          Method (_STA, 0x0, NotSerialized)
          {
            If(LEqual(PCHS, PCHH)) {
              Return(0x1F)
            } else {
              Return(0x0)
            }
          }
        }
        
        
        Device(LDRC)  // LPC Device Resource Consumption
        {
          Name(_HID,EISAID("PNP0C02"))
        
          Name(_UID,2)
        
          Name(_CRS,ResourceTemplate()                      // This is for Cougar Point
          {
            IO(Decode16,0x2E,0x2E,0x1,0x02)             // SIO Access.
            IO(Decode16,0x4E,0x4E,0x1,0x02)             // LPC Slot Access.
            IO(Decode16,0x61,0x61,0x1,0x1)               // NMI Status.
            IO(Decode16,0x63,0x63,0x1,0x1)               // Processor I/F.
            IO(Decode16,0x65,0x65,0x1,0x1)               // Processor I/F.
            IO(Decode16,0x67,0x67,0x1,0x1)               // Processor I/F.
            IO(Decode16,0x70,0x70,0x1,0x1)               // NMI Enable.
            IO(Decode16,0x80,0x80,0x1,0x1)               // Port 80h.
            IO(Decode16,0x92,0x92,0x1,0x1)               // Processor I/F.
            IO(Decode16,0xB2,0xB2,0x01,0x02)           // Software SMI.
            IO(Decode16,0x680,0x680,0x1,0x20)        // 32 Byte I/O.
            IO(Decode16,0x164e,0x164e,0x1,0x02)    // 16 Byte I/O.
          })
        }
        
        Device(RTC) // RTC
        {
          Name(_HID,EISAID("PNP0B00"))
        
          Name(_CRS,ResourceTemplate()
          {
            IO(Decode16,0x70,0x70,0x01,0x08)
            IRQNoFlags() {8}
          })
        
          Method(_STA) {
            If (LEqual(\STAS,1)){
              Return(0x0F)
            } Else {
              Return(0x00)
            }
          }
        }
        
        Device(TIMR)  // 8254 Timer
        {
          Name(_HID,EISAID("PNP0100"))
        
          Name(_CRS,ResourceTemplate()
          {
            IO(Decode16,0x40,0x40,0x01,0x04)
            IO(Decode16,0x50,0x50,0x10,0x04)
            IRQNoFlags() {0}
          })
        }
        
        Device(CWDT)
        {
          Name(_HID,EISAID("INT3F0D"))
          Name(_CID,EISAID("PNP0C02"))
        
          Method(_STA,0,Serialized)
          {
            Return(0x0F)
          }
        
          Method (_CRS, 0x0, NotSerialized) {
            Name (RBUF, ResourceTemplate () {
              IO(Decode16, 0, 0, 0x4, 0x4,OCWD)  // ACPIBASE + OcWdtCtl offset
            })
        
            CreateWordField(RBUF,OCWD._MIN,OMIN)
            CreateWordField(RBUF,OCWD._MAX,OMAX)
        
            Add(PMBS,0x54,OMIN)
            Add(PMBS,0x54,OMAX)
        
            Return (RBUF)
          }
        }

        //Include ("H8S2113Sio.asl")
        /** @file
          ACPI DSDT table
        
          Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        
        Device(ITE8)
        {
          Name(_HID,EISAID("PNP0A05"))
        
          Name(_UID,6)
        
          // Status Method for the ITE SIO.
        
          Method(_STA,0,Serialized)
          {
            // Only report resources to the OS if the SIO Device is
            // present on the Docking Board.
        
            If(LEqual(ITSI,1))
            {
              Return(0x000F)
            }
        
            Return(0x0000)
          }
        
          // Define the SIO Index/Data Registers as an ACPI Operating
          // Region.  These registers will be used communicate to the SIO.
        
          OperationRegion(ITE8, SystemIO, 0x04E, 0x02)
          Field(ITE8, ByteAcc, Lock, Preserve)
          {
            INDX, 8,
            DATA, 8
          }
        
          OperationRegion(ITT8, SystemIO, 0x295, 0x02)
          Field(ITT8, ByteAcc, Lock, Preserve)
          {
            INDT, 8,
            DATT, 8
          }
        
          // Use ACPI Defined IndexField so consecutive Index/Data I/Os are
          // assured to be uninterrupted.
        
          IndexField(INDX, DATA, ByteAcc, Lock, Preserve)
          {
            Offset(0x07), // Logical Device Number.
            IT07, 8,
            Offset(0x20), // SIO Configuration and ID.
            IT20, 8,
            IT21, 8,
            IT22, 8,
            IT23, 8,
            IT24, 8,
            IT25, 8,
            IT26, 8,
            IT27, 8,
            IT28, 8,
            IT29, 8,
            IT2A, 8,
            Offset(0x30), // Logical Device Activate.
            IT30, 8,
            Offset(0x60), // I/O Space Configuration.
            IT60, 8,
            IT61, 8,
            Offset(0x70), // Interrupt Configuration.
            IT70, 8,
            IT71, 8,
            Offset(0x74), // DMA Configuration.
            IT74, 8,
            IT75, 8,
            Offset(0xF0), // Special Logical Device Configuration.
            ITF0, 8,
            ITF1, 8
          }
        
          //------------------------------------------------------------------------
          // Enter Config Mode, Select LDN
          // Arg0 : Logical Device number
          //------------------------------------------------------------------------
          Method(ENFG, 1)
          {
            Store(0x87, INDX)
            Store(0x01, INDX)
            Store(0x55, INDX)
            Store(0xAA, INDX)
            Store(Arg0, IT07) //Select LDN
          }
        
          //------------------------------------------------------------------------
          // Exit Config Mode
          //------------------------------------------------------------------------
          Method(EXFG, 0)
          {
            Store(0x02, INDX)
            Store(0x02, DATA)
          }
        
          // Set External Temperature Sensor Host Control Reg
          Method(SETP, 1)
          {
            Store(0x8E, INDT)
            Store(Arg0, DATT)
          }
        
          // Set Environment Controller Configuration Reg
          Method(SETS, 1)
          {
            Store(0x00, INDT)
            Store(Arg0, DATT)
          }
          If (LEqual(\ECON,0))
          {
            /**@file IOTG SIO
            
              Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
              SPDX-License-Identifier: BSD-2-Clause-Patent
            **/
            
            
            // This ASL file will support the F81804U HW monitor.
            
            Device(IHWM)  // Hw monitor.
            {
              Name(_HID,EISAID("PNP0A05"))
              Name(_UID,0)
            
              // Status Method.
              Method(_STA,0,Serialized)
              {
                // Only report resources to the OS if the SIO Device is present.
                // Only AlderIsland board has ITE8659-E SIO.
            
                If(LEqual(ITHW,1))
                {
                  Return(0x0B)
                }
            
                Return(0x00)
              }
            
              // Current Resource.
            
              Method(_CRS,0,Serialized)
              {
                Name(HMIO, ResourceTemplate()
                {
                  IO(Decode16,0x0295,0x0296,1,2)
                })
            
                Return(HMIO)
              }
            }

            if(LEqual(DPTF,1))
            {
              /** @file
                IOTG SIO
              
                Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              // This ASL file will support the F81804U HW monitor
              
              Device (TFN2)
              {
                Name (_HID, "INTC1048")  // Intel DPTF Fan Device
                Name (_UID, "TFN2")
                Name (_STR, Unicode ("Fan 2"))
              
                Method (_STA, 0, Serialized)
                {
                  // Only report resources to the OS if the SIO Device is present.
              
                  //
                  // Steps: 1) If board does not support IT8659E return 0x0000 (no device).
                  //        2) If bit set (IT8659E present) aquire mutex and set the SIO
                  //           to COM A.
                  //        3) Read enable register to Local0.
                  //        4) Release mutex and exit config mode.
                  //        5) If Local0 set return 0x000f (device present and active).
                  //        6) Else return 0x000d (device present, inactive).
                  //
                  If (LEqual (FND2, 1)) {
                    ENFG (0x04)
                    Store (IT30, Local0)
                    EXFG ()
                    If (Local0) {
                      Return (0x000F)
                    }
                    Return (0x000D)
                  }
              
                  Return (0x0000)
                }
              
                OperationRegion (HWEC, SystemIO, 0x295, 0x02)
                Field (HWEC, ByteAcc, Lock, Preserve)
                {
                  INDX, 8,
                  DATA, 8
                }
              
                // Use ACPI Defined IndexField so consecutive Index/Data I/Os are
                // assured to be uninterrupted.
              
                IndexField (INDX, DATA, ByteAcc, Lock, Preserve)
                {
                  Offset(0x0A),
                  R0AR , 8 ,   //enable SMB and PECI, 1 host clock
                  Offset (0x0E),
                  R2DR, 8,        // Fan Tachometer 2 Reading Register
                  Offset (0x13),
                  R13R, 8,        // active high PWM Fan output, default: 6MHz, 23.43KHz
                  Offset (0x14),
                  R14R, 8,        // active high PWM Fan output, default: 6MHz, 23.43KHz
                  Offset (0x16),
                  R16R, 8,        // FAN_CTL2 PWM Control Register
                  Offset (0x2A),
                  R2AR, 8,        // TMPIN2 Temperature Reading Register
                  Offset (0x42),
                  R42R, 8,        // TMPIN2 High limit register
                  R43R, 8,        // TMPIN2 Low limit register
                  Offset (0x51),
                  R51R, 8,        // set Fan1/Fan2
                  Offset (0x53),
                  R52R, 8,        // TMPIN2 Thermal Output Limit Register
                  Offset (0x56),
                  R56R , 8 ,  // offset for the Tmp1 reading
                  R57R,  8 ,  //offset for the Tmp2 reading
                  Offset (0x5C),
                  R5CR, 8,
                  Offset (0x68),
                  R68R, 8,        // SmartGuardian Automatic Mode Temperature Limit of OFF
                  R69R, 8,        // SmartGuardian Automatic Mode Temperature Limit of Start
                  R6AR, 8,        // SmartGuardian Automatic Mode Temperature Limit of Full Speed
                  R6BR, 8,         // FAN_CTL2 SmartGuardian Automatic Mode start PWM register
                  R6CR, 8
                }
              
                // _FIF (Fan Information)
                //
                // The optional _FIF object provides OSPM with fan device capability information.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //  A Package containing the fan device parameters.
                //
                Method (_FIF)
                {
                  Return (Package (){
                    0,                          // Revision:Integer
                    1,                          // FineGrainControl:Integer Boolean
                    2,                          // StepSize:Integer DWORD
                    0                           // LowSpeedNotificationSupport:Integer Boolean
                  })
                }
              
                // _FPS (Fan Performance States)
                //
                // Evaluates to a variable-length package containing a list of packages that describe the fan device's performance states.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //  A variable-length Package containing a Revision ID and a list of Packages that describe the fan device's performance states.
                //
                Method (_FPS,,,,PkgObj)
                {
                  Return (Package()
                  {
                    0,      // Revision:Integer
                    //        Control,  TripPoint,    Speed,  NoiseLevel, Power
                    Package () {100,    0xFFFFFFFF,    255,   500,        5000},
                    Package () {95,     0xFFFFFFFF,    240,   475,        4750},
                    Package () {90,     0xFFFFFFFF,    220,   450,        4500},
                    Package () {85,     0xFFFFFFFF,    200,   425,        4250},
                    Package () {80,     0xFFFFFFFF,    180,   400,        4000},
                    Package () {70,     0xFFFFFFFF,    150,   350,        3500},
                    Package () {60,     0xFFFFFFFF,    130,   300,        3000},
                    Package () {50,     0xFFFFFFFF,    110,   250,        2500},
                    Package () {40,     0xFFFFFFFF,     90,   200,        2000},
                    Package () {30,     0xFFFFFFFF,     70,   150,        1500},
                    Package () {25,     0xFFFFFFFF,     50,   125,        1250},
                    Package () {0,      0xFFFFFFFF,      0,     0,           0}    // OFF
                  })
                }
              
                Store(0,R16R)       //Set automatic mode off
                Store(144,R6BR)  //Default fan speed value
                Name (FSLV, 50)
              
                // _FSL (Fan Set Level)
                //
                // The optional _FSL object is a control method that OSPM evaluates to set a fan device's speed (performance state) to a specific level.
                //
                // Arguments: (1)
                //  Arg0 - Level (Integer): conveys to the platform the fan speed level to be set.
                // Return Value:
                //  None
                //
                // Argument Information
                //  Arg0: Level. If the fan supports fine-grained control, Level is a percentage of maximum level (0-100)
                //  that the platform is to engage the fan. If the fan does not support fine-grained control,
                //  Level is a Control field value from a package in the _FPS object's package list.
                //  A Level value of zero causes the platform to turn off the fan.
                //
                Method(_FSL,1,Serialized)
                {
                  Store(Arg0, FSLV)
                  //
                  //Turn off the fan
                  //
                  If(LEqual(Arg0, 0)) {
                    Store(0,R6BR)
                  }
                  //
                  //Fan speed level set by user. The fan speed range based on _FPS package.
                  //
                  If(LAnd(LGreaterEqual(Arg0, 25),LLess(Arg0, 30))) {
                    Store(64,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 30),LLess(Arg0, 40))) {
                    Store(80,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 40),LLess(Arg0, 50))) {
                    Store(96,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 50),LLess(Arg0, 60))) {
                    Store(144,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 60),LLess(Arg0, 70))) {
                    Store(160,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 70),LLess(Arg0, 80))) {
                    Store(176,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 80),LLess(Arg0, 85))) {
                    Store(192,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 85),LLess(Arg0, 90))) {
                    Store(208,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 90),LLess(Arg0, 95))) {
                    Store(224,R6BR)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 95),LLess(Arg0, 100))) {
                    Store(240,R6BR)
                  }
                  If(LEqual(Arg0,100)) {
                    Store(255,R6BR)
                  }
                }
              
                Name (TFST,Package ()
                {
                  0,            // Revision:Integer
                  0xFFFFFFFF,   // Control:Integer DWORD
                  0xFFFFFFFF    // Speed:Integer DWORD
                })
              
                //_FST (Fan Status)
                //
                // The optional _FST object provides status information for the fan device.
                //
                // Arguments: (0)
                //  None
                // Return Value:
                //  A Package containing fan device status information
                //  The fan device status information will show on DTT UI
                //
                Method(_FST,0,Serialized,,PkgObj)
                {
                  Store(FSLV, Index(TFST, 1))                //Control ID: Show the fan speed level
                  Store(Multiply(R6BR,60), Index(TFST, 2))  //PWM Value : Show the fan speed value
                  Return(TFST)
                } //End TFN2 device
              }

              /**@file IOTG SIO
              
                Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              // This ASL file will support the F81804U HW monitor
              
              Device (TFN1)
              {
                Name (_HID, "INTC1048")  // Intel DPTF Fan Device
                Name (_UID, "TFN1")
                Name (_STR, Unicode ("Fan 1"))
              
                Method (_STA, 0, Serialized)
                {
                  // Only report resources to the OS if the SIO Device is present.
              
                  //
                  // Steps: 1) If board does not support IT8659E return 0x0000 (no device).
                  //        2) If bit set (IT8659E present) aquire mutex and set the SIO
                  //           to COM A.
                  //        3) Read enable register to Local0.
                  //        4) Release mutex and exit config mode.
                  //        5) If Local0 set return 0x000f (device present and active).
                  //        6) Else return 0x000d (device present, inactive).
                  //
                  If (LEqual (FND1, 1)) {
                    ENFG (0x04)
                    Store (IT30, Local0)
                    EXFG ()
                    If (Local0) {
                      Return (0x000F)
                    }
                    Return (0x000D)
                  }
              
                  Return (0x0000)
                }
              
                OperationRegion (HWEC, SystemIO, 0x295, 0x02)
                Field (HWEC, ByteAcc, Lock, Preserve)
                {
                  INDX, 8,
                  DATA, 8
                }
              
                // Use ACPI Defined IndexField so consecutive Index/Data I/Os are
                // assured to be uninterrupted.
              
                IndexField (INDX, DATA, ByteAcc, Lock, Preserve)
                {
                  Offset (0x0A),
                  R0AR, 8,        // Fan Tachometer 1 Reading Register
                  Offset (0x0D),
                  R0DR, 8,        // Fan Tachometer 1 Reading Register
                  Offset (0x13),  //Enable FAN Tacometer for both the Fans.
                  R13R, 8,
                  Offset (0x14),
                  R14R, 8,
                  Offset (0x15),
                  R15R, 8,        // FAN_CTL1 PWM Control Register
                  Offset (0x29),
                  R29R, 8,        // TMPIN1 Temperature Reading Register
                  Offset (0x2B),
                  R2BR, 8,
                  Offset (0x40),
                  R40R, 8,        // TMPIN1 High limit register
                  R41R, 8,        // TMPIN1 Low limit register
                  Offset (0x44),
                  R44R, 8,
                  R45R, 8,
                  Offset (0x51),
                  R51R, 8,
                  R52R, 8,        // TMPIN1 Thermal Output Limit Register
                  Offset (0x56),
                  R56R, 8,
                  R57R, 8,
                  Offset (0x59),
                  R59R, 8,
                  Offset (0x5C),
                  R5CR, 8,
                  Offset (0x60),
                  R60R, 8,        // SmartGuardian Automatic Mode Temperature Limit of OFF
                  R61R, 8,        // SmartGuardian Automatic Mode Temperature Limit of Start
                  R62R, 8,        // SmartGuardian Automatic Mode Temperature Limit of Full Speed
                  R63R, 8,         // FAN_CTL1 SmartGuardian Automatic Mode start PWM register
                  R64R, 8
                }
              
                // _FIF (Fan Information)
                //
                // The optional _FIF object provides OSPM with fan device capability information.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //  A Package containing the fan device parameters.
                //
                Method (_FIF)
                {
                  Return (Package (){
                    0,                          // Revision:Integer
                    1,                          // FineGrainControl:Integer Boolean
                    2,                          // StepSize:Integer DWORD
                    0                           // LowSpeedNotificationSupport:Integer Boolean
                  })
                }
              
                // _FPS (Fan Performance States)
                //
                // Evaluates to a variable-length package containing a list of packages that describe the fan device's performance states.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //  A variable-length Package containing a Revision ID and a list of Packages that describe the fan device's performance states.
                //
                Method (_FPS,,,,PkgObj)
                {
                  Return (Package()
                  {
                    0,      // Revision:Integer
                    //        Control,  TripPoint,    Speed,  NoiseLevel, Power
                    Package () {100,    0xFFFFFFFF,    255,   500,        5000},
                    Package () {95,     0xFFFFFFFF,    240,   475,        4750},
                    Package () {90,     0xFFFFFFFF,    220,   450,        4500},
                    Package () {85,     0xFFFFFFFF,    200,   425,        4250},
                    Package () {80,     0xFFFFFFFF,    180,   400,        4000},
                    Package () {70,     0xFFFFFFFF,    150,   350,        3500},
                    Package () {60,     0xFFFFFFFF,    130,   300,        3000},
                    Package () {50,     0xFFFFFFFF,    110,   250,        2500},
                    Package () {40,     0xFFFFFFFF,     90,   200,        2000},
                    Package () {30,     0xFFFFFFFF,     70,   150,        1500},
                    Package () {25,     0xFFFFFFFF,     50,   125,        1250},
                    Package () {0,      0xFFFFFFFF,      0,     0,           0}    // OFF
                  })
                }
              
              
                Store(0,R15R)    //Set automatic mode off
                Store(144,R63R)  //Default fan speed value
              
                //Changes related to TMPIN3
                Store(0x80,R5CR)
                Store(0x00,R56R)
                Store(0x00,R57R)
                Store(0x64,R59R)
              
                Name (FSLV, 50)
                // _FSL (Fan Set Level)
                //
                // The optional _FSL object is a control method that OSPM evaluates to set a fan device's speed (performance state) to a specific level.
                //
                // Arguments: (1)
                //  Arg0 - Level (Integer): conveys to the platform the fan speed level to be set.
                // Return Value:
                //  None
                //
                // Argument Information
                //  Arg0: Level. If the fan supports fine-grained control, Level is a percentage of maximum level (0-100)
                //  that the platform is to engage the fan. If the fan does not support fine-grained control,
                //  Level is a Control field value from a package in the _FPS object's package list.
                //  A Level value of zero causes the platform to turn off the fan.
                //
                Method(_FSL,1,Serialized)
                {
                  Store(Arg0, FSLV)
                  //
                  //Turn off the fan
                  //
                  If(LEqual(Arg0, 0))
                  {
                    Store(0,R63R)
                  }
                  //
                  //Fan speed level set by user. The fan speed range based on _FPS package.
                  //
                  If(LAnd(LGreaterEqual(Arg0, 25),LLess(Arg0, 30))) {
                    Store(64,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 30),LLess(Arg0, 40))) {
                    Store(80,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 40),LLess(Arg0, 50))) {
                    Store(96,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 50),LLess(Arg0, 60))) {
                    Store(144,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 60),LLess(Arg0, 70))) {
                    Store(160,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 70),LLess(Arg0, 80))) {
                    Store(176,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 80),LLess(Arg0, 85))) {
                    Store(192,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 85),LLess(Arg0, 90))) {
                    Store(208,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 90),LLess(Arg0, 95))) {
                    Store(224,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 95),LLess(Arg0, 100))) {
                    Store(240,R63R)
                  }
                  If(LEqual(Arg0,100)) {
                    Store(255,R63R)
                  }
                }
              
                Name (TFST,Package ()
                {
                  0,            // Revision:Integer
                  0xFFFFFFFF,   // Control:Integer DWORD
                  0xFFFFFFFF    // Speed:Integer DWORD
                })
              
                //_FST (Fan Status)
                //
                // The optional _FST object provides status information for the fan device.
                //
                // Arguments: (0)
                //  None
                // Return Value:
                //  A Package containing fan device status information
                //  The fan device status information will show on DTT UI
                //
                Method(_FST,0,Serialized,,PkgObj)
                {
                  Store(FSLV, Index(TFST, 1))  //Control ID: Show the fan speed level
                  Store(Multiply(R63R,60), Index(TFST, 2)) //PWM Value : Show the fan speed value
                  Return(TFST)
                } //End TFN1 device
              }

              /** @file
                Intel ACPI Reference Code for Intel(R) Dynamic Tuning Technology
              
                Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              
              Device(SEN1)
              {
                Name (_HID, "INTC1046")  // Intel(R) Dynamic Tuning Technology Temperature Sensor Device
                Name (_UID, "SEN1")
                Name (_STR, Unicode ("Thermistor PCH VR"))
              
                Method (_STA, 0, Serialized)
                {
                  // Only report resources to the OS if the SIO Device is present.
              
                  //
                  // Steps: 1) If board does not support IT8659E return 0x0000 (no device).
                  //        2) If bit set (IT8659E present) aquire mutex and set the SIO
                  //           to COM A.
                  //        3) Read enable register to Local0.
                  //        4) Release mutex and exit config mode.
                  //        5) If Local0 set return 0x000f (device present and active).
                  //        6) Else return 0x000d (device present, inactive).
                  //
                  If (LEqual (S1DE, 1)) {
                    ENFG (0x04)
                    Store (IT30, Local0)
                    EXFG ()
                    If (Local0) {
                      Return (0x000F)
                    }
                    Return (0x000D)
                  }
              
                  Return (0x0000)
                }
              
                // ITRD (SIO Read Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (1)
                //    Arg0 - Object to Read
                //  Return Value:
                //    Read Value
                //
                Method(ITRD,1,Serialized, 0, IntObj, FieldUnitObj)
                {
                  Store(Arg0, Local1) // Execute Read from EC
                  Return(Local1)
                }
              
                // ICWT (SIO Write Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (2)
                //    Arg0 - Value to Write
                //    Arg1 - Object to Write to
                //
                Method(ICWT,2,Serialized,,,{IntObj, FieldUnitObj})
                {
                  Store(Arg0,Arg1) // Execute Write to SIO
                }
              
                // KTOC (Kelvin to Celsius)
                //
                // This control method converts from 10ths of degree Kelvin to Celsius.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Kelvin
                // Return Value:
                //   Temperature in Celsius
                //
                Method(KTOC,1,Serialized)
                {
                  If(LGreater(Arg0,2732)) // make sure we have a temperature above zero Celcius
                  {
                    Return(Divide(Subtract(Arg0, 2732), 10))
                  } Else {
                    Return(0) // negative temperatures Celcius are changed to 0 degrees Celcius
                  }
                }
              
                // CTOK (Celsius to Kelvin)
                //
                // This control method converts from Celsius to 10ths of degree Kelvin.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in Celsius
                // Return Value:
                //   Temperature in 10ths of degree Kelvin
                //
                Method(CTOK,1,Serialized)
                {
                  Return(Add(Multiply(Arg0,10),2732))
                }
              
                // C10K (Celsius to Kelvin)
                //
                // This control method converts from 10ths of degree Celsius (16 bit signed) to 10ths of degree Kelvin.
                // This method works only for temperatures upto absolute 0 Kelvin.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Celsius (16 bit signed value)
                // Return Value:
                //   Temperature in 10ths of degree Kelvin
                //
                Method(C10K,1,Serialized)
                {
                  Name(TMP1, Buffer(16) {0})
                  CreateByteField(TMP1, 0x00, TMPL)
                  CreateByteField(TMP1, 0x01, TMPH)
              
                  Add(Arg0, 2732, Local0)
                  Store(And(Local0,0xFF),TMPL)
                  Store(ShiftRight(And(Local0,0xFF00),0x8),TMPH)
              
                  ToInteger(TMP1, Local1)
                  Return(Local1)
                }
              
                // K10C (Kelvin to Celsius)
                //
                // This control method converts from 10ths of degree Kelvin to 10ths of degree Celsius (16 bit signed).
                // This method works only for temperatures upto 0 degree celsius. Temperatures below 0 deg celsius are changed to 0 deg C.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Kelvin
                // Return Value:
                //   Temperature in 10ths of degree Celsius (16 bit signed value)
                //
                Method(K10C,1,Serialized)
                {
                  If(LGreater(Arg0,2732)) // make sure we have a temperature above zero Celcius
                  {
                    Return(Subtract(Arg0, 2732))
                  } Else {
                    Return(0) // negative temperatures Celcius are changed to 0 degrees Celcius
                  }
                }
              
                // _TMP (Temperature)
                //
                // This control method returns the thermal zone's current operating temperature.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the current temperature of the thermal zone (in tenths of degrees Kelvin)
                //
                Method(_TMP,0,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(\_SB.PC00.LPCB.ITE8.TFN1.R29R), Local1)
                  Return(Local1)
                }
              
                // PATx (Participant Programmable Auxiliary Trip) - Sets Aux Trip Point
                //
                // The PATx objects shall take a single integer parameter, in tenths of degree Kelvin, which
                // represents the temperature at which the device should notify the participant driver of
                // an auxiliary trip event. A PATx control method returns no value.
                //
                //  Arguments: (1)
                //    Arg0 - temperature in tenths of degree Kelvin
                //  Return Value:
                //    None
                //
                Method(PAT0,1,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN1.K10C(Arg0),Local1)
                  \_SB.PC00.LPCB.ITE8.SEN1.ICWT(Local1, \_SB.PC00.LPCB.ITE8.TFN1.R41R) // Set low limit trip point
                }
              
                // PATx (Participant Programmable Auxiliary Trip) - Sets Aux Trip Point
                //
                // The PATx objects shall take a single integer parameter, in tenths of degree Kelvin, which
                // represents the temperature at which the device should notify the participant driver of
                // an auxiliary trip event. A PATx control method returns no value.
                //
                //  Arguments: (1)
                //    Arg0 - temperature in tenths of degree Kelvin
                //  Return Value:
                //    None
                //
                Method(PAT1,1,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN1.K10C(Arg0),Local1)
                  \_SB.PC00.LPCB.ITE8.SEN1.ICWT(Local1, \_SB.PC00.LPCB.ITE8.TFN1.R40R) // Set high limit trip point
                }
              
                Name(LSTM,0)  // Last temperature reported
              
                // _DTI (Device Temperature Indication)
                //
                // Conveys the temperature of a device's internal temperature sensor to the platform when a temperature trip point
                // is crossed or when a meaningful temperature change occurs.
                //
                // Arguments: (1)
                //   Arg0 - An Integer containing the current value of the temperature sensor (in tenths Kelvin)
                // Return Value:
                //   None
                //
                Method(_DTI, 1)
                {
                  Store(Arg0,LSTM)
                  Notify(\_SB.PC00.LPCB.ITE8.SEN1, 0x91) // notify the participant of a trip point change event
                }
              
                // _NTT (Notification Temperature Threshold)
                //
                // Returns the temperature change threshold for devices containing native temperature sensors to cause
                // evaluation of the _DTI object
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the temperature threshold in tenths of degrees Kelvin.
                //
                Method(_NTT, 0)
                {
                  Return(2782)  // 5 degree Celcius, this could be a platform policy with setup item
                }
              
                // Default values for trip points for the validation purpose.
                Name (S1AC,60)  // Active0 trip point in celsius
                Name (S1A1,50)  // Active1 trip point in celsius
                Name (S1A2,40)  // Active2 trip point in celsius
                Name (S1PV,65)  // Passive trip point in celsius
                Name (S1CC,80)  // Critical trip point in celsius
                Name (S1C3,70)  // Critical s3 trip point in celsius
                Name (S1HP,75)  // Hot trip point in celsius
                Name (SSP1,0)   // Thermal Sampling Period
              
                // _TSP (Thermal Sampling Period)
                //
                // Sets the polling interval in 10ths of seconds. A value of 0 tells the driver to use interrupts.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the polling rate in tenths of seconds.
                //   A value of 0 will specify using interrupts through the ACPI notifications.
                //
                //   The granularity of the sampling period is 0.1 seconds. For example, if the sampling period is 30.0
                //   seconds, then _TSP needs to report 300; if the sampling period is 0.5 seconds, then it will report 5.
                //
                Method(_TSP,0,Serialized)
                {
                  Return(SSP1)
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC0,0,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1AC),Local1) // Active Cooling Policy
                  If(LGreaterEqual(LSTM,Local1))
                  {
                    Return(Subtract(Local1,20)) // subtract 2 degrees which is the Hysteresis
                  }
                  Else
                  {
                    Return(Local1)
                  }
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC1,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1A1))
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC2,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1A2))
                }
              
                // _PSV (Passive)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the passive cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_PSV,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1PV)) // Passive Cooling Policy
                }
              
                // _CRT (Critical Temperature)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the critical temperature threshold in tenths of degrees Kelvin
                //
                Method(_CRT,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1CC))
                }
              
                // _CR3 (Critical Temperature for S3/CS)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the critical temperature threshold in tenths of degrees Kelvin
                //
                Method(_CR3,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1C3))
                }
              
                // _HOT (Hot Temperature)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    The return value is an integer that represents the critical sleep threshold tenths of degrees Kelvin.
                //
                Method(_HOT,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN1.CTOK(S1HP))
                }
              
              } // End SEN1 Device

               /** @file
                Intel ACPI Reference Code for Intel(R) Dynamic Tuning Technology
              
                Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              
              Device(SEN2)
              {
                Name (_HID, "INTC1046")  // Intel(R) Dynamic Tuning Technology Temperature Sensor Device
                Name (_UID, "SEN2")
                Name (_STR, Unicode ("Thermistor PCH VR"))
              
                Method (_STA, 0, Serialized)
                {
                  // Only report resources to the OS if the SIO Device is present.
              
                  //
                  // Steps: 1) If board does not support IT8659E return 0x0000 (no device).
                  //        2) If bit set (IT8659E present) aquire mutex and set the SIO
                  //           to COM A.
                  //        3) Read enable register to Local0.
                  //        4) Release mutex and exit config mode.
                  //        5) If Local0 set return 0x000f (device present and active).
                  //        6) Else return 0x000d (device present, inactive).
                  //
                  If (LEqual (S2DE, 1)) {
                    ENFG (0x04)
                    Store (IT30, Local0)
                    EXFG ()
                    If (Local0) {
                      Return (0x000F)
                    }
                    Return (0x000D)
                  }
              
                  Return (0x0000)
                }
              
                // ITRD (SIO Read Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (1)
                //    Arg0 - Object to Read
                //  Return Value:
                //    Read Value
                //
                Method(ITRD,1,Serialized, 0, IntObj, FieldUnitObj)
                {
                  Store(Arg0, Local1) // Execute Read from EC
                  Return(Local1)
                }
              
                // ICWT (SIO Write Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (2)
                //    Arg0 - Value to Write
                //    Arg1 - Object to Write to
                //
                Method(ICWT,2,Serialized,,,{IntObj, FieldUnitObj})
                {
                  Store(Arg0,Arg1) // Execute Write to SIO
                }
              
                // KTOC (Kelvin to Celsius)
                //
                // This control method converts from 10ths of degree Kelvin to Celsius.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Kelvin
                // Return Value:
                //   Temperature in Celsius
                //
                Method(KTOC,1,Serialized)
                {
                  If(LGreater(Arg0,2732)) // make sure we have a temperature above zero Celcius
                  {
                    Return(Divide(Subtract(Arg0, 2732), 10))
                  } Else {
                    Return(0) // negative temperatures Celcius are changed to 0 degrees Celcius
                  }
                }
              
                // CTOK (Celsius to Kelvin)
                //
                // This control method converts from Celsius to 10ths of degree Kelvin.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in Celsius
                // Return Value:
                //   Temperature in 10ths of degree Kelvin
                //
                Method(CTOK,1,Serialized)
                {
                  Return(Add(Multiply(Arg0,10),2732))
                }
              
                // C10K (Celsius to Kelvin)
                //
                // This control method converts from 10ths of degree Celsius (16 bit signed) to 10ths of degree Kelvin.
                // This method works only for temperatures upto absolute 0 Kelvin.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Celsius (16 bit signed value)
                // Return Value:
                //   Temperature in 10ths of degree Kelvin
                //
                Method(C10K,1,Serialized)
                {
                  Name(TMP2, Buffer(16) {0})
                  CreateByteField(TMP2, 0x00, TMPL)
                  CreateByteField(TMP2, 0x01, TMPH)
              
                  Add(Arg0, 2732, Local0)
                  Store(And(Local0,0xFF),TMPL)
                  Store(ShiftRight(And(Local0,0xFF00),0x8),TMPH)
              
                  ToInteger(TMP2, Local1)
                  Return(Local1)
                }
              
                // K10C (Kelvin to Celsius)
                //
                // This control method converts from 10ths of degree Kelvin to 10ths of degree Celsius (16 bit signed).
                // This method works only for temperatures upto 0 degree celsius. Temperatures below 0 deg celsius are changed to 0 deg C.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Kelvin
                // Return Value:
                //   Temperature in 10ths of degree Celsius (16 bit signed value)
                //
                Method(K10C,1,Serialized)
                {
                  If(LGreater(Arg0,2732)) // make sure we have a temperature above zero Celcius
                  {
                    Return(Subtract(Arg0, 2732))
                  } Else {
                    Return(0) // negative temperatures Celcius are changed to 0 degrees Celcius
                  }
                }
              
                // _TMP (Temperature)
                //
                // This control method returns the thermal zone's current operating temperature.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the current temperature of the thermal zone (in tenths of degrees Kelvin)
                //
                Method(_TMP,0,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(\_SB.PC00.LPCB.ITE8.TFN2.R2AR), Local1)
                  Return(Subtract(Local1,100))
                }
              
              
                // PATx (Participant Programmable Auxiliary Trip) - Sets Aux Trip Point
                //
                // The PATx objects shall take a single integer parameter, in tenths of degree Kelvin, which
                // represents the temperature at which the device should notify the participant driver of
                // an auxiliary trip event. A PATx control method returns no value.
                //
                //  Arguments: (1)
                //    Arg0 - temperature in tenths of degree Kelvin
                //  Return Value:
                //    None
                //
                Method(PAT0,1,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.K10C(Arg0),Local1)
                  \_SB.PC00.LPCB.ITE8.SEN2.ICWT(Local1, \_SB.PC00.LPCB.ITE8.TFN2.R42R) // Set low limit trip point
                }
              
                // PATx (Participant Programmable Auxiliary Trip) - Sets Aux Trip Point
                //
                // The PATx objects shall take a single integer parameter, in tenths of degree Kelvin, which
                // represents the temperature at which the device should notify the participant driver of
                // an auxiliary trip event. A PATx control method returns no value.
                //
                //  Arguments: (1)
                //    Arg0 - temperature in tenths of degree Kelvin
                //  Return Value:
                //    None
                //
                Method(PAT1,1,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.K10C(Arg0),Local1)
                  \_SB.PC00.LPCB.ITE8.SEN2.ICWT(Local1, \_SB.PC00.LPCB.ITE8.TFN2.R43R) // Set high limit trip point
                }
              
                Name(LSTM,0)  // Last temperature reported
              
                // _DTI (Device Temperature Indication)
                //
                // Conveys the temperature of a device's internal temperature sensor to the platform when a temperature trip point
                // is crossed or when a meaningful temperature change occurs.
                //
                // Arguments: (1)
                //   Arg0 - An Integer containing the current value of the temperature sensor (in tenths Kelvin)
                // Return Value:
                //   None
                //
                Method(_DTI, 1)
                {
                  Store(Arg0,LSTM)
                  Notify(\_SB.PC00.LPCB.ITE8.SEN2, 0x91) // notify the participant of a trip point change event
                }
              
                // _NTT (Notification Temperature Threshold)
                //
                // Returns the temperature change threshold for devices containing native temperature sensors to cause
                // evaluation of the _DTI object
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the temperature threshold in tenths of degrees Kelvin.
                //
                Method(_NTT, 0)
                {
                  Return(2782)  // 5 degree Celcius, this could be a platform policy with setup item
                }
              
                // Default values for trip points for the validation purpose.
                Name (S1AC,60)  // Active0 trip point in celsius
                Name (S1A1,50)  // Active1 trip point in celsius
                Name (S1A2,40)  // Active2 trip point in celsius
                Name (S1PV,65)  // Passive trip point in celsius
                Name (S1CC,80)  // Critical trip point in celsius
                Name (S1C3,70)  // Critical s3 trip point in celsius
                Name (S1HP,75)  // Hot trip point in celsius
                Name (SSP1,0)   // Thermal Sampling Period
              
              
                // _TSP (Thermal Sampling Period)
                //
                // Sets the polling interval in 10ths of seconds. A value of 0 tells the driver to use interrupts.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the polling rate in tenths of seconds.
                //   A value of 0 will specify using interrupts through the ACPI notifications.
                //
                //   The granularity of the sampling period is 0.1 seconds. For example, if the sampling period is 30.0
                //   seconds, then _TSP needs to report 300; if the sampling period is 0.5 seconds, then it will report 5.
                //
                Method(_TSP,0,Serialized)
                {
                  Return(SSP1)
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC0,0,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1AC),Local1) // Active Cooling Policy
                  If(LGreaterEqual(LSTM,Local1))
                  {
                    Return(Subtract(Local1,20)) // subtract 2 degrees which is the Hysteresis
                  }
                  Else
                  {
                    Return(Local1)
                  }
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC1,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1A1))
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC2,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1A2))
                }
              
                // _PSV (Passive)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the passive cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_PSV,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1PV)) // Passive Cooling Policy
                }
              
                // _CRT (Critical Temperature)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the critical temperature threshold in tenths of degrees Kelvin
                //
                Method(_CRT,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1CC))
                }
              
                // _CR3 (Critical Temperature for S3/CS)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the critical temperature threshold in tenths of degrees Kelvin
                //
                Method(_CR3,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1C3))
                }
              
                // _HOT (Hot Temperature)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    The return value is an integer that represents the critical sleep threshold tenths of degrees Kelvin.
                //
                Method(_HOT,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1HP))
                }
              } // End SEN2 Device
              
              

               /** @file
                Intel ACPI Reference Code for Intel(R) Dynamic Tuning Technology
              
                Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              
              Device(SEN3)
              {
                Name (_HID, "INTC1046")  // Intel(R) Dynamic Tuning Technology Temperature Sensor Device
                Name (_UID, "SEN3")
                Name (_STR, Unicode ("Thermistor PCH VR"))
              
                Method (_STA, 0, Serialized)
                {
                  // Only report resources to the OS if the SIO Device is present.
              
                  //
                  // Steps: 1) If board does not support IT8659E return 0x0000 (no device).
                  //        2) If bit set (IT8659E present) aquire mutex and set the SIO
                  //           to COM A.
                  //        3) Read enable register to Local0.
                  //        4) Release mutex and exit config mode.
                  //        5) If Local0 set return 0x000f (device present and active).
                  //        6) Else return 0x000d (device present, inactive).
                  //
                  If (LEqual (S3DE, 1)) {
                    ENFG (0x04)
                    Store (IT30, Local0)
                    EXFG ()
                    If (Local0) {
                      Return (0x000F)
                    }
                    Return (0x000D)
                  }
              
                  Return (0x0000)
                }
              
                // ITRD (SIO Read Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (1)
                //    Arg0 - Object to Read
                //  Return Value:
                //    Read Value
                //
                Method(ITRD,1,Serialized, 0, IntObj, FieldUnitObj)
                {
                  Store(Arg0, Local1) // Execute Read from EC
                  Return(Local1)
                }
              
                // ICWT (SIO Write Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (2)
                //    Arg0 - Value to Write
                //    Arg1 - Object to Write to
                //
                Method(ICWT,2,Serialized,,,{IntObj, FieldUnitObj})
                {
                  Store(Arg0,Arg1) // Execute Write to SIO
                }
              
                // KTOC (Kelvin to Celsius)
                //
                // This control method converts from 10ths of degree Kelvin to Celsius.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Kelvin
                // Return Value:
                //   Temperature in Celsius
                //
                Method(KTOC,1,Serialized)
                {
                  If(LGreater(Arg0,2732)) // make sure we have a temperature above zero Celcius
                  {
                    Return(Divide(Subtract(Arg0, 2732), 10))
                  } Else {
                    Return(0) // negative temperatures Celcius are changed to 0 degrees Celcius
                  }
                }
              
                // CTOK (Celsius to Kelvin)
                //
                // This control method converts from Celsius to 10ths of degree Kelvin.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in Celsius
                // Return Value:
                //   Temperature in 10ths of degree Kelvin
                //
                Method(CTOK,1,Serialized)
                {
                  Return(Add(Multiply(Arg0,10),2732))
                }
              
                // C10K (Celsius to Kelvin)
                //
                // This control method converts from 10ths of degree Celsius (16 bit signed) to 10ths of degree Kelvin.
                // This method works only for temperatures upto absolute 0 Kelvin.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Celsius (16 bit signed value)
                // Return Value:
                //   Temperature in 10ths of degree Kelvin
                //
                Method(C10K,1,Serialized)
                {
                  Name(TMP3, Buffer(16) {0})
                  CreateByteField(TMP3, 0x00, TMPL)
                  CreateByteField(TMP3, 0x01, TMPH)
              
                  Add(Arg0, 2732, Local0)
                  Store(And(Local0,0xFF),TMPL)
                  Store(ShiftRight(And(Local0,0xFF00),0x8),TMPH)
              
                  ToInteger(TMP3, Local1)
                  Return(Local1)
                }
              
                // K10C (Kelvin to Celsius)
                //
                // This control method converts from 10ths of degree Kelvin to 10ths of degree Celsius (16 bit signed).
                // This method works only for temperatures upto 0 degree celsius. Temperatures below 0 deg celsius are changed to 0 deg C.
                //
                // Arguments: (1)
                //   Arg0 - Temperature in 10ths of degree Kelvin
                // Return Value:
                //   Temperature in 10ths of degree Celsius (16 bit signed value)
                //
                Method(K10C,1,Serialized)
                {
                  If(LGreater(Arg0,2732)) // make sure we have a temperature above zero Celcius
                  {
                    Return(Subtract(Arg0, 2732))
                  } Else {
                    Return(0) // negative temperatures Celcius are changed to 0 degrees Celcius
                  }
                }
              
                // _TMP (Temperature)
                //
                // This control method returns the thermal zone's current operating temperature.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the current temperature of the thermal zone (in tenths of degrees Kelvin)
                //
                Method(_TMP,0,Serialized)
                {
                  Store(0xC3, \_SB.PC00.LPCB.ITE8.TFN1.R51R) //more than 100
                  // Subtract(\_SB.PC00.LPCB.ITE8.TFN1.R2BR,80)
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(\_SB.PC00.LPCB.ITE8.TFN1.R2BR), Local1)
                  Return(Local1)
                }
              
                // PATx (Participant Programmable Auxiliary Trip) - Sets Aux Trip Point
                //
                // The PATx objects shall take a single integer parameter, in tenths of degree Kelvin, which
                // represents the temperature at which the device should notify the participant driver of
                // an auxiliary trip event. A PATx control method returns no value.
                //
                //  Arguments: (1)
                //    Arg0 - temperature in tenths of degree Kelvin
                //  Return Value:
                //    None
                //
                Method(PAT0,1,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.K10C(Arg0),Local1)
                  \_SB.PC00.LPCB.ITE8.SEN2.ICWT(Local1, \_SB.PC00.LPCB.ITE8.TFN1.R45R) // Set low limit trip point
                }
              
                // PATx (Participant Programmable Auxiliary Trip) - Sets Aux Trip Point
                //
                // The PATx objects shall take a single integer parameter, in tenths of degree Kelvin, which
                // represents the temperature at which the device should notify the participant driver of
                // an auxiliary trip event. A PATx control method returns no value.
                //
                //  Arguments: (1)
                //    Arg0 - temperature in tenths of degree Kelvin
                //  Return Value:
                //    None
                //
                Method(PAT1,1,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.K10C(Arg0),Local1)
                  \_SB.PC00.LPCB.ITE8.SEN2.ICWT(Local1, \_SB.PC00.LPCB.ITE8.TFN1.R44R) // Set high limit trip point
                }
              
                Name(LSTM,0)  // Last temperature reported
              
                // _DTI (Device Temperature Indication)
                //
                // Conveys the temperature of a device's internal temperature sensor to the platform when a temperature trip point
                // is crossed or when a meaningful temperature change occurs.
                //
                // Arguments: (1)
                //   Arg0 - An Integer containing the current value of the temperature sensor (in tenths Kelvin)
                // Return Value:
                //   None
                //
                Method(_DTI, 1)
                {
                  Store(Arg0,LSTM)
                  Notify(\_SB.PC00.LPCB.ITE8.SEN3, 0x91) // notify the participant of a trip point change event
                }
              
                // _NTT (Notification Temperature Threshold)
                //
                // Returns the temperature change threshold for devices containing native temperature sensors to cause
                // evaluation of the _DTI object
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the temperature threshold in tenths of degrees Kelvin.
                //
                Method(_NTT, 0)
                {
                  Return(2782)  // 5 degree Celcius, this could be a platform policy with setup item
                }
              
                // Default values for trip points for the validation purpose.
                Name (S1AC,60)  // Active0 trip point in celsius
                Name (S1A1,50)  // Active1 trip point in celsius
                Name (S1A2,40)  // Active2 trip point in celsius
                Name (S1PV,65)  // Passive trip point in celsius
                Name (S1CC,80)  // Critical trip point in celsius
                Name (S1C3,70)  // Critical s3 trip point in celsius
                Name (S1HP,75)  // Hot trip point in celsius
                Name (SSP1,0)   // Thermal Sampling Period
              
              
                // _TSP (Thermal Sampling Period)
                //
                // Sets the polling interval in 10ths of seconds. A value of 0 tells the driver to use interrupts.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //   An Integer containing the polling rate in tenths of seconds.
                //   A value of 0 will specify using interrupts through the ACPI notifications.
                //
                //   The granularity of the sampling period is 0.1 seconds. For example, if the sampling period is 30.0
                //   seconds, then _TSP needs to report 300; if the sampling period is 0.5 seconds, then it will report 5.
                //
                Method(_TSP,0,Serialized)
                {
                  Return(SSP1)
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC0,0,Serialized)
                {
                  Store(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1AC),Local1) // Active Cooling Policy
                  If(LGreaterEqual(LSTM,Local1))
                  {
                    Return(Subtract(Local1,20)) // subtract 2 degrees which is the Hysteresis
                  }
                  Else
                  {
                    Return(Local1)
                  }
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC1,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1A1))
                }
              
                // _ACx (Active Cooling)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the active cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_AC2,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1A2))
                }
              
                // _PSV (Passive)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the passive cooling temperature threshold in tenths of degrees Kelvin
                //
                Method(_PSV,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1PV)) // Passive Cooling Policy
                }
              
                // _CRT (Critical Temperature)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the critical temperature threshold in tenths of degrees Kelvin
                //
                Method(_CRT,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1CC))
                }
              
                // _CR3 (Critical Temperature for S3/CS)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    An Integer containing the critical temperature threshold in tenths of degrees Kelvin
                //
                Method(_CR3,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1C3))
                }
              
                // _HOT (Hot Temperature)
                //
                // This ACPI method is optional.
                // OEM/ODM can directly set the value on Intel(R) Dynamic Tuning Technology UI for the participant and then export the value to BIOS GDDV for storage.
                // The value programmed here is the default value used on Intel RVP for the validation purpose.
                // OEM/ODM can set a different default value for a specific platform if necessary.
                //
                //  Arguments: (0)
                //    None
                //  Return Value:
                //    The return value is an integer that represents the critical sleep threshold tenths of degrees Kelvin.
                //
                Method(_HOT,0,Serialized)
                {
                  Return(\_SB.PC00.LPCB.ITE8.SEN2.CTOK(S1HP))
                }
              } // End SEN3 Device

            }  Else {

              /** @file
                IOTG SIO
                Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              // This ASL file will support the F81804U HW monitor
              
              Device (TFN3)
              {
                Name (_HID, "INTC1048")  // Intel DPTF Fan Device
                Name (_UID, "TFN1")
                Name (_STR, Unicode ("Fan Auto 1"))
              
                Method (_STA, 0, Serialized)
                {
                  // Only report resources to the OS if the SIO Device is present.
              
                  //
                  // Steps: 1) If board does not support IT8659E return 0x0000 (no device).
                  //        2) If bit set (IT8659E present) aquire mutex and set the SIO
                  //           to COM A.
                  //        3) Read enable register to Local0.
                  //        4) Release mutex and exit config mode.
                  //        5) If Local0 set return 0x000f (device present and active).
                  //        6) Else return 0x000d (device present, inactive).
                  //
                  If (LEqual (FND3, 1)) {
                    ENFG (0x04)
                    Store (IT30, Local0)
                    EXFG ()
                    If (Local0) {
                      Return (0x000F)
                    }
                    Return (0x000D)
                  }
              
                  Return (0x0000)
                }
              
                OperationRegion (HWEC, SystemIO, 0x295, 0x02)
                Field (HWEC, ByteAcc, Lock, Preserve)
                {
                  INDX, 8,
                  DATA, 8
                }
              
                // Use ACPI Defined IndexField so consecutive Index/Data I/Os are
                // assured to be uninterrupted.
              
                IndexField (INDX, DATA, ByteAcc, Lock, Preserve)
                {
                  Offset (0x0A),
                  R0AR, 8,        // Fan Tachometer 1 Reading Register
                  Offset (0x0D),
                  R0DR, 8,        // Fan Tachometer 1 Reading Register
                  Offset (0x13),  //Enable FAN Tacometer for both the Fans.
                  R13R, 8,
                  Offset (0x14),
                  R14R, 8,
                  Offset (0x15),
                  R15R, 8,        // FAN_CTL1 PWM Control Register
                  Offset (0x29),
                  R29R, 8,        // TMPIN1 Temperature Reading Register
                  Offset (0x2B),
                  R2BR, 8,
                  Offset (0x40),
                  R40R, 8,        // TMPIN1 High limit register
                  R41R, 8,        // TMPIN1 Low limit register
                  Offset (0x44),
                  R44R, 8,
                  R45R, 8,
                  Offset (0x51),
                  R51R, 8,
                  R52R, 8,        // TMPIN1 Thermal Output Limit Register
                  Offset (0x56),
                  R56R, 8,
                  R57R, 8,
                  Offset (0x59),
                  R59R, 8,
                  Offset (0x5C),
                  R5CR, 8,
                  Offset (0x60),
                  R60R, 8,        // SmartGuardian Automatic Mode Temperature Limit of OFF
                  R61R, 8,        // SmartGuardian Automatic Mode Temperature Limit of Start
                  R62R, 8,        // SmartGuardian Automatic Mode Temperature Limit of Full Speed
                  R63R, 8,         // FAN_CTL1 SmartGuardian Automatic Mode start PWM register
                  R64R, 8
                }
              
                // _FIF (Fan Information)
                //
                // The optional _FIF object provides OSPM with fan device capability information.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //  A Package containing the fan device parameters.
                //
                Method (_FIF)
                {
                  Return (Package (){
                    0,                          // Revision:Integer
                    1,                          // FineGrainControl:Integer Boolean
                    2,                          // StepSize:Integer DWORD
                    0                           // LowSpeedNotificationSupport:Integer Boolean
                  })
                }
              
                // _FPS (Fan Performance States)
                //
                // Evaluates to a variable-length package containing a list of packages that describe the fan device's performance states.
                //
                // Arguments: (0)
                //   None
                // Return Value:
                //  A variable-length Package containing a Revision ID and a list of Packages that describe the fan device's performance states.
                //
                Method (_FPS,,,,PkgObj)
                {
                  Return (Package()
                  {
                    0,      // Revision:Integer
                    //        Control,  TripPoint,    Speed,  NoiseLevel, Power
                    Package () {100,    0xFFFFFFFF,    255,   500,        5000},
                    Package () {95,     0xFFFFFFFF,    240,   475,        4750},
                    Package () {90,     0xFFFFFFFF,    220,   450,        4500},
                    Package () {85,     0xFFFFFFFF,    200,   425,        4250},
                    Package () {80,     0xFFFFFFFF,    180,   400,        4000},
                    Package () {70,     0xFFFFFFFF,    150,   350,        3500},
                    Package () {60,     0xFFFFFFFF,    130,   300,        3000},
                    Package () {50,     0xFFFFFFFF,    110,   250,        2500},
                    Package () {40,     0xFFFFFFFF,     90,   200,        2000},
                    Package () {30,     0xFFFFFFFF,     70,   150,        1500},
                    Package () {25,     0xFFFFFFFF,     50,   125,        1250},
                    Package () {0,      0xFFFFFFFF,      0,     0,           0}    // OFF
                  })
                }
              
                // 0x0A <- 0x64     ; enable SMB and PECI, 1 host clock
                // 0x14 <- 0xC0      ; active high PWM Fan output, default: 6MHz, 23.43KHz
                // 0x15 <- 0x82      ; enable smart/auto mode Fan1 - Tmpin3(PECI)
                // 0x16 <- 0x80      ; enable smart/auto mode Fan2 - Tmpin1
                // 0x51 <- 0xC3      ; set Fan1/Fan2 -> PECI DTS ->Tmpin3: Tmpin1/Tmpin2 thermal diode/transistor mode
              
                Store( 0x64 ,R0AR) //enable SMB and PECI, 1 host clock
                Store( 0xC0 ,R14R) //active high PWM Fan output, default: 6MHz, 23.43KHz
                Store( 0x82 ,R15R) // enable smart/auto mode Fan1 - Tmpin3(PECI)
                Store( 0xC3 ,R51R) //  set Fan1/
                Store( 0x3F ,R13R) //Select Fan2 reading temperature and select TempIn1
              
                //Ste the Fan Temp limits
                Store(0x10,R60R) // set Fan1 Off temp 16C               0x10              (Note: Fan1 being controlled by SoC DTS over PECI -> TMPIN3)
                Store(0x22,R61R) // set Fan1 Start temp 34C             0x22
                Store(0x3D,R62R) // set Fan1 Full temp 61C              0x3D
                Store(0x80,R63R) // start Fan 1 PWM < 50%               0x80
                Store(0x18,R64R) // set no fan 1 smoothing, slope is 128C/61C-34C or ~4.7         (0x18 is slope 3)
                // Enable Sensors
                Store(0x80,R5CR) //enable thermal diode zero degree adjust register write enable
                Store(0x64,R59R) // PECI offset for TMPIN3 (100C offset ?)
                Name (FSLV, 50)
              
                // _FSL (Fan Set Level)
                //
                // The optional _FSL object is a control method that OSPM evaluates to set a fan device's speed (performance state) to a specific level.
                //
                // Arguments: (1)
                //  Arg0 - Level (Integer): conveys to the platform the fan speed level to be set.
                // Return Value:
                //  None
                //
                // Argument Information
                //  Arg0: Level. If the fan supports fine-grained control, Level is a percentage of maximum level (0-100)
                //  that the platform is to engage the fan. If the fan does not support fine-grained control,
                //  Level is a Control field value from a package in the _FPS object's package list.
                //  A Level value of zero causes the platform to turn off the fan.
                //
                Method(_FSL,1,Serialized)
                {
                  Store(Arg0, FSLV)
                  //
                  //Turn off the fan
                  //
                  If(LEqual(Arg0, 0))
                  {
                    Store(0,R63R)
                  }
                  //
                  //Fan speed level set by user. The fan speed range based on _FPS package.
                  //
                  If(LAnd(LGreaterEqual(Arg0, 25),LLess(Arg0, 30))) {
                    Store(64,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 30),LLess(Arg0, 40))) {
                    Store(80,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 40),LLess(Arg0, 50))) {
                    Store(96,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 50),LLess(Arg0, 60))) {
                    Store(144,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 60),LLess(Arg0, 70))) {
                    Store(160,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 70),LLess(Arg0, 80))) {
                    Store(176,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 80),LLess(Arg0, 85))) {
                    Store(192,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 85),LLess(Arg0, 90))) {
                    Store(208,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 90),LLess(Arg0, 95))) {
                    Store(224,R63R)
                  }
                  If(LAnd(LGreaterEqual(Arg0, 95),LLess(Arg0, 100))) {
                    Store(240,R63R)
                  }
                  If(LEqual(Arg0,100)) {
                    Store(255,R63R)
                  }
                }
              
                Name (TFST,Package ()
                {
                  0,            // Revision:Integer
                  0xFFFFFFFF,   // Control:Integer DWORD
                  0xFFFFFFFF    // Speed:Integer DWORD
                })
              
                //_FST (Fan Status)
                //
                // The optional _FST object provides status information for the fan device.
                //
                // Arguments: (0)
                //  None
                // Return Value:
                //  A Package containing fan device status information
                //  The fan device status information will show on DTT UI
                //
                Method(_FST,0,Serialized,,PkgObj)
                {
                  Store(FSLV, Index(TFST, 1))  //Control ID: Show the fan speed level
                  Store(0x0D, Index(TFST, 2))  // Show the fan speed value in Auto mode
                  Return(TFST)
                } //End TFN3 device
              }

            }
            /** @file
              ACPI DSDT table
            
              Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
              SPDX-License-Identifier: BSD-2-Clause-Patent
            **/
            
            
            Device(UAR1)  // Serial Port A
            {
              Name(_HID, EISAID("PNP0501"))
            
              Name(_UID,11)
            
              // Status Method for COM A.
            
              Method(_STA,0,Serialized)
              {
                // Only report resources to the OS if the SIO Device is
                // not set to Disabled in BIOS Setup.
            
                If(LEqual(ITCM,1))
                {
                  // Set the SIO to COM A.
                  ENFG(0x01)
            
                  // Display COMA and return status.
            
                  If(IT30)
                  {
                    EXFG()
                    Return(0x000F)
                  }
                  EXFG()
                  Return(0x000D)
                }
                Return(0x0000)
              }
            
              // Disable Method for COM A.
            
              Method(_DIS,0,Serialized)
              {
                ENFG(0x01)
                Store(0,IT30)
                EXFG()
              }
            
              // Current Resource Setting Method for COM A.
            
              Method(_CRS,0,Serialized)
              {
                // Create the Buffer that stores the Resources to
                // be returned.
            
                Name(BUF0,ResourceTemplate()
                {
                  IO(Decode16,0x03F8,0x03F8,0x01,0x08)
                  IRQNoFlags(){4}
                })
            
                // Set SIO to COM A.
                ENFG(0x01)
                // Skip this sequence if the COMA Port is Disabled
                // in BIOS Setup.
            
                If(LEqual(ITCM,1))
                {
                  // Create pointers to the specific byte.
            
                  CreateByteField(BUF0,0x02,IOL0)
                  CreateByteField(BUF0,0x03,IOH0)
                  CreateByteField(BUF0,0x04,IOL1)
                  CreateByteField(BUF0,0x05,IOH1)
                  CreateByteField(BUF0,0x07,LEN0)
                  CreateWordField(BUF0,0x09,IRQW)
            
                  // Write IO and Length values into the Buffer.
            
                  Store(IT60,IOH0)
                  Store(IT61,IOL0)
                  Store(IT60,IOH1)
                  Store(IT61,IOL1)
                  Store(8,LEN0)
            
                  // Write the IRQ value into the Buffer.
            
                  And(IT70,0x0F,Local0)
                  If(Local0)
                  {
                    ShiftLeft(One,Local0,IRQW)
                  }
                  Else
                  {
                    Store(Zero,IRQW)
                  }
                }
            
                EXFG()
                Return(BUF0)
              }
            
              // Possible Resource Setting Method for COM A.
            
                // Build a Buffer with all valid COM Port Resources.
            
                Name(_PRS,ResourceTemplate()
                {
                  StartDependentFn(0,2)
                  {
                    IO(Decode16,0x3F8,0x3F8,0x01,0x08)
                    IRQNoFlags(){4}
                  }
            
                  StartDependentFn(0,2)
                  {
                    IO(Decode16,0x2F8,0x2F8,0x01,0x08)
                    IRQNoFlags(){3}
                  }
            
                  StartDependentFn(0,2)
                  {
                    IO(Decode16,0x3E8,0x3E8,0x01,0x08)
                    IRQNoFlags(){4}
                  }
            
                  StartDependentFn(0,2)
                  {
                    IO(Decode16,0x2E8,0x2E8,0x01,0x08)
                    IRQNoFlags(){3}
                  }
            
                  EndDependentFn()
                })
            
            
              // Set Resource Setting Method for COM A.
            
              Method(_SRS,1,Serialized)
              {
                // Point to the specific information in the passed
                // in Buffer.
            
                CreateByteField(Arg0,0x02,IOLO)
                CreateByteField(Arg0,0x03,IOHI)
                CreateWordField(Arg0,0x09,IRQW)
            
                // Set the SIO to COM A.
                ENFG(0x01)
            
                // Disable the device.
            
                Store(0,IT30)
            
                // Set the Base IO Address.
            
                Store(IOLO,IT61)
                Store(IOHI,IT60)
            
                // Set the IRQ.
            
                FindSetRightBit(IRQW,Local0)
                If(LNotEqual(IRQW,Zero))
                {
                  Decrement(Local0)
                }
                Store(Local0,IT70)
            
                // Set the Decode Range so COM A works on ICH7 and
                // future platforms.
            
                AND(IOD0,0xF8,IOD0)     // Clear all bits.
            
                If(LEqual(IOHI,0x03))     // Address = 0x3xx
                {
                  If(LEqual(IOLO,0xF8))   // Address = 0x3F8
                  {
                    Or(IOD0,0x00,IOD0)
                  }
                  Else        // Address = 0x3E8
                  {
                    Or(IOD0,0x07,IOD0)
                  }
                }
                Else          // Address = 0x2xx
                {
                  If(LEqual(IOLO,0xF8))   // Address = 0x2F8
                  {
                    Or(IOD0,0x01,IOD0)
                  }
                  Else        // Address = 0x2E8
                  {
                    Or(IOD0,0x05,IOD0)
                  }
                }
            
                // Enable the device.
            
                Store(1,IT30)
                EXFG()
              }
            
              // D0 Method for COM Port.
            
              Method(_PS0,0,Serialized)
              {
                ENFG(0x01)
                Store(1,IT30)
                EXFG()
              }
            
              // D3 Method for COM Port.
            
              Method(_PS3,0,Serialized)
              {
                ENFG(0x01)
                Store(0,IT30)
                EXFG()
              }
            }
            














































































































































































































































#line 29009 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"

          }
        
        
        
        
        }

  
        If (LEqual(\ECON,1)){
              /** @file
              
                Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
                SPDX-License-Identifier: BSD-2-Clause-Patent
              **/
              
              External(HGAS, MethodObj)
              External(HPFS, MethodObj)
              External(HBRT, MethodObj)
              External(CHPS, MethodObj)
              External(UP1D)
              External(SVRF, MethodObj)
              External(\_SB.PC00.CTCU, MethodObj)
              External(\_SB.PC00.CTCN, MethodObj)
              External(\_SB.PC00.CTCD, MethodObj)
              External(\_SB.PC00.GFX0.GLID, MethodObj)
              External(\_SB.PC00.GFX0.GDCK, MethodObj)
              External(\_SB.PC00.GFX0.IUEH, MethodObj)
              External(\_SB.PC00.GFX0.GHDS, MethodObj)
              External(\_SB.TPWR, DeviceObj)
              External(\_SB.BAT1, DeviceObj)
              External(\_SB.UBTC, DeviceObj)
              External(\_SB.UBTC.MGI0, IntObj)
              External(\_SB.UBTC.MGI1, IntObj)
              External(\_SB.UBTC.MGI2, IntObj)
              External(\_SB.UBTC.MGI3, IntObj)
              External(\_SB.UBTC.MGI4, IntObj)
              External(\_SB.UBTC.MGI5, IntObj)
              External(\_SB.UBTC.MGI6, IntObj)
              External(\_SB.UBTC.MGI7, IntObj)
              External(\_SB.UBTC.MGI8, IntObj)
              External(\_SB.UBTC.MGI9, IntObj)
              External(\_SB.UBTC.MGIA, IntObj)
              External(\_SB.UBTC.MGIB, IntObj)
              External(\_SB.UBTC.MGIC, IntObj)
              External(\_SB.UBTC.MGID, IntObj)
              External(\_SB.UBTC.MGIE, IntObj)
              External(\_SB.UBTC.MGIF, IntObj)
              External(\_SB.UBTC.CCI0, IntObj)
              External(\_SB.UBTC.CCI1, IntObj)
              External(\_SB.UBTC.CCI2, IntObj)
              External(\_SB.UBTC.CCI3, IntObj)
              External(\_SB.UBTC.STS0, IntObj)
              External(\_SB.UBTC.STS1, IntObj)
              External(\_SB.UBTC.STS2, IntObj)
              External(\_SB.UBTC.STS3, IntObj)
              External(\_SB.UBTC.STS4, IntObj)
              External(\_SB.UBTC.STS5, IntObj)
              External(\_SB.UBTC.STS6, IntObj)
              External(\_SB.UBTC.STS7, IntObj)
              External(\_SB.PC00.GFX0.IUER, IntObj)
              External(\LIDS)
              External(\IGDS)
              External(\BRTL)
              External(\_SB.HIDD.HPEM, MethodObj)
              External(\_SB.HIDD.BTLD, MethodObj)
              External(\_SB.HIDD.HRDY, MethodObj)
              
              
              
              
              
              
              
              
              
              Device(H_EC)  // Hitachi Embedded Controller
              {
                Name(_HID, EISAID("PNP0C09"))
              
                Name(_UID,1)
              
                Name(ECAV, Zero)   // OS Bug Checks if EC OpRegion accessed before Embedded Controller Driver loaded
                Name(ECTK, One)    // ECDT (Embedded Controller Boot Resources Table) Check to correct ECAV flag in the beginning
                Name(BNUM, 0)  // Number Of Batteries Present
              
                // EC Mutex
                Mutex(ECMT, 0)
              
                Method(_CRS,0, Serialized)
                {
                  Name(BFFR, ResourceTemplate()
                  {
                    IO(Decode16,0x62,0x62,0,1)  // DIN/DOUT
                    IO(Decode16,0x66,0x66,0,1)  // CMD/STS
                  })
              
                  Return(BFFR)
                }
              
                Method(_STA)
                {
                  If (LEqual(ECON,1)){
                    Return(0x0F)
                  }
                  Return(0x00)
                }
              
                OperationRegion(ECF3,EmbeddedControl,0,0xFF)
                Field(ECF3,ByteAcc,Lock,Preserve)
                {
                  Offset(4),
                  IWCW, 160,    // EC buffer, send data to EC
                  Offset(24),
                  IWCR, 160,
                }
              
                OperationRegion(ECF2,EmbeddedControl,0,0xFF)
                Field(ECF2,ByteAcc,Lock,Preserve)
                {
                  Offset(1),
                  PLMX, 8,      // 1       Max Platform temprature
                  LTMP, 8,      // 2       Sensor Temperature
                  RPWR, 1,      // 3.0     Real AC Power (AC Present = 1)
                      , 2,      // 3.2:1   Reserved
                  CFAN, 1,      // 3.3     CPU Fan (Fan On = 1)
                      , 2,      // 3.5:4   Reserved
                  LSTE, 1,      // 3.6     Lid State (Lid Open = 1)
                      , 1,      // 3.7     Reserved
                  MGI0, 8,  //Offset 4, PPM->OPM Message In, 128 bits, 16 bytes
                  MGI1, 8,
                  MGI2, 8,
                  MGI3, 8,
                  MGI4, 8,
                  MGI5, 8,
                  MGI6, 8,
                  MGI7, 8,
                  MGI8, 8,
                  MGI9, 8,
                  MGIA, 8,
                  MGIB, 8,
                  MGIC, 8,
                  MGID, 8,
                  MGIE, 8,
                  MGIF, 8,
                  MGO0, 8,  //  Offset 20, OPM->PPM Message Out, 128 bits, 16 bytes
                  MGO1, 8,
                  MGO2, 8,
                  MGO3, 8,
                  MGO4, 8,
                  MGO5, 8,
                  MGO6, 8,
                  MGO7, 8,
                  MGO8, 8,
                  MGO9, 8,
                  MGOA, 8,
                  MGOB, 8,
                  MGOC, 8,
                  MGOD, 8,
                  MGOE, 8,
                  MGOF, 8,
                  CCI0, 8,  //  Offset 36, PPM->OPM CCI indicator, 4 bytes,
                  CCI1, 8,
                  CCI2, 8,
                  CCI3, 8,
                  Offset(47),
                  CTMP, 8,      // 47      EC Critical Temperature
                      , 1,      // 48.0    Reserved
                      , 2,      // 48.2:1  Reserved
                  PBNS, 1,      // 48.3    Power Button State (0 = Pressed)
                  VPWR, 1,      // 48.4    Virtual AC Power (AC Present = 1)
                      , 3,      // 48.7:5  Reserved
                  SCAN, 8,      // 49      Hot-Key Scan Code
                  B1ST, 8,      // 50      Battery 1 Status
                  Offset(54),
                  B2ST, 8,      // 54      Battery 2 Status
                  Offset(58),
                  CMDR, 8,      // 58      KSC command register
                  Offset(65),
                  PPSL, 8,      // 65      PWM Port Select low byte
                  PPSH, 8,      // 66      PWM Port Select high byte
                  PINV, 8,      // 67      PWM initial value
                  PENV, 8,      // 68      PWM ending value
                  PSTP, 8,      // 69      PWM ms delay between steps
                  Offset(71),
                  CPUP, 16,     // 71,72   CPU Power mW
                  BPWR, 16,     // 73,74   Brick Power cW(100ths)
                  PPWR, 16,     // 75,76   Platform Power cW(100ths)
                  //
                  // PwrSrcType Bit[0] = 0 <DC>, Bit[0] = 1 <AC>, Bit[1] = 1 <USB-PD>, Bit[2] = 1 <Wireless Charging>
                  // Bit[7:4]  = Power Delivery State Change Sequence Number
                  Offset(78),
                  PWRT, 8,     // 78
                  PBOK, 8,     // 79       PBOK offset where BIOS will update the Power Delivery State Change Sequence Number
                  Offset(80),
                  TSI,  4,      // 80      TemSnsrSelct Select Thermal Sensor
                                //          # 0 = SEN1
                                //          # 1 = SEN2
                                //          # 2 = SEN3
                                //          # 3 = SEN4
                                //          # 4 = SEN5
                                //          # 5 = SEN6
                                //          # 6 = SEN7
                                //          # 7 = SEN8
                                //          # 8 = SEN9
                                //          # 9 = SEN10
                                //          # A = SEN11
                                //          # B = SEN12
                                //          # C = SEN13
                                //          # D = SEN14
                                //          # E = SEN15
                                //          # F = SEN16
                  HYST, 4,      // Hysteresis selection is global and meant for all sensors
                  TSHT, 16,     // 81-82   TempThrshldH Sensor High Trip Point
                  TSLT, 16,     // 83-84   TempThrshldL Sensor Low Trip Point
                  Offset(85),
                  TSSR, 16,     // 85- 86  TSSR- thermal sensor status register:
                                //         Responsible for triggering _QF1:
                                //          BIT0:  SEN1
                                //          BIT1:  SEN2
                                //          BIT2:  SEN3
                                //          BIT3:  SEN4
                                //          BIT4:  SEN5
                  Offset(87),
                  B1DC, 16,     // 87      Battery 1 Design Capacity (mWh)
                  B1RC, 16,     // 89      Battery 1 Remaining Capacity (mWh)
                  B1FC, 16,     // 91      Battery 1 Full Charge Capacity (mWh)
                  B1FV, 16,     // 93      Battery 1 Full Resolution Voltage (mV)
                  B1DI, 16,     // 95      Battery 1 Full Resolution Discharge Current (mA)
                  B1CI, 16,     // 97      Battery 1 Full Resolution Charge Current (mA)
                  B2RC, 16,     // 99      Battery 2 Remaining Capacity (mWh)
                  B2FC, 16,     // 101     Battery 2 Full Charge Capacity (mWh)
                  B2FV, 16,     // 103     Battery 2 Full Resolution Voltage (mV)
                  B2DI, 16,     // 105     Battery 2 Full Resolution Discharge Current (mA)
                  B2CI, 16,     // 107     Battery 2 Full Resolution Charge Current (mA)
                  VMIN, 16,     // 109,110 Min voltage below which platform activates OC protection and shuts down (mV).
                  PROP, 16,     // 111,112 Worst case rest of platform power in (W).
                  DFSP, 16,     // 113,114 DDR Fan speed in rpm
                  CFSP, 16,     // 115,116 CPU Fan speed in rpm
                  GFSP, 16,     // 116,117 GPU Fan speed in rpm
                  Offset(120),  // (0x78)
                  DLED, 1,      // 120.0   EC Connected Standby Debug LED (CAPS LOCK)
                      , 2,      // 120.2:1   Reserved
                  DOCO, 1,      // 120.3   Dock Orientation - 1 if normal, 0 for reverse
                  Offset(122),
                  AVOL, 16,     // 122,123 Returns the AC source nominal voltage in (mV).
                  Offset(125),
                  ACUR, 16,     // 125,126 Returns the AC source operational current in (mA).
                  Offset(128),
                  PMAX, 8,      // 128     CPU,MCH & PCH Max temp
                  PPDT, 8,      // 129     PCH DTS reading from PCH
                  PECL, 8,      // 130     CPU PECI reading fractional value (1/64 Celcius)
                  PECH, 8,      // 131     CPU PECI reading integer value (unit Celicus)
                  Offset(135),
                  ARTG, 16,     // 135,136 AC adapter rating in 10 mW. Max adapter power supported. Because of EC-space constraint EC can only send 2bytes=15000mW but system uses 150000mW hence bios will multiply this value by 10 and return.
                  CTYP, 8,      // 137     Charger type, Traditional or Hybrid
                  AP01, 8,      // 138     Returns AC source 1ms period percentage overload in 1% unit.
                  AP02, 8,      // 139     Returns AC source 2ms period percentage overload in 1% unit.
                  AP10, 8,      // 140     Returns AC source 10ms period percentage overload in 1% unit.
                  PBSS, 16,     // 141,142 Max sustained power for battery (mW)
                  BICC, 16,     // 143,144 _BIX.Cycle Count
                  Offset(145),
                  TSR1, 16,     // 145,146 Sensor SEN1
                  TSR2, 16,     // 147,148 Sensor SEN2
                  TSR3, 16,     // 149,150 Sensor SEN3
                  TSR4, 16,     // 151,152 Sensor SEN4
                  TSR5, 16,     // 153,154 Sensor SEN5
                  Offset(155),
                  PRC1, 8,      // 155     Peci Repeat Cycle (LSB)
                  PRC2, 8,      // 156     Peci Repeat Cycle
                  PRC3, 8,      // 157     Peci Repeat Cycle
                  PRC4, 8,      // 158     Peci Repeat Cycle (MSB)
                  PRPI, 8,      // 159     Peci Repeat Period Interval
                  PECN, 8,      // 160     Peci Error Count Number
                  PCAD, 8,      // 161     Peci Clinet Addess
                  PEWL, 8,      // 162     Write Length
                  PWRL, 8,      // 163     Read lenght
                  PECD, 8,      // 164     Command Code
                  PEHI, 8,      // 165     Host ID
                  PECI, 8,      // 166     Index
                  PEPL, 8,      // 167     Parameter (LSB)
                  PEPM, 8,      // 168     Parameter (MSB)
                  PWFC, 8,      // 169     Write FCS
                  PECC, 8,      // 170     Completion code
                  PDT0, 8,      // 171     Data 0
                  PDT1, 8,      // 172     Data 1
                  PDT2, 8,      // 173     Data 2
                  PDT3, 8,      // 174     Data 3
                  PRFC, 8,      // 175     Read FCS
                  PRS0, 8,      // 176     Reserved
                  PRS1, 8,      // 177     Reserved
                  PRS2, 8,      // 178     Reserved
                  PRS3, 8,      // 179     Reserved
                  PRS4, 8,      // 180     Reserved
                  Offset(187),
                  PRCS, 8,      // 187     Peci Repeat Command Status
                  PEC0, 8,      // 188     Peci Error Count (LSB)
                  PEC1, 8,      // 189     Peci Error Count
                  PEC2, 8,      // 190     Peci Error Count
                  PEC3, 8,      // 191     Peci Error Count (MSB)
                  Offset(195),
                  WTMM, 8,      // 195     Wake timer mode (C3)
                  WTMV, 32,     // 196     Wake time value (C4)
              
                  SPT2, 1,      // 200.0   SATA Por2 - Cable connect power control. 1=ON;0=OFF
                  ,7,           // 200.7-1  Reserved
                  Offset(201),
                  BTEN, 8,      // 201     Button Enable/Disable
                                //          201.0: Power Button N/A to disable
                                //          201.1: Windows Button
                                //          201.2: Volume Up Button
                                //          201.3: Volume Down Button
                                //          201.4: Rotation Lock Button
                                //          201.5-8: Reserved
                  Offset(209),
                  B2DC, 16,     // 209     Battery 2 Design Capacity (mWh)
                  B1DV, 16,     // 211     Battery 1 Design Voltage (mV)
                  B2DV, 16,     // 213     Battery 2 Design Voltage (mV)
                  Offset(215),
                  BMAX, 16,     // 215     Battery A maximum
                  B2ML, 8,      // 217     BattBPmaxL - Battery Pack B maximum low byte
                  B2MH, 8,      // 218     BattBPmaxH - Battery Pack B maximum high byte
                  BTP1, 8,      // 219     Battery 1 Trip Point in %
                  B1TL, 8,      // 220     Battery 1 Trip Point lower byte in mAh
                  B1TH, 8,      // 221     Battery 1 Trip Point higher byte in mAh
                  KBDB, 8,      // 222     Keyboard brightness Percentage
                  CHGR, 16,     // 223     Charge Rate
                  Offset(231),
                  SCCK, 8,      // 231     Ctrl+Alt+Shit(CAS)+Key Scan Code
                  PVOL, 8,      // 232     Pmic Vendor ID and Voltage Margining byte
                  FCHG, 8,      // 233     Fast Charging Enabled.
                  CTL0, 8,      // 234     OPM->PPM Control message, 8 bytes,
                  CTL1, 8,
                  CTL2, 8,
                  CTL3, 8,
                  CTL4, 8,
                  CTL5, 8,
                  CTL6, 8,
                  CTL7, 8,
                  Offset(244),  // 244 (0xF4)
                  VBUS, 1,      // BIT0 -  VBUS Sense
                  OTGI, 1,      // BIT1 -  OTG ID
                  Offset(245),
                  RBHF, 16,     // 245-246 Battery high frequency impedance
                  VBNL, 16,     // 247-248 Battery No-Load Voltage
                  CMPP, 16,     // 249-250 Battery Maximum peak current
                  Offset(251),
                  UVTH, 16,     // 251-252 Under Voltage Threshold
                }
              
              
                // ECRD (Embedded Read Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (1)
                //    Arg0 - Object to Read
                //  Return Value:
                //    Read Value
                //
                Method(ECRD,1,Serialized, 0, IntObj, FieldUnitObj)
                {
                  //
                  // Check for ECDT support, set ECAV to One if ECDT is supported by OS
                  // Only check once at beginning since ECAV might be clear later in certain conditions
                  //
                  If (ECTK) {
                    If (LGreaterEqual (_REV, 2)) {
                      Store (One, ECAV)
                    }
                    Store (Zero, ECTK)   // Clear flag for checking once only
                  }
              
                  Store (Acquire(ECMT, 1000), Local0)  // save Acquire result so we can check for Mutex acquired
                  If (LEqual(Local0, Zero))  // check for Mutex acquired
                  {
                    If (ECAV) {
                      Store(DerefOf (Arg0), Local1) // Execute Read from EC
                      Release(ECMT)
                      Return(Local1)
                    }
                    Else
                    {
                      Release(ECMT)
                    } // If (ECAV)
                  } // If EC Acquired
                  Return(0)
                }
              
                // ECWT (Embedded Write Method)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (2)
                //    Arg0 - Value to Write
                //    Arg1 - Object to Write to
                //
                Method(ECWT,2,Serialized,,,{IntObj, FieldUnitObj})
                {
                  //
                  // Check for ECDT support, set ECAV to One if ECDT is supported by OS
                  // Only check once at beginning since ECAV might be clear later in certain conditions
                  //
                  If (ECTK) {
                    If (LGreaterEqual (_REV, 2)) {
                      Store (One, ECAV)
                    }
                    Store (Zero, ECTK)   // Clear flag for checking once only
                  }
              
                  Store (Acquire(ECMT, 1000), Local0)  // save Acquire result so we can check for Mutex acquired
                  If (LEqual(Local0, Zero))  // check for Mutex acquired
                  {
                    If (ECAV) {
                      Store(Arg0,Arg1) // Execute Write to EC
                    } // If (ECAV)
                    Release(ECMT)
                  } // If EC Acquired
                }
              
                // ECMD (Embedded Controller Command)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (1)
                //    Arg0 - EC command
                //  Return Value:
                //    0x00 = Success
                //    0xFF = Failure
                //
                Method(ECMD,1,Serialized)
                {
                  //
                  // Check for ECDT support, set ECAV to One if ECDT is supported by OS
                  // Only check once at beginning since ECAV might be clear later in certain conditions
                  //
                  If (ECTK) {
                    If (LGreaterEqual (_REV, 2)) {
                      Store (One, ECAV)
                    }
                    Store (Zero, ECTK)   // Clear flag for checking once only
                  }
              
                  If (ECAV) {
                    Store (ECRD (RefOf (CMDR)), Local0)
                    Store (0, Local1)
                    //
                    // Time out value is 10 second
                    //
                    While (LAnd (Local0, LLess (Local1, 5000))) {
                      Stall (200)
                      Store (ECRD (RefOf (CMDR)), Local0)
                      Increment (Local1)
                    }
              
                    If (LGreaterEqual (Local1, 5000)) {
                      Return (0xFF)
                    }
              
                    ECWT (Arg0, RefOf (CMDR))
                    Return (0x00)
                  }
                  Return (0xFF)
                }
              
              
                // ECNT (Embedded Controller Notify)
                //
                // Handle all commands sent to EC by BIOS
                //
                //  Arguments: (1)
                //    Arg0 - 3 = Idle Resiliency Entry Notify
                //           2 = Idle Resiliency Exit Notify
                //           1 = CS Entry Notify
                //           0 = CS Exit Notify
                //  Return Value:
                //    0x00 = Success
                //    0xFF = Failure
                //
                Method (ECNT,1,Serialized) {
                  Switch (ToInteger(Arg0)) {
                    Case (0) { // exit CS
                      D8XH (0, 0xC5)
                      D8XH (1, 0xAA)
                      if (LEqual(ECNO,0x01)) { // Check EC notification enabled in Setup
                        Store (Acquire(\EHLD, 0xFFFF), Local0) // Wait for Mutex for telling EC to exit Low Power Mode
                        if (LEqual(Local0, Zero)) {
                          \_SB.PC00.LPCB.H_EC.ECMD (0x2D) // Notify EC of CS exit
                          If (LEqual(ECLP, 0x1)) {
                            Store (One,\ECUP)
                          }
                          Release (\EHLD)
                        }
                      }
                      Return (0x00)
                    }
              
                    Case(1) { // enter CS
                      D8XH (0, 0xC5)
                      D8XH (1, 0x01)
              
                      if (LEqual(ECNO,0x01)) { // Check EC notification enabled in Setup
                        \_SB.PC00.LPCB.H_EC.ECMD (0x2C) // Notify EC of CS entry
                        If (LEqual(ECLP, 0x1)) {
                          Store (Zero,\ECUP)
                        }
                      }
                      Return (0x00)
                    }
              
                    Default {
                      Return (0xFF)  // Error invalid argument
                    }
                  }
                }
              
                // EREG method will be used in _REG (evaluated by OS without ECDT support) or _INI (for OS with ECDT support)
                Method(EREG)
                {
                  // Update ECAV Object. ASL should check for this value to be One before accessing EC OpRegion.
                  Store(One, ECAV)
              
                  // Turn off the CPU Fan if Active Cooling is disabled.
                  If (LEqual(0,ACTT))
                  {
                    ECWT(0,RefOf(CFAN))
                  }
              
                  // Turn off pwm fan so it starts in a known state for legacy thermal zone only.
                  If (CondRefOf(\_TZ.ETMD))
                  {
                    If(LEqual(\_TZ.ETMD,1))
                    {
                      \_TZ.FN00._OFF()
                    }
                  }
              
                  // Save the Lid State in global NVS and IGD OpRegion.
                  //Store(LSTE,\_SB.PC00.GFX0.CLID)
                  If (LEqual(ECRD(RefOf(LSTE)), 0))
                  {
                    Store(0,\_SB.PC00.GFX0.CLID)
                  }
                  If (LEqual(ECRD(RefOf(LSTE)), 1))
                  {
                    Store(3,\_SB.PC00.GFX0.CLID)
                  }
                  Store(ECRD(RefOf(LSTE)),LIDS)
              
                  // Update the Dock Status
                  Store(\DSTS,\_SB.PC00.GFX0.CDCK)
              
                  // Unconditionally fix up the Battery and Power State.
              
                  // Initialize the Number of Present Batteries.
                  //  1 = Real Battery 1 is present
                  //  2 = Real Battery 2 is present
                  //  3 = Real Battery 1 and 2 are present
                  Store(0,BNUM)
                  Or(BNUM,ShiftRight(And(ECRD(RefOf(B1ST)),0x08),3),BNUM)
                  Or(BNUM,ShiftRight(And(ECRD(RefOf(B2ST)),0x08),2),BNUM)
              
              
                  // Initialize the Power State.
                  //  BNUM = 0 = Virtual Power State
                  //  BNUM > 0 = Real Power State
                  If (LEqual(BNUM,0))
                  {
                    Store(ECRD(RefOf(VPWR)),PWRS)
                  }
                  Else
                  {
                    Store(ECRD(RefOf(RPWR)),PWRS)
                  }
              
                  // Perform needed ACPI Notifications.
              
                  SPNT()
                }
              
                // The _REG Method is needed because communication with the EC
                // before the driver is loaded is prohibited in WIN2000/WINXP.
                // According to ACPI spec, the arguments:
                //   Arg0 - Opertion Region Address space ID
                //   Arg1 - handler connection code
                Method(_REG,2)
                {
                  // When OS runs _REG control method with Arg0 = 3 (Embedded Controller Operation Region) and Arg1 = 1 (connect the handler)
                  If (LAnd(LEqual(Arg0,3),LEqual(Arg1,1)))
                  {
                    // Must be running NT 5.0 OS or newer.
                    EREG()
                  }
                }
              
                // The _REG Method will not evaluated if ECDT is loaded by OS with ECDT support
                // Uising _INI Method to cover EC initialization done in _REG
                Method(_INI)
                {
                  If (LGreaterEqual (_REV, 2)) {
                    // Only for OS with ECDT support, such as Vista or newer Windows OS
                    EREG()
                  }
              
                  If (LEqual(\S0ID,1)) {
                    //
                    // Enable SCIs in EC to trigger QD5 and QD6 event
                    //
                    \_SB.PC00.LPCB.H_EC.ECWT(0x01, RefOf(\_SB.PC00.LPCB.H_EC.BTEN)) //Enable EC Power Button in ACPI name space
                    \_SB.PC00.LPCB.H_EC.ECMD(0x38)                                  //Enable/Disable SCIs from buttons
                  }
                }
              
                // Update Timer value in EC mailbox
                // Arg0: Timer mode
                // Arg1: TimerValue
                Method(UTEC, 2)
                {
                   \_SB.PC00.LPCB.H_EC.ECWT(Arg0, RefOf(\_SB.PC00.LPCB.H_EC.WTMM))
                   If(LNotEqual(Arg1,0xFFFFFFFF)) {
                      \_SB.PC00.LPCB.H_EC.ECWT(Arg1, RefOf(\_SB.PC00.LPCB.H_EC.WTMV))
                      \_SB.PC00.LPCB.H_EC.ECMD(0x2F)
                   }
                }
              
                //
                // The _GPE method needs to be the same as the GPE number assignment in ECDT
                //
                Method(_GPE)
                {
                  If (\_SB.PC00.LPCB.ESPI)
                  {
                    Store (0x6E,  Local0)   // GPI6E for eSPI
                  } Else {
                      Store (23,  Local0)     // GPI23 for other boards
                      If (LNotEqual(\SRSP, 0))
                      {
                         Store (GGPE(\SRSP), Local0)  // SMC Runtime SCI
                      }
                  }
                  return (Local0)
                }
              
                // For the below _Qxx Methods, The Runtime SCI has been asserted,
                // the EC Driver performed it's query, and the value returned from
                // the Query = xx.
              
                Method(_Q30)    // Real Battery AC Insertion Event.
                {
                  // Set Global Power State = AC Mode.
              
                  Store(1,PWRS)
              
                  // Perform needed ACPI Notifications.
                  If(LAnd(LEqual(\DPTF,1), LEqual(\PWRE,1))) {
                     Notify(\_SB.TPWR, 0x81) // notify Power participant
                  }
              
                  SPNT()
                }
              
                Method(_Q31)    // Real Battery AC Removal Event.
                {
                  // Set Global Power State = Battery Mode.
              
                  Store(0,PWRS)
              
                  // Perform needed ACPI Notifications.
                  If(LAnd(LEqual(\DPTF,1), LEqual(\PWRE,1))) {
                     Notify(\_SB.TPWR, 0x81) // notify Power participant
                  }
              
                  SPNT()
                }
              
                Method(_Q32)    // Real Battery Capacity Change.
                {
                  // Perform needed ACPI Notifications.
                  If(LAnd(LEqual(\DPTF,1), LEqual(\BATR,1))) {
                     Notify(\_SB.BAT1, 0x86) // notify Battery participant
                  }
              
                  SPNT()
                }
              
                Method(_Q33)    // Real Battery Insertion/Removal Event.
                {
                  // Initialize the Number of Present Batteries.
                  //  1 = Real Battery 1 is present
                  //  2 = Real Battery 2 is present
                  //  3 = Real Battery 1 and 2 are present
              
                  Store(0,BNUM)
                  Or(BNUM,ShiftRight(And(ECRD(RefOf(B1ST)),0x08),3),BNUM)
                  Or(BNUM,ShiftRight(And(ECRD(RefOf(B2ST)),0x08),2),BNUM)
              
                  // Perform needed ACPI Notifications.
                  If(LAnd(LEqual(\DPTF,1), LEqual(\PWRE,1))) {
                     Notify(\_SB.TPWR, 0x81) // notify Power participant
                  }
              
                  SPNT()
                }
              
                Method(_Q34)    // PMAX changed by 250mw
                {
                  If(LAnd(LEqual(\DPTF,1), LEqual(\BATR,1))) {
                    Notify(\_SB.BAT1, 0x80) // notify battery participant
                  }
                }
              
              
                Method(_Q35)    // PBSS changed by 100mw
                {
                  If(LAnd(LEqual(\DPTF,1), LEqual(\BATR,1))) {
                    Notify(\_SB.BAT1, 0x83) // notify battery participant
                  }
                }
              
                Method(_Q37)    //PWR_SRC_CHANGE_SCI
                {
                  //
                  // This SCI is supported by EC for KBL onwards not SKL SDS.
                  //
              
                  //PWRT 78d PwrSrcType Bit0=1 if AC, Bit1=1 if USB-PD, Bit2=1 if Wireless Charging
                  P8XH(0,0x37)
              
                  And(\_SB.PC00.LPCB.H_EC.PWRT, 0x03, Local0)
              
                  If (LOr(LEqual(Local0, 1), LEqual(Local0, 2))) {
                    Store(1, PWRS)     // AC or USB-PD Insertion
                  }
              
                  If(LEqual(Local0, 0x0)) {
                    Store(0, PWRS)     // AC or USB-PD Removal
                  }
              
                  // Perform needed ACPI Notifications.
                  If(LAnd(LEqual(\DPTF,1), LEqual(\PWRE,1))) {
                     Notify(\_SB.TPWR, 0x81) // notify Power participant
                  }
                  SPNT()
                }
              
                Method(_Q38)    //RBHF value is changed over a threshold, 5mOhm.
                {
                  If(LAnd(LEqual(\DPTF,1), LEqual(\BATR,1))) {
                    Notify(\_SB.BAT1, 0x85) // notify battery participant
                  }
                }
              
                Method(_Q39)    //VBNL value is changed over a threshold, for example, 50mV.
                {
                  If(LAnd(LEqual(\DPTF,1), LEqual(\BATR,1))) {
                    Notify(\_SB.BAT1, 0x86) // notify battery participant
                  }
                }
              
                Method(_Q3A)    //CMPP value value is changed over a threshold, for example,  100mA.
                {
                  If(LAnd(LEqual(\DPTF,1), LEqual(\BATR,1))) {
                    Notify(\_SB.BAT1, 0x86) // notify battery participant
                  }
                }
              
                Method(_Q40, 0, Serialized)   // Dock complete Event
                {
              //@todo: Waiting for DOCK offect data
              //    If (LEqual(ECRD(RefOf(DOCK)), 0)) {
                  P8XH(0,0x40)
                  Return()
              //    }
              
              //@todo: Temporary reomove for fix iasl compiler warning.
              //    Sleep(1000) // Delay 1 second for hot docking stability
              //    Store(DKSM, \SSMP)
              //    Store(1, \DSTS)
              //    Sleep(1000) // Delay 1 second for hot docking stability
              //    Notify(\_SB.PC00.DOCK, 0x00)
              //
              //    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
              //      Or(PB1E, 0x10, PB1E)   // Set Dock status
              //      UPBT(DOCK_INDICATOR, One)
              //      Notify(\_SB.HIDD, 0xCA)    // Notify HID Event Filter driver that the system is now in Dock mode.
              //      If (LEqual(\CEDS,1)) {
              //        If (LEqual(ECRD(RefOf(DOCO)), 1)) {
              //          Or(PB1E, 0x08, PB1E) // Set Laptop status
              //          UPBT(CONVERTIBLE_BUTTON, One)
              //          Notify(\_SB.HIDD, 0xCD)  // Notify HID Event Filter driver that the system is now in Laptop mode.
              //        } Else {
              //          And(PB1E, Not(0x08), PB1E) // Clear Laptop Status
              //          UPBT(CONVERTIBLE_BUTTON, Zero)
              //          Notify(\_SB.HIDD, 0xCC)        // Notify HID Event driver that the system is now in Slate mode.
              //        }
              //      }
              //    } Else {
              //      If (IGDS)
              //      {
              //        \_SB.PC00.GFX0.GDCK(1)
              //      }
              //      If (LEqual(\CEDS,1)) {
              //        If (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
              //          \_SB.PC00.GFX0.IUEH(6)
              //          \_SB.PC00.GFX0.IUEH(7)
              //        }
              //      }
              //    }
              
                }
              
                Method(_Q41)    // Surprise Removal
                {
              //@todo: Waiting for DOCK offect data
              //    If (LEqual(ECRD(RefOf(DOCK)), 1)) {
                  P8XH(0,0x41)
                  Return()
              //    }
              
              //@todo: Temporary reomove for fix iasl compiler warning.
              //    Store(0, \DSTS)
              //    Sleep(1000) // Delay 1 second for hot un-docking stability
              //    Notify(\_SB.PC00.DOCK, 0x01)
              //
              //    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
              //      And(PB1E, Not(0x10), PB1E)   // Clear Dock Status
              //      UPBT(DOCK_INDICATOR, Zero)
              //      Notify(\_SB.HIDD, 0xCB)          // Notify HID Event Filter driver that the system is now in Undock mode.
              //      If (LEqual(\CEDS,1)) {
              //        And(PB1E, Not(0x08), PB1E) // Clear Laptop Status
              //        UPBT(CONVERTIBLE_BUTTON, Zero)
              //        Notify(\_SB.HIDD, 0xCC)        // Notify HID Event Filter driver that the system is now in Slate mode.
              //      }
              //    } Else {
              //      If (IGDS)
              //      {
              //        \_SB.PC00.GFX0.GDCK(0)
              //      }
              //      If (LEqual(\CEDS,1)) {
              //        If (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
              //          \_SB.PC00.GFX0.IUEH(6)
              //          \_SB.PC00.GFX0.IUEH(7)
              //        }
              //      }
              //    }
              
                }
              
                Method(_Q42)    // Undocking request Event
                {
                }
              
                Method(_Q43)    // Express Card Presence Changed on Saddlestring (Docking)
                {
                  Notify(\_SB.PC00.RP07, 0x0)
                }
              
                Method(_Q44)  // Virtual Dock Presence Changed
                {
                }
              
                //
                // SCI handler for USB device Attach/Detach notification
                //
              
                // XDAT: XDCI device attach/detach
                // Return 1 when device attach
                // Return 0 when device detach
                Method(XDAT)
                {
                  If(LEqual(VBUS,1)){
                    Return(1)
                  }Else{
                    Return(0)
                  }
                }
                Method(_Q77)
                {
                  If(LEqual(XDAT(), 1)){
                    Notify(\_SB.PC00.XDCI,0x80)
                  }
                }
              
                Method(UCEV, 0, Serialized)    // Any event on USBTypeC.
                {
                    P8XH(0, 0x79)
                    Store( MGI0, \_SB.UBTC.MGI0 )
                    Store( MGI1, \_SB.UBTC.MGI1 )
                    Store( MGI2, \_SB.UBTC.MGI2 )
                    Store( MGI3, \_SB.UBTC.MGI3 )
                    Store( MGI4, \_SB.UBTC.MGI4 )
                    Store( MGI5, \_SB.UBTC.MGI5 )
                    Store( MGI6, \_SB.UBTC.MGI6 )
                    Store( MGI7, \_SB.UBTC.MGI7 )
                    Store( MGI8, \_SB.UBTC.MGI8 )
                    Store( MGI9, \_SB.UBTC.MGI9 )
                    Store( MGIA, \_SB.UBTC.MGIA )
                    Store( MGIB, \_SB.UBTC.MGIB )
                    Store( MGIC, \_SB.UBTC.MGIC )
                    Store( MGID, \_SB.UBTC.MGID )
                    Store( MGIE, \_SB.UBTC.MGIE )
                    Store( MGIF, \_SB.UBTC.MGIF )
                    Store( CCI0, \_SB.UBTC.CCI0 )
                    Store( CCI1, \_SB.UBTC.CCI1 )
                    Store( CCI2, \_SB.UBTC.CCI2 )
                    Store( CCI3, \_SB.UBTC.CCI3 )
              
                    Notify(\_SB.UBTC,0x80)
                }
                Method(_Q76)    // Any event on USBTypeC.
                {
                  UCEV()
                }
                Method(_Q79)    // Any event on USBTypeC.
                {
                  UCEV()
                }
              // Display Hotkey Control Function
              //    Handle display hotkey control functions, such as display switch, display brightness increase/decrease
              //
              //  Arguments:
              //    Arg0: Function Number
              //            1 = Display Switch
              //            2 = Display Brightness Increase
              //            3 = Display Brightness Decrease
              //            4+ = Reserved
              //
              //    Arg1: Sub Function Number
              //            if Arg0 == 1, then
              //              x = Display Switch Table Index x ( 0<= x <= 3)
              //
              //  Return Value:
              //    None
              
                Method(DHCF, 2, Serialized)
                {
                  Switch(ToInteger(Arg0))
                  {
                    Case(1) // GMCH SCI hotkey display switch, table index x
                    {
                      If (LAnd(IGDS, LLess(Arg1, 4)))
                      {
                        \_SB.PC00.GFX0.GHDS(Arg1)
                      }
                    }
                    Case(2) // Brightness Increase.
                    {
                      If (CondRefOf(HBRT)) // Send backlight notifications to the DGPU LFP device.
                      {
                        HBRT(3)
                      }
                      If (And(4,DSEN))
                      {
                        //BRTN(0x86)
                      } Else {
                        // Current brightness is a percentage number. This must be done if ALS is enabled,
                        // as the driver will change the brightness based on ambient light.
                        Store(\_SB.PC00.GFX0.CBLV, Local0)
              
                        // 1 % will be lost in the conversion, so need to make it up first.
                        AND(Add(Local0, 1),0xFE, Local0)
              
                        If (LLessEqual(Local0, 90))
                        {
                          Add(Local0, 10, Local0)
                        }
                        Store(Local0, BRTL)
                        \_SB.PC00.GFX0.AINT(1, Local0)
                      }
                    }
                    Case(3) // Brightness Decrease.
                    {
                      If (CondRefOf(HBRT)) // Send backlight notifications to the DGPU LFP device.
                      {
                        HBRT(4)
                      }
                      If (And(4,DSEN))
                      {
                        //BRTN(0x87)
                      } Else {
                        // Current brightness is a percentage number. This must be done if ALS is enabled,
                        // as the driver will change the brightness based on ambient light.
                        Store(\_SB.PC00.GFX0.CBLV, Local0)
              
                        // 1 % will be lost in the conversion, so need to make it up first.
                        AND(Add(Local0, 1),0xFE, Local0)
              
                        If (LGreaterEqual(Local0, 10))
                        {
                          Subtract(Local0, 10, Local0)
                        }
                        Store(Local0, BRTL)
                        \_SB.PC00.GFX0.AINT(1, Local0)
                      }
                    }
                  }
                }
              
                Method(_Q52)    // Hot-Key Event.
                {
                  //Return if PS2 Keyboard and Mouse disabled
                  If (LEqual(P2MK,0))
                  {
                    Return
                  }
              
                  // This event will be generated whenever a
                  // FN+"Next Key" is hit.  This event handler
                  // will base code execution on the "Next Key" Scan Code
                  // stored in the EC Memory Space.
              
                  Store(ECRD(RefOf(SCAN)),Local0)
              
              
                  // Fn + F1 - F8 & F12, EC would send the Scan code to OS directly
                  // Function key | OS behavior           | EC behavior
                  // -------------+-----------------------+---------------------------------------------------------------------
                  // F1           | Mute                  | Send scan code to OS directly (press: 0xE0 0x20, release: 0xE0 0xA0)
                  // F2           | Volume down           | Send scan code to OS directly (press: 0xE0 0x2E, release: 0xE0 0xAE)
                  // F3           | Volume up             | Send scan code to OS directly (press: 0xE0 0x30, release: 0xE0 0xB0)
                  // F4           | Play/Pause            | Send scan code to OS directly (press: 0xE0 0x22, release: 0xE0 0xA2)
                  // F5           | Insert                | Send scan code to OS directly (press: 0xE0 0x52, release: 0xE0 0xD2)
                  // F6           | Print Screen          | Send scan code to OS directly (press: 0xE0 0x37, release: 0xE0 0xB7)
                  // F7           | Blank                 | Nothing
                  // F8           | NumLock               | Send scan code to OS directly (press: 0x45, release: 0xC5)
                  // F9           | Display brightness -  | Send SCI: Q52 with scan code 0x43
                  // F10          | Display brightness +  | Send SCI: Q52 with scan code 0x44
                  // F11          | Airplane mode         | Send SCI: Q52 with scan code 0x45
                  // F12          | Scroll lock           | Send scan code to OS directly (press: 0x46, release: 0xC6)
              
                  // F9 Scan Code = 0x43
                  If (LEqual(Local0,0x43))
                  {
                    DHCF(3, 0)
                  }
              
                  // F10 Scan Code = 0x44
                  ElseIf (LEqual(Local0,0x44))
                  {
                    DHCF(2, 0)
                  }
              
                  // F11 Scan Code = 0x45
                  ElseIf (LEqual(Local0,0x45))
                  {
                    \_SB.HIDD.HPEM(8)         // HID Event Index 8: Airplane Mode/Wireless Radio Button
                  }
                } // end Method(_Q52) Fn hot key event
              
                Method(_Q54)    // Power Button Event for Control method Power Button(10sec PB Override without V-GPIO driver)
                {
                  If (LEqual(S0ID,0)) {  // if Connected Standby is not supported
              
                    //
                    // Check UAMS(User Absent Mode State) to notify the power button event.
                    //
                    If (UAMS){ // UAMS has a non-Zero value, means the system is under User Absent Mode. Send Wake up event.
                      If (CondRefOf(\_SB.PWRB)){
                        Notify(\_SB.PWRB, 0x02)
                      }
                    } Else { // UAMS is Zero, means the system is ON. Send Sleep event.
                      If (CondRefOf(\_SB.PWRB)){
                        Notify(\_SB.PWRB, 0x80)
                      }
                    }
                  }
                } // end Method(_Q54) Power button event.
              
                Name(ABCD,0) // used as counter by hotkeys
              
                Method(_Q56)    // Hot-Key Event.
                {
                  //Return if PS2 Keyboard and Mouse disabled
                  If (LEqual(P2MK,0))
                  {
                    Return
                  }
              
                  Store(ECRD(RefOf(SCCK)),Local0)
              
                  // This event will be generated whenever a
                  // CRTL+ALT+SHIFT+"Next Key" is hit.  This event handler
                  // will base code execution on the "Next Key" Scan Code
                  // stored in the EC Memory Space.
              
                  // "BKSP" Scan Code = 0x0E
                  If (LEqual(Local0,0x0E))
                  {
                    \_SB.HIDD.HPEM(14)        // HID Event Index 14: Stop.
                  }
              
                  // "Tab" Scan Code = 0x0F
                  If (LEqual(Local0,0x0F))
                  {
                    \_SB.HIDD.HPEM(15)        // HID Event Index 15: Play/Pause.
                  }
              
                  // "Q" Scan Code = 0x10
                  If (LEqual(Local0,0x10))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(1)         // HID Event Index 1: Windows Button (Keyboard Left GUI).
                  }
              
                  // "W" Scan Code = 0x11
                  ElseIf (LEqual(Local0,0x11))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(2)         // HID Event Index 2: Rotation Lock
                  }
              
                  // "E" Scan Code = 0x12
                  ElseIf (LEqual(Local0,0x12))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(3)         // HID Event Index 3: Num Lock
                  }
              
                  // "R" Scan Code = 0x13
                  ElseIf (LEqual(Local0,0x13))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(4)         // HID Event Index 4: Home
                  }
              
                  // "T" Scan Code = 0x14
                  ElseIf (LEqual(Local0,0x14))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(5)         // HID Event Index 5: End
                  }
              
                  // "Y" Scan Code = 0x15
                  ElseIf (LEqual(Local0,0x15))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(6)         // HID Event Index 6: Page Up
                  }
              
                  // "U" Scan Code = 0x16
                  ElseIf (LEqual(Local0,0x16))
                  {
                    Sleep(1000)               // Index 1-7 are Keyboard/Keypad HIDs.  Add delay.
                    \_SB.HIDD.HPEM(7)         // HID Event Index 7: Page Down
                  }
              
                  // "I" Scan Code = 0x17
                  ElseIf (LEqual(Local0,0x17))
                  {
                    \_SB.HIDD.HPEM(8)         // HID Event Index 8: Wireless Radio Button
                  }
              
                  // "O" Scan Code = 0x18
                  ElseIf (LEqual(Local0,0x18))
                  {
                    \_SB.HIDD.HPEM(9)         // HID Event Index 9: System Power Down
                  }
              
                  // HK: "P" Scan Code = 0x19
                  ElseIf (LEqual(Local0,0x19))   // CTDP Up
                  {
                    If (LAnd(CondRefOf(\_SB.PC00.CTCU),LEqual(CTDB,1))){ // only allow this feature if it is enabled in SETUP
                      \_SB.PC00.CTCU()
                    }
                  }
              
                  // HK: "[" Scan Code = 0x1A
                  ElseIf (LEqual(Local0,0x1A))   // CTDP Nominal
                  {
                    If (LAnd(CondRefOf(\_SB.PC00.CTCN),LEqual(CTDB,1))){ // only allow this feature if it is enabled in SETUP
                      \_SB.PC00.CTCN()
                    }
                  }
              
                  // HK: "]" Scan Code = 0x1B
                  ElseIf (LEqual(Local0,0x1B))   // CTDP Down
                  {
                    If (LAnd(CondRefOf(\_SB.PC00.CTCD),LEqual(CTDB,1))){ // only allow this feature if it is enabled in SETUP
                      \_SB.PC00.CTCD()
                    }
                  }
              
                  // Calculator (Enter) Key = 0x1C
                  ElseIf (LEqual(Local0,0x1C))
                  {
                    \_SB.HIDD.HPEM(27)         // HID Event Index 27: System Wake
                  }
              
                  // "A" Scan Code = 0x1E
                  If (LEqual(Local0,0x1E))
                  {
                    \_SB.HIDD.HPEM(16)        // HID Event Index 16: Mute.
                  }
              
                  // "G" Scan Code = 0x22
                  ElseIf (LEqual(Local0,0x22))
                  {
                    // Virtual Button Event - Ctrl + Alt + Del Screen
              
                    Sleep(1000) // 1sec delay is needed for Powerbutton and Windows Home button
              
                    If (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                      // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                      \_SB.PC00.GFX0.IUEH(0)
                    }
                  }
              
                  // "H" Scan Code = 0x23
                  ElseIf (LEqual(Local0,0x23))
                  {
                    // Virtual Button Event - Windows Button
                    Sleep(1000)
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Windows Home
                      Notify(\_SB.HIDD,0xC2) // Notify HID driver that Windows Home button is pressed.
                      Notify(\_SB.HIDD,0xC3) // Notify HID driver that Windows Home button is released.
                    } ElseIf (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                      // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                      \_SB.PC00.GFX0.IUEH(1)
                    }
                  }
              
                  // "J" Scan Code = 0x24
                  ElseIf (LEqual(Local0,0x24))
                  {
                    // Virtual Button Event - Volume Up
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Volume UP Press
                      Notify(\_SB.HIDD,0xC4) // Notify HID driver that Volume UP button is pressed.
                      Notify(\_SB.HIDD,0xC5) // Notify HID driver that Volume UP button is released.
                    } ElseIf (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                      // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                      \_SB.PC00.GFX0.IUEH(2)
                    }
                  }
              
                  // "K" Scan Code = 0x25
                  ElseIf (LEqual(Local0,0x25))
                  {
                    // Virtual Button Event - Volume Down
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Volume Down Press
                      Notify(\_SB.HIDD,0xC6) // Notify HID driver that Volume Down button is pressed.
                      Notify(\_SB.HIDD,0xC7) // Notify HID driver that Volume Down button is released.
                    } ElseIf (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                      // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                      \_SB.PC00.GFX0.IUEH(3)
                    }
                  }
              
                  // "L" Scan Code = 0x26
                  ElseIf (LEqual(Local0,0x26))
                  {
                    // Virtual Button Event - Rotation Lock
                    Sleep(1000)
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: RotationLock Press
                      Notify(\_SB.HIDD,0xC8) // Notify HID driver that Rotation Lock button is pressed.
                      Notify(\_SB.HIDD,0xC9) // Notify HID driver that Rotation Lock button is released.
                    } ElseIf (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                      // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                      \_SB.PC00.GFX0.IUEH(4)
                    }
                  }
              
                  // ";" Scan Code = 0x27
                  ElseIf (LEqual(Local0,0x27))
                  {
                    // Virtual Button Event - Convertible Indicator Toggle
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
                      Xor(PB1E, 0x08, PB1E) // Toggle Slate/Laptop Lock Status
                      If (And(PB1E, 0x08)) // Follower/Laptop Mode changed 0 -> 1 Laptop mode
                      {
                        UPBT(6, One)
                        Notify(\_SB.HIDD, 0xCD) // Notify HID Event Filter driver that the system is now in Laptop mode.
                      } Else { // Follower/Laptop Mode Changed 1 -> 0 Slate/Tablet Mode
                        UPBT(6, Zero)
                        Notify(\_SB.HIDD, 0xCC) // Notify HID Event Filter driver that the system is now in Slate/Tablet mode.
                      }
                    } Else {
                      If (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                        // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                        \_SB.PC00.GFX0.IUEH(6)
                      }
                    }
              
                  }
              
                  // "'" Scan Code = 0x28
                  ElseIf (LEqual(Local0,0x28))
                  {
                    // Virtual Button Event - Docking Indicator Toggle
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
                      Xor(PB1E, 0x10, PB1E) // Toggle Dock/Undock Status
                      If (And(PB1E, 0x10)) // Dock/Undock status changed 0 -> 1 Dock mode
                      {
                        UPBT(7, One)
                        Notify(\_SB.HIDD, 0xCA) // Notify HID Event Filter driver that the system is now in Dock mode.
                      } Else { // Dock/Undock status Changed 1 -> 0 Undock mode
                        UPBT(7, Zero)
                        Notify(\_SB.HIDD, 0xCB) // Notify HID Event Filter driver that the system is now in undock mode.
                      }
                    } Else {
                      If (CondRefOf(\_SB.PC00.GFX0.IUEH)) {
                        // Win8 Compatible mode.  Graphics driver takes care of the hot key.
                        \_SB.PC00.GFX0.IUEH(7)
                      }
                    }
              
                  }
              
                  // F1 Scan Code = 0x3B
                  ElseIf (LEqual(Local0,0x3B))
                  {
                    DHCF(1, 0)              // IGfx Display Switch using Toggle List 1.
                  }
              
                  // F2 Scan Code = 0x3C
                  ElseIf (LEqual(Local0,0x3C))
                  {
                    DHCF(1, 1)              // IGfx Display Switch using Toggle List 2.
                  }
              
                  // F3 Scan Code = 0x3D
                  ElseIf (LEqual(Local0,0x3D))
                  {
                    DHCF(1, 2)              // IGfx Display Switch using Toggle List 3
                  }
              
                  // F4 Scan Code = 0x3E
                  ElseIf (LEqual(Local0,0x3E))
                  {
                    DHCF( 1, 3)             // IGfx Display Switch using Toggle List 4
                  }
              
                  // F8 Scan Code = 0x42
                  ElseIf (LEqual(Local0,0x42))
                  {
                    // Panel Fitting Hot Key.
                    If (IGDS)
                    {
                      If (CondRefOf(HPFS))
                      {
                        HPFS()
                      } Else {
                        \_SB.PC00.GFX0.AINT(2, 0)
                      }
                    }
                  }
              
                  // F9 Scan Code = 0x43
                  ElseIf (LEqual(Local0,0x43))
                  {
                    DHCF(3, 0)              // Decrease Brightness Level.
                  }
              
                  // F10 Scan Code = 0x44
                  ElseIf (LEqual(Local0,0x44))
                  {
                    DHCF(2, 0)              // Increase Brightness Level.
                  }
              
                  // F12 Scan Code = 0x58
                  ElseIf (LEqual(Local0,0x58))
                  {
                    \_SB.HIDD.HPEM(11)      // HID Event Index 11: System Sleep
                  }
              
                  // Home Scan Code = 0x47
                  // Don't use: SDS shares this key with Left Arrow key and should not be used for Hotkey.
              
                  // UpArw Scan Code = 0x48
                  ElseIf (LEqual(Local0,0x48))
                  {
                    \_SB.HIDD.HPEM(17)         // HID Event Index 17: Volume Increment
                  }
              
                  // PgUp Scan Code = 0x49
                  // Don't use: SDS shares this key with Up Arrow key and should not be used for Hotkey.
              
                  // LftArw Scan Code = 0x4B
                  ElseIf (LEqual(Local0,0x4B))
                  {
                    \_SB.HIDD.HPEM(20)         // HID Event Index 20: Display Brightness Decrement
                  }
              
                  // RtArw Scan Code = 0x4D
                  ElseIf (LEqual(Local0,0x4D))
                  {
                    \_SB.HIDD.HPEM(19)         // HID Event Index 19: Display Brightness Increment
                  }
              
                  // End Scan Code = 0x4F
                  // Don't use: SDS shares this key with Right Arrow key and should not be used for Hotkey.
              
                  // DwnArw Scan Code = 0x50
                  ElseIf (LEqual(Local0,0x50))
                  {
                    \_SB.HIDD.HPEM(18)         // HID Event Index 18: Volume Decrement
                  }
              
                  // PgDn Scan Code = 0x51
                  // Don't use: SDS shares this key with Down Arrow key and should not be used for Hotkey.
              
                  // Ins Scan Code = 0x52
                  ElseIf (LEqual(Local0,0x52))
                  {
                    \_SB.HIDD.HPEM(13)         // HID Event Index 13: Scan Prev Track
                  }
              
                  // Del Scan Code = 0x53
                  ElseIf (LEqual(Local0,0x53))
                  {
                    \_SB.HIDD.HPEM(12)        // HID Event Index 12: Scan Next Track
                  }
                } // end Method(_Q56) CAS hot key event
              
                Method(_QD5)    // 10 second power button press.
                {
                  \_SB.PWPR()
                }
              
                Method(_QD6)    // 10 second power button de-press.
                {
                  \_SB.PWRR()
                }
              
                Method(_Q80)    // Volume Up
                {
                  If(LEqual(\VBVP,1))
                  {
                    // Volume Up.
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
                    // Else If HID Event Driver loaded
                    //   use HID Event Driver
                    // Else
                    //   use GFX Driver.
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Volume UP
                      Notify(\_SB.HIDD,0xC4) // Notify HID driver that Volume UP button is pressed.
                    } Else {
                      If (LEqual(\_SB.HIDD.HRDY, 1)){
                        \_SB.HIDD.HPEM(17)
                      } Else {
                        \_SB.PC00.GFX0.IUEH(2)
                      }// End of If (LEqual(\_SB.HIDD.HRDY, 1))
                    }
                  }
                }
              
                Method(_Q81)    // Volume Down
                {
                  If(LEqual(\VBVD,1))
                  {
                    // Volume Down.
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
                    // Else If HID Event Driver loaded
                    //   use HID Event Driver
                    // Else
                    //   use GFX Driver.
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Volume Down
                      Notify(\_SB.HIDD,0xC6) // Notify HID driver that Volume Down button is pressed.
                    } Else {
                      If (LEqual(\_SB.HIDD.HRDY, 1)){
                        \_SB.HIDD.HPEM(18)
                      } Else {
                        \_SB.PC00.GFX0.IUEH(3)
                      }
                    }
                  }
                }
              
              Method(_Q82)    // Tablet Switch Toggle Slate/Tablet mode
              {
              
                If (LEqual(\SMSS,1)) // SDS, PantherMtn, GrizzlyMtn or StarBrook
                {
                  // Rotation Lock button
                  // If VirtualButton driver loaded
                  //   use VirtualButton driver
                  // Else
                  //   use GFX Driver.
                  ADBG("Toggle Tablet mode ")
              
                  If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
                    Or(PB1E, 0x08, PB1E) // Toggle Slate Status
                    UPBT(6, Zero)
                    ADBG("Notify 0xCC")
                    Notify(\_SB.HIDD, 0xCC) // Notify HID Event Filter driver that the system is now in Slate/Tablet mode.
                  } Else {
                    \_SB.PC00.GFX0.IUEH(6) // Convertible Indicator lock
                  }
                }
              
              }
              
              Method(_Q83)    // Tablet Switch Toggle Laptop/Normal mode
              {
              
                If (LEqual(\SMSS,1)) // SDS, PantherMtn, GrizzlyMtn or StarBrook
                {
                  // Rotation Lock button
                  // If VirtualButton driver loaded
                  //   use VirtualButton driver
                  // Else
                  //   use GFX Driver.
                  ADBG("Toggle Laptop mode")
              
                  If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
                    Or(PB1E, 0x08, PB1E) // Set Laptop status
                    UPBT(6, One)
                    ADBG("Notify 0xCD")
                    Notify(\_SB.HIDD, 0xCD) // Notify HID Event Filter driver that the system is now in Laptop mode.
                  } Else {
                    \_SB.PC00.GFX0.IUEH(6) // Convertible Indicator lock
                  }
                }
              
              }
              
                Method(_Q85)    // Windows Home button
                {
                  If(LEqual(\VBHB,1))
                  {
                    // Windows Home Button
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
                    // Else If HID Event Driver loaded
                    //   use HID Event Driver
                    // Else
                    //   use GFX Driver.
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Windows Home Press
                      Notify(\_SB.HIDD,0xC2) // Notify HID driver that Windows Home button is pressed.
                    } Else {
                      If (LEqual(\_SB.HIDD.HRDY, 1)){
                        \_SB.HIDD.HPEM(1)
                      } Else {
                        \_SB.PC00.GFX0.IUEH(1)
                      }
                    }
                  }
                }
              
                Method(_Q86)    // Rotation Lock press event
                {
                  If(LEqual(\VBRL,1))
                  {
                    // Rotation Lock button
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
                    // Else If HID Event Driver loaded
                    //   use HID Event Driver
                    // Else
                    //   use GFX Driver.
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: RotationLock Press
                      Notify(\_SB.HIDD,0xC8) // Notify HID driver that Rotation Lock button is pressed.
                    } Else {
                      If (LEqual(\_SB.HIDD.HRDY, 1)){
                        \_SB.HIDD.HPEM(2)
                      } Else {
                        \_SB.PC00.GFX0.IUEH(4)
                      }
                    }
                  }
                }
              
                Method(_Q87)    // Mode Switch: Clam Shell (Laptop) mode and Slate mode switch
                {
                  If (LEqual(\SMSS,1)) // SDS, PantherMtn, GrizzlyMtn or StarBrook
                  {
                    // Rotation Lock button
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
                    // Else
                    //   use GFX Driver.
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded. For HID event filter driver
                      Xor(PB1E, 0x08, PB1E) // Toggle Slate/Laptop Lock Status
                      If (And(PB1E, 0x08)) // Follower/Laptop Mode changed 0 -> 1 Laptop mode
                      {
                        UPBT(6, One)
                        Notify(\_SB.HIDD, 0xCD) // Notify HID Event Filter driver that the system is now in Laptop mode.
                      } Else { // Follower/Laptop Mode Changed 1 -> 0 Slate/Tablet Mode
                        UPBT(6, Zero)
                        Notify(\_SB.HIDD, 0xCC) // Notify HID Event Filter driver that the system is now in Slate/Tablet mode.
                      }
                    } Else {
                      \_SB.PC00.GFX0.IUEH(6) // Convertible Indicator lock
                    }
                  }
              
                }
              
                Method(_Q88)    // Volume Up release event
                {
                  If(LEqual(\VBVP,1))
                  {
                    // Volume Up button release event.
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Volume UP Release
                      Notify(\_SB.HIDD,0xC5) // Notify HID driver that Volume UP button is released.
                    }
                  }
                }
              
                Method(_Q89)    // Volume Down release event
                {
                  If(LEqual(\VBVD,1))
                  {
                    // Volume Down button release event.
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Volume Down Release
                      Notify(\_SB.HIDD,0xC7) // Notify HID driver that Volume UP button is released.
                    }
                  }
                }
              
                Method(_Q8A)    // Windows Home button release event
                {
                  If(LEqual(\VBHB,1))
                  {
                    // Windows Home Button release event
                    // If VirtualButton driver loaded
                    //   use VirtualButton driver
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Windows Home Button Release
                      Notify(\_SB.HIDD,0xC3) // Notify HID driver that Windows Home button is released.
                    }
                  }
                }
              
                Method(_Q8B)    // Rotation Lock release event
                {
                  If (LEqual(\VBRL,1)) {
                    // Windows Rotation Lock release event
              
                    If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Rotation Lock Release
                      Notify(\_SB.HIDD,0xC9) // Notify HID driver that Windows Home button is released.
                    }
                  }
                }
              
                Method(_QF0)    // Thermal Event.
                {
                  Notify(\_TZ.TZ00,0x80)
                }
              
                //
                // Subfunctions for VB driver and HID Event Filter driver. Those were all defined under VGBI before but
                // due to HID Event Filter driver integration effort, they are relocated under EC device so that both VGBI and HIDD
                // can use those methods.
                // Relocated methods: VGBS, UPBT
                // Removed method: PBIN (no longer used)
                //
                Name(VBDS,0)
                Name(ONTM,0) // Temporary variable to initialise VBDS only once in the boot
                Method(VGBS,0,Serialized)  // Virtual GPIO Button Status - Refer Bios Arch Spec
                {
                  // Bit[7] : Docking Indicatory Status
                  // Bit[6] : Convertible/Slate Indicator Status
                  // Bit[5] : Reserved
                  // Bit[4] : Rotation Lock Button Status
                  // Bit[3] : Volume Down Button Status
                  // Bit[2] : Volume Up Button Status
                  // Bit[1] : Windows Home Button Status
                  // Bit[0] : Power Button Status
              
                  If (LEqual(ONTM,0))
                  {
                    // Initial setup option on VBDS and thereafter hotkeys should be updating the VBDS
                    If (LEqual(And(PB1E,0x04),0x04)) // Rotation Lock
                    {
                      UPBT(4,One)
                    }
              
                    If (LEqual(And(PB1E,0x08),0x08)) // Slate/Laptop
                    {
                      UPBT(6,One)
                    }
              
                    If (LEqual(And(PB1E,0x10),0x10))  // Undock/Dock
                    {
                      UPBT(7,One)
                    }
                    Store(One,ONTM)
                  }
                  Return(VBDS)
                }// End of Method
              
                //
                // UPBT Update Button Status
                //
                // Arg0: Bit location of the target button
                //       0: Power Button
                //       1: Windows Button
                //       2: Volume up Button
                //       3: Volume down Button
                //       4: Rotation Lock Button
                //       5: Reserved
                //       6: Convertible state 0 - Slate, 1 - Notebook
                //       7: Dock Indicator 0 - Undock, 1 - Dock
                //
                // Arg1: On/Off state, 0 - Clear the target bit, 1 - Set the target bit.
                //
                Method(UPBT,2,Serialized)  // Update Button Status
                {
                  ShiftLeft(One, Arg0, Local0)
                  If (Arg1){                // Button Press/ON
                    Or(VBDS, Local0, VBDS)
                  } Else {                 // Button Press/OFF
                    And(VBDS, Not(Local0),VBDS)
                  }
                } // End of UPBT
              
              Device(WDT0)  // WDT Device Resource Consumption
              {
                Name(_HID,EISAID("PNP0C02"))
              
                Name(_UID,3)
              
                Name(_CRS,ResourceTemplate()
                {
                  IO(Decode16,0x6A4,0x6A4,0x1,0x1)  // 1 Byte EC Prv Intfc.
                  IO(Decode16,0x6A0,0x6A0,0x1,0x1)  // 1 Byte EC Prv Intfc.
                })
              }
              
              /************************************************************************;
              ;*
              ;* Name:  CHDK
              ;*
              ;* Description: Check DOCK status, returen True if Dock status equal Arg0
              ;*
              ;************************************************************************/
              
                Method(CHDK, 1)
                {
                  // If not Mobile Platform then skip the code and return 0
                  If (LEqual(ECON,1)){
              //@todo: Waiting for DOCK offect data
              //      If (LEqual(ECRD(RefOf(DOCK)), Arg0))
                    If (LEqual(0, Arg0))
                      { // If not docked then it's hot plug
                        Return(1)
                      }
                  }
                  Return(0)
                }
              
                //
                // Hardware Button Array support
                //
              
                Device(BIND)  // Button Indicators.
                {
                   Name(_HID, "INT33D2")
                   Name(_CID, "PNP0C40")
              
                   Method(_STA, 0,Serialized)
                   {
                     If (LAnd(And(IUBE,1), LGreaterEqual(OSYS, 2013)))
                     {
                       If (And(PB1E, 1)) // 10Sec Power Button is enabled?
                       {
                         Return(0x000B) // Not visible in UI
                       }
                       Else
                       {
                         Return(0x000F)
                       }
                     }
                     Return(0x00)
                   }
                   //
                   // _DSM : Device Specific Method for the Windows Compatible Button Array.
                   //
                   // Arg0: UUID Unique function identifier
                   // Arg1: Integer Revision Level
                   // Arg2: Integer Function Index
                   // Arg3: Package Parameters
                   //
                   Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj})
                   {
                     // Compare passed in UUID to supported UUID.
              
                     If (LEqual(Arg0, ToUUID ("DFBCF3C5-E7A5-44E6-9C1F-29C76F6E059C")))
                     {
                       If (LEqual(0,ToInteger(Arg1)))        // Revision 0.
                       {
                         Switch (ToInteger(Arg2))            // Switch to Function Index.
                         {
                           //
                           // Function 0, Query of supported functions.
                           //
              
                           Case (0)
                           {
                             Return (Buffer() {0x03})
                           }
              
                           //
                           // Function 1, Windows Compatible Button Array Power Button Properties.
                           //
              
                           Case (1)
                           {
                             // Only return support if platform enabled via setup.
              
                             If (LEqual(And(PB1E, 1), 1))
                             {
                               Return (0x07)
                             }
              
                             Return(0x00)
              
                           }
                         } // End Switch statement
                       }  // End Revision check
                     }  // End UUID check
              
                     // If the code falls through to this point, just return a buffer of 0.
              
                     Return (Buffer() {0x00})
              
                  }  // End _DSM Method
                }
              
                Device(CIND)  // Convertible Indicators.
                {
                   Name(_HID, "INT33D3")
                   Name(_CID, "PNP0C60")
              
                   Method(_STA, 0,Serialized)
                   {
                     If (LAnd(And(IUCE,1), LGreaterEqual(OSYS, 2012)))
                     {
                       Return(0x000F)
                     }
                     Return(0x00)
                   }
                }
              
                Device(DIND)  // Docking Indicators.
                {
                   Name(_HID, "INT33D4")
                   Name(_CID, "PNP0C70")
                   Method(_STA, 0,Serialized)
                   {
                     If (LAnd(And(IUDE,1), LGreaterEqual(OSYS, 2012)))
                     {
                       Return(0x000F)
                     }
                     Return(0x00)
                   }
                }
              
                // Define a Lid Switch.
                Device(LID0)
                {
                  Name(_HID,EISAID("PNP0C0D"))
                  Method(_STA)
                  {
                    If (LEqual(PFLV,0x1)){
                      Return(0x0F)
                    }
                    Return(0x00)
                  }
                  Method(_LID,0)
                  {
                    // 0 = Closed, 1 = Open.
                    Return(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.LSTE)))
                  }
                }
              } // End H_EC
              
                // System Bus
              
              Scope(\_SB)
              {
              
                // Define an AC Device for ULT, ULX and Halo Platforms.
              
                Device(ADP1)
                {
                  Name(_HID,"ACPI0003")
              
                  Method(_STA)
                  {
                    If(LEqual(\ADAS,0)){
                      Return(0x00)
                    }
                    If (LEqual(ECON,1)){
                      Return(0x0F)
                    }
                    Return(0x00)
                  }
              
                  // Return the value that determines if running
                  // from AC or not.
              
                  Method(_PSR,0)
                  {
                    Return(PWRS)
                  }
              
                  // Return that everything runs off of AC.
              
                  Method(_PCL,0)
                  {
                    Return (
                      Package() { _SB }
                    )
                  }
                }
              
                // Define a (Control Method) Power Button.
              
                Device(PWRB)
                {
                  Name(_HID,EISAID("PNP0C0C"))
              
                  // The PRW isn't working when
                  // placed in any of the logical locations ( PS2K, PS2M,
                  // H_EC ), so a Power Button Device was created specifically
                  // for the WAKETIME_SCI PRW.
              
                  //
                  // Power button status flag used to communicate H_EC.VBDL
                  //
                  Name(PBST, 1)
              
                  //
                  // Up Press Register flag. Set when OS register to recieve the up press of the power button
                  //
                  Name(UPPS, 0)
              
                  //
                  // Status of Power Button Level when EC is in mode where SCI is sent for both press and release of power button
                  //
                  Name(PBLV, 0)
              
                  Method(PKG2, 2, Serialized) {
                    Name (PKG, Package(2){0,0})
                    Store(Arg0, Index(PKG,0))
                    Store(Arg1, Index(PKG,1))
                    Return (PKG)
                  }
              
                  Method(_PRW, 0) {
                    Name (GPEB, 0)   // GPE status bit #
              
                    // Get GPIO status bit location from PCH lib
                    If (LNotEqual(\PPBG, 0))
                    {
                      Store(GGPE(\PPBG), GPEB)   // PM_PWRBTN is GPD, Pad 3
                      Return(PKG2(GPEB, 4))
                    }
                    Return(Package(){30,4})       //GPI14 = GPE30 = Waketime SCI for Haswell Traditional boards
                  }
              
                  Method(_STA, 0)
                  {
                    If (LAnd(LEqual(ECON,1), PBST)){
                      Return(0x0F)
                    }
                    Return(0x00)
                  }
              
                  Method(PBUP, 0) {
                    If(UPPS) {
                      Notify(\_SB.PWRB, 0xC0) // Send release notification to Power Button device
                    }
                  }
              
                  //
                  // _DSM : Device Specific Method for the Power Button.
                  //
                  // Arg0: UUID Unique function identifier
                  // Arg1: Integer Revision Level
                  // Arg2: Integer Function Index
                  // Arg3: Package Parameters
                  //
                  Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj}) {
                    // Compare passed in UUID to supported UUID.
                    If (LEqual(Arg0, ToUUID ("9C355BCB-35FA-44f7-8A67-447359C36A03")))
                    {
                      If (LEqual(0,ToInteger(Arg1)))        // Revision 0.
                      {
                        Switch (ToInteger(Arg2)) {           // Switch to Function Index.
                          //
                          // Function 0, Query of supported functions.
                          //
                          Case (0) {
                            // Need check for platfroms that support this
                            Return (Buffer() {0x07}) // Supports Function 1,2.
                          }
              
                          //
                          // Function 1, Register for Power Button Release Notify.
                          //
                          Case (1) {
                            Store(0x1, UPPS) // OS has registered to recieve notify on release of power button
                            //
                            // Place EC into mode where SCI is sent for both press and release of power button
                            //
                            \_SB.PC00.LPCB.H_EC.ECMD(0x74)
                            Return(0x00)
                          }
              
                          //
                          // Function 2, Power Button Level.
                          //
                          Case (2) {
                            If (UPPS) { // If OS has registered to recieve notify on release of power button
                              If (LNot(PBLV)) {
                                return(0x00) // Power button not pressed
                              } else {
                                return(0x01) // Power button pressed
                              }
                            } else {
                              If (\_SB.PC00.LPCB.PRBL) {
                                return(0x00) // Power button not pressed
                              } else {
                                return(0x01) // Power button pressed
                              }
                            }
                          }
                        } // End Switch statement
                      } // End Revision check
                    } // End UUID check
              
                    //
                    // If the code falls through to this point, just return a buffer of 0.
                    //
                    Return (Buffer() {0x00})
                  } // End _DSM Method
              
              
                }//end device PWRB
              
                Method(PWPR, 0, Serialized) // Power Button Press Helper Method
                {
                  If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Power Button Press
                    Notify(\_SB.HIDD,0xCE) // Notify HID driver that Power button is pressed.
                  } Else {
                    If(LEqual(\_SB.PWRB.PBST, 0x1)) { // Using Control Method Power Button
                      Notify(\_SB.PWRB, 0x80) // Send press notification to Power Button device
                      Store(1, \_SB.PWRB.PBLV) // Keep track of Power Button Level
                    }
              
                    If (CondRefOf(\_SB.PC00.GFX0.IUER))
                    {
                      Store(\_SB.PC00.GFX0.IUER, Local0)
                      And(Local0, 0xC0, \_SB.PC00.GFX0.IUER)  // Clear 4:0 button events on entry.
                      Store(\_SB.PC00.GFX0.IUER, Local0)
                      Or(Local0, 0x01, \_SB.PC00.GFX0.IUER)   // Set Power Button Status = pressed.
                    }
              
                  } //If Win10
                } //End Method
              
                Method(PWRR, 0, Serialized) // Power Button Release Helper Method
                {
                  If (LAnd(LGreaterEqual(OSYS, 2015), \_SB.HIDD.BTLD)) { //Win10 and Button Driver loaded: Power Button Release
                    Notify(\_SB.HIDD,0xCF) // Notify HID driver that Power button is released.
                  } Else {
                    If(LEqual(\_SB.PWRB.PBST, 0x1)) { // Using Control Method Power Button
                      \_SB.PWRB.PBUP() // Send release notification to Power Button device if requested
                      Store(0, \_SB.PWRB.PBLV) //// Keep track of Power Button Level
                    }
              
                    If (CondRefOf(\_SB.PC00.GFX0.IUER))
                    {
                      Store(\_SB.PC00.GFX0.IUER, Local0)
                      And(Local0, 0xC0, \_SB.PC00.GFX0.IUER)  // Clear 4:0 button events on entry.
                    }
              
                  } //If Win10
                } //End Method
              }//end scope _SB

  
        }
  }

  /** @file
    ACPI DSDT table
  
    Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  #line 1 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PlatformBase.h"
/** @file

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/











// FSP will assign temporary resource to serial io devices, align with FSP resource here.


#line 22 "e:\\code\\adl_n100_code\\sblplatform\\SblOpen\\Silicon\\AlderlakePkg\\Include\\PlatformBase.h"
#line 31110 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
  
  
  
  External(\HGMD) //Hybrid graphics
  
  //
  // DTS externals
  //
  External(\_SB.TRPD)
  External(\_SB.TRPF)
  
  //
  // BIOS Guard externals
  //
  External(\_SB.BGMA)
  External(\_SB.BGMS)
  External(\_SB.BGIA)
  //
  // Intel(R) Dynamic Tuning Technology Externals
  //
  External(\_SB.PC00.LPCB.H_EC.CHRG,DeviceObj)
  External(\_SB.IETM, DeviceObj)
  
  External(\_SB.PC00.GFX0.TCHE)   // Technology enabled indicator
  External(\_SB.PC00.GFX0.STAT)   // State Indicator
  External(\_SB.PC00.GFX0.IUEH, MethodObj)
  
  External(\_SB.TPM.PTS, MethodObj)
  External(\_SB.PC00.PAUD.PUAM, MethodObj) //PUAM - PowerResource User Absent Mode
  
  External(\_SB.PC00.LPCB.H_EC.CFAN, FieldUnitObj)
  External(\_SB.PC00.LPCB.H_EC.LSTE, FieldUnitObj)
  External(\_SB.PC00.LPCB.H_EC.VPWR, FieldUnitObj)
  External(\_SB.PC00.LPCB.H_EC.RPWR, FieldUnitObj)
  
  External(\_SB.PC00.LPCB.H_EC.WTMM, FieldUnitObj)
  External(\_SB.PC00.LPCB.H_EC.WTMV, FieldUnitObj)
  
  External(\_SB.PC00.LPCB.H_EC.ECWT, MethodObj)
  External(\_SB.PC00.LPCB.H_EC.ECRD, MethodObj)
  External(\_SB.PC00.LPCB.H_EC.UPBT, MethodObj)
  External(\_SB.PC00.LPCB.H_EC.UTEC, MethodObj)
  External(\_SB.PC00.LPCB.H_EC.ONTM, IntObj)
  External(\_SB.PC00.LPCB.H_EC.BNUM, IntObj)
  External(ISAR, MethodObj, {IntObj, BuffObj}, {BuffObj, IntObj, IntObj, PkgObj})
  
  
  
  
  
  Name(ECUP, 1)  // EC State indicator: 1- Normal Mode 0- Low Power Mode
  Mutex(EHLD, 0) // EC Hold indicator: 0- No one accessing the EC Power State 1- Someone else is accessing the EC Power State
  
  External(TADL)
  External(TADH)
  External(PG3S)
  External(\EPTU, FieldUnitObj)
  
  External(SPTS, MethodObj)
  External(SPNT, MethodObj)
  External(SWAK, MethodObj)
  
  External (\_SB.PC00.TDM0, DeviceObj)
  External (\_SB.PC00.TDM1, DeviceObj)
  External (\_SB.PC00.TDM0.STCM, MethodObj)
  External (\_SB.PC00.TDM1.STCM, MethodObj)
  
  // Create a Global MUTEX.
  Mutex(MUTX, 0)
  // OS Up mutex
  Mutex(OSUM, 0)
  // _WAK Finished Event
  Event(WFEV)
  
  // Define Port 80 as an ACPI Operating Region to use for debugging.  Please
  // note that the Intel CRBs have the ability to ouput a Word to
  // Port 80h for debugging purposes, so the model implemented here may not be
  // able to be used on OEM Designs.
  
  OperationRegion(PRT0,SystemIO,0x80,2)
  Field(PRT0,WordAcc,Lock,Preserve)
  {
    P80B, 16
  }
  
  // Port 80h Update:
  //    Update 2 bytes of Port 80h.
  //
  //  Arguments:
  //    Arg0: 0 = Write Port 80h
  //          1 = Write Port 81h
  //    Arg1: 8-bit Value to write
  //
  //  Return Value:
  //    None
  
  Name(P80T, 0) // temp buffer for P80
  
  Method(D8XH,2,Serialized)
  {
    If(LEqual(Arg0,0))    // Write Port 80h
    {
      Store(Or(And(P80T,0xFF00),Arg1),P80T)
    }
    If(LEqual(Arg0,1))    // Write Port 81h
    {
      Store(Or(And(P80T,0x00FF),ShiftLeft(Arg1,8)),P80T)
    }
    Store(P80T,P80B)
  }
  
  //
  // Wrapper of D8XH, enabled only when ACPI debug enabled
  //
  Method(P8XH,2,Serialized)
  {
    If(CondRefOf(MDBG)) { // Check if ACPI Debug SSDT is loaded
      D8XH(Arg0,Arg1)
    }
  }
  
  
  //
  // Define SW SMI port as an ACPI Operating Region to use for generate SW SMI.
  //
  OperationRegion(SPRT,SystemIO, 0xB2,2)
  Field (SPRT, ByteAcc, Lock, Preserve) {
    SSMP, 8
  }
  
  // Operational region for ACPI Control (SMI_EN) access
  //
  OperationRegion (SMIN, SystemIO, (0x1800 + 0x30), 0x4)
  Field (SMIN, AnyAcc, NoLock, Preserve)
  {
    SMIE, 32
  }
  
  // The _PIC Control Method is optional for ACPI design.  It allows the
  // OS to inform the ASL code which interrupt controller is being used,
  // the 8259 or APIC.  The reference code in this document will address
  // PCI IRQ Routing and resource allocation for both cases.
  //
  // The values passed into _PIC are:
  //   0 = 8259
  //   1 = IOAPIC
  
  Method(\_PIC,1)
  {
    Store(Arg0,GPIC)
    Store(Arg0,PICM)
  }
  
  // Prepare to Sleep.  The hook is called when the OS is about to
  // enter a sleep state.  The argument passed is the numeric value of
  // the Sx state.
  
  Method(_PTS,1)
  {
    D8XH(0,Arg0)    // Output Sleep State to Port 80h, Byte 0.
    D8XH(1,0)       // output byte 1 = 0, sleep entry
  
  
    // If code is executed, Wake from RI# via Serial Modem will be
    // enabled.  If code is not executed, COM Port Debugging throughout
    // all Sx states will be enabled.
  
    If(LEqual(Arg0,3))
    {
      Store(CPWE, CWEF)  // save GPE0_EN_127_96_CPU_WAKE_EN value to NVS
    }
  
    // If S4 or S5 state and PG3 enabled then sa
    ElseIf(LOr(LEqual(Arg0, 4), LEqual(Arg0, 5)))
    {
      If (LEqual(PG3S, 1)) {
        If (CondRefOf(\_SB.PC00.LPCB.H_EC.UTEC)) {
          //Programming BIOS to send DC timer mode only .Other timer mode will be sent as per future requirements.
          // 1. Program Timer mode to 0x00 : WADT_AC register
          //\_SB.PC00.LPCB.H_EC.UTEC(0x00, \ACWA)
  
          // 2. Program Timer mode to 0x01 : WADT_DC register
          \_SB.PC00.LPCB.H_EC.UTEC(0x01, \DCWA)
  
          // 3. Program Timer mode to 0x10 : WADT_EXP_AC register
          //\_SB.PC00.LPCB.H_EC.UTEC(0x10, \ACET)
  
          // 4. Program Timer mode to 0x11 : WADT_EXP_DC register
          //\_SB.PC00.LPCB.H_EC.UTEC(0x11, \DCET)
        }
      }
    }
  
    // Generate a SW SMI trap to save some NVRAM data back to CMOS.
  
    //  Don't enable IGD OpRegion support yet.
    //  TRAP(1, 81)
    //
    // Call TPM.PTS
    //
    If(CondRefOf(\_SB.TPM.PTS))
    {
      //
      // Call TPM PTS method
      //
      \_SB.TPM.PTS (Arg0)
    }
  
    // Call SOC Prepare to Sleep
    SPTS (Arg0)
  }
  
  // Platform Hook for _BCL method for Igfx.
  // Platform can also add logic here  to create run time creation of package
  // example: return package without 0-10 values when in tablet mode,else return all values 0-100.
  Method(PBCL ,0)
  {
    //
    // List of supported brightness levels in the following sequence.
    // Level when machine has full power.
    // Level when machine is on batteries.
    // Other supported levels.
    //
    Return(Package(){80, 50, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100})
  }
  
  // Wake.  This hook is called when the OS is about to wake from a
  // sleep state.  The argument passed is the numeric value of the
  // sleep state the system is waking from.
  
  Method(_WAK,1,Serialized)
  {
    D8XH(1,0xAB)    // Beginning of _WAK.
  
    ADBG("_WAK")
  
    Name (RPWM, 0) // Root Port Wake Mask
  
    If (LEqual(\DSTS, 0)) { // Undocked
      Store (0, RPWM)
    } Else {
      Store (0x180, RPWM) // Skip RP 7 and 8
    }
  
    // Call SOC Wake
    SWAK (Arg0, RPWM)
  
    If(LEqual(Arg0,3))
    {
      // Turn off the CPU Fan for all OSes if Active Cooling
      // is disabled.
      If(LEqual(0,ACTT))
      {
        If(LEqual(\ECON,1))
        {
          \_SB.PC00.LPCB.H_EC.ECWT(0, RefOf(\_SB.PC00.LPCB.H_EC.CFAN))
        }
      }
    }
  
    If(LOr(LEqual(Arg0,3), LEqual(Arg0,4)))  // If S3 or S4 Resume
    {
  
      //
      // Check to send Convertible/Dock state changes upon resume from Sx.
      //
      If(And(GBSX,0x40))
      {
        \_SB.PC00.GFX0.IUEH(6)
  
        //
        //  Do the same thing for Virtul Button device.
        //  Toggle Bit3 of PB1E(Slate/Notebook status)
        //
        Xor(PB1E, 0x08, PB1E)
  
        //
        // Update button status.
        //
        If (\ECON)
        {
          If(And(PB1E, 0x08)){
            If(CondRefOf(\_SB.PC00.LPCB.H_EC.UPBT))
            {
              \_SB.PC00.LPCB.H_EC.UPBT(6, One)
            }
          }
          Else
          {
            If(CondRefOf(\_SB.PC00.LPCB.H_EC.UPBT))
            {
              \_SB.PC00.LPCB.H_EC.UPBT(6, Zero)
            }
          }
        }
      }
  
      If(And(GBSX,0x80))
      {
        \_SB.PC00.GFX0.IUEH(7)
  
        //
        //  Do the same thing for Virtul Button device.
        //  Toggle Bit4 of PB1E (Dock/Undock status)
        //
        Xor(PB1E, 0x10, PB1E)
  
        //
        // Update button status.
        //
        If (\ECON)
        {
          If(And(PB1E, 0x10))
          {
            If(CondRefOf(\_SB.PC00.LPCB.H_EC.UPBT))
            {
              \_SB.PC00.LPCB.H_EC.UPBT(7, One)
            }
          }
          Else
          {
            If(CondRefOf(\_SB.PC00.LPCB.H_EC.UPBT))
            {
              \_SB.PC00.LPCB.H_EC.UPBT(7, Zero)
            }
          }
        }
      }
  
      //
      // Prevent reinitializing Virtual GPIO Button status
      //
      If (\ECON)
      {
        If(CondRefOf(\_SB.PC00.LPCB.H_EC.ONTM))
        {
          Store(1, \_SB.PC00.LPCB.H_EC.ONTM)
        }
      }
  
      If(LEqual(\ECON,1))
      {
  //@todo: Waiting for DOCK offect data
  //      // Detect the change of Dock state
  //      If(LNotEqual(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.DOCK)), \DSTS))
  //      {
  //        Store(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.DOCK)), \DSTS)
  //        If(LEqual(\DSTS, 1))  // Docked.
  //        {
  //          If(LEqual(Arg0,3))
  //          {
  //            Sleep(1000) // Delay 1 second for hot docking stability
  //            Store(DKSM, \SSMP)
  //            Sleep(1000) // Delay 1 second for hot docking stability
  //          }
  //          Notify(\_SB.PC00.DOCK, 0)
  //        }
  //        Else      // Undocked.
  //        {
  //          Notify(\_SB.PC00.DOCK, 1)
  //        }
  //      }
  
        // Detect the change of Power State.
        If(LEqual(\_SB.PC00.LPCB.H_EC.BNUM,0))
        {
          If(LNotEqual(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.VPWR)),PWRS))
          {
            Store(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.VPWR)),PWRS)
            // Perform needed ACPI Notifications.
            SPNT()
          }
        }
        Else
        {
          If(LNotEqual(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.RPWR)),PWRS))
          {
            Store(\_SB.PC00.LPCB.H_EC.ECRD(RefOf(\_SB.PC00.LPCB.H_EC.RPWR)),PWRS)
            // Perform needed ACPI Notifications.
            SPNT()
          }
        }
      }
    } // If S3 or S4
    If(LEqual(\ECON,1)) {
      If(LOr(LEqual(Arg0,3), LEqual(Arg0,4)))  // If S3 or S4 Resume
      {
        //
        // If Using Control Method Power Button, notify PWRD device with 0x2
        //
  






#line 31509 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      }
    }
  
    Return(Package(){0,0})
  }
  
  // Get Buffer:
  //    This method will take a buffer passed into the method and
  //    create then return a smaller buffer based on the pointer
  //    and size parameters passed in.
  //
  //  Arguments:
  //    Arg0: Pointer to start of new Buffer in passed in Buffer.
  //    Arg1: Size of Buffer to create.
  //    Arg2: Original Buffer
  //
  //  Return Value:
  //    Newly created buffer.
  Method(GETB,3,Serialized)
  {
    Multiply(Arg0,8,Local0)     // Convert Index.
    Multiply(Arg1,8,Local1)     // Convert Size.
    CreateField(Arg2,Local0,Local1,TBF3)  // Create Buffer.
  
    Return(TBF3)        // Return Buffer.
  }
  
  //
  // Memory window to the CTDP registers starting at MCHBAR+5000h.
  //
    OperationRegion (CPWR, SystemMemory, Add(\_SB.PC00.GMHB(),0x5000), 0x1000)
    Field (CPWR, ByteAcc, NoLock, Preserve)
    {
      Offset (0x938), // PACKAGE_POWER_SKU_UNIT (MCHBAR+0x5938)
      PWRU,  4,       // Power Units [3:0] unit value is calculated by 1 W / Power(2,PWR_UNIT). The default value of 0011b corresponds to 1/8 W.
      Offset (0x9A0), // TURBO_POWER_LIMIT1 (MCHBAR+0x59A0)
      PPL1, 15,       // PKG_PWR_LIM_1 [14:0]
      PL1E,1,         // PKG_PWR_LIM1_EN [15]
      CLP1,1,         // Package Clamping Limitation 1
    }
  Name(CLMP, 0) // save the clamp bit
  Name(PLEN,0) // save the power limit enable bit
  Name(PLSV,0x8000) // save value of PL1 upon entering CS
  Name(CSEM, 0) //semaphore to avoid multiple calls to SPL1.  SPL1/RPL1 must always be called in pairs, like push/pop off a stack
  //
  // SPL1 (Set PL1 to 4.5 watts with clamp bit set)
  //   Per Legacy Thermal management CS requirements, we would like to set the PL1 limit when entering CS to 4.5W with clamp bit set via MMIO.
  //   This can be done in the ACPI object which gets called by graphics driver during CS Entry.
  //   Likewise, during CS exit, the BIOS must reset the PL1 value to the previous value prior to CS entry and reset the clamp bit.
  //
  //  Arguments:
  //    None
  //
  //  Return Value:
  //    None
  Method(SPL1,0,Serialized)
  {
      Name(PPUU,0) // units
      If (LEqual(CSEM, 1))
      {
        Return() // we have already been called, must have CS exit before calling again
      }
      Store(1, CSEM) // record first call
  
      Store (PPL1, PLSV) // save PL1 value upon entering CS
      Store (PL1E, PLEN) // save PL1 Enable bit upon entering CS
      Store (CLP1, CLMP) // save PL1 Clamp bit upon entering CS
  
      If (LEqual(PWRU,0)) {  // use PACKAGE_POWER_SKU_UNIT - Power Units[3:0]
        Store(1,PPUU)
      } Else {
        ShiftLeft(Decrement(PWRU),2,PPUU) // get units
      }
  
      Multiply(PLVL,PPUU,Local0)  // convert SETUP value to power units in milli-watts
      Divide(Local0,1000,,Local1) // convert SETUP value to power units in watts
      Store(Local1, PPL1)   // copy value to PL1
      Store(1, PL1E)     // set Enable bit
      Store(1, CLP1)     // set Clamp bit
  }
  //
  // RPL1 (Restore the PL1 register to the values prior to CS entry)
  //
  //  Arguments:
  //    None
  //
  //  Return Value:
  //    None
  Method(RPL1,0,Serialized)
  {
      Store (PLSV, PPL1)  // restore value of PL1 upon exiting CS
      Store(PLEN, PL1E)   // restore the PL1 enable bit
      Store(CLMP, CLP1)   // restore the PL1 Clamp bit
      Store(0, CSEM)      // restore semaphore
  }
  
  Name(UAMS, 0) // User Absent Mode state, Zero - User Present; non-Zero - User not present
  Name(GLCK, 0) // a spin lock to avoid multi execution of GUAM
  // GUAM - Global User Absent Mode
  //    Run when a change to User Absent mode is made,  e.g. screen/display on/off events.
  //    Any device that needs notifications of these events includes its own UAMN Control Method.
  //
  //    Arguments:
  //      Power State:
  //        00h = On
  //        01h = Standby
  //        other value = do nothing & return
  //
  //    Return Value:
  //      None
  //
  Method(GUAM,1,Serialized)
  {
    Switch(ToInteger(Arg0))
    {
      Case(0) // exit CS
      {
        If(LEqual(GLCK, 1)){
          store(0, GLCK)
  
          P8XH(0, 0xE1)
          P8XH(1, 0xAB)
  
          If(PSCP){
            // if P-state Capping s enabled
            If (CondRefOf(\_SB.PR00._PPC))
            {
              Store(Zero, \_SB.CPPC)
              SPNT()
            }
          }
          If(PLCS){
            RPL1() // restore PL1 to pre-CS value upon exiting CS
          }
        } // end GLCK=1
      } // end case(0)
  
      Case(1) // enter CS
      {
        If(LEqual(GLCK, 0)){
          store(1, GLCK)
  
          P8XH(0, 0xE0)
          P8XH(1, 00)
  
          If(PSCP){
            // if P-state Capping is enabled
            If (LAnd(CondRefOf(\_SB.PR00._PSS), CondRefOf(\_SB.PR00._PPC)))
            {
              SPNT()
            }
          }
          If(PLCS){
            SPL1() // set PL1 to low value upon CS entry
          }
        } // end GLCK=0
      } // end case(1)
      Default{
        Return()  // do nothing
      }
    } // end switch(arg0)
  
    Store(LAnd(Arg0, LNot(PWRS)), UAMS)  // UAMS: User Absent Mode state, Zero - User Present; non-Zero - User not present
    P_CS()                               // Powergating during CS
  
  } // end method GUAM()
  
  // Power CS Powergated Devices:
  //    Method to enable/disable power during CS
  Method(P_CS,0,Serialized)
  {
      // NOTE: Do not turn ON Touch devices from here. Touch does not have PUAM
      If(CondRefOf(\_SB.PC00.PAUD.PUAM)){           // Notify Codec(HD-A/ADSP)
          \_SB.PC00.PAUD.PUAM()
      }
  }
  
  // SMI I/O Trap:
  //    Generate a Mutex protected SMI I/O Trap.
  //
  //  Arguments:
  //    Arg0: I/O Trap type.
  //               2 - For DTS
  //               4 - For BIOS Guard Tools
  //    Arg1: SMI I/O Trap Function to call.
  //
  //  Return Value:
  //    SMI I/O Trap Return value.
  //      0 = Success.  Non-zero = Failure.
  Method(TRAP,2,Serialized)
  {
    Store(Arg1,SMIF)        // Store SMI Function.
  
    If(LEqual(Arg0,0x04))  // Is BIOS Guard TOOLS IO Trap?
    {
      Store(0,\_SB.TRPF)         // Generate IO Trap
    }
  
    Return(SMIF)            // Return SMIF.  0 = Success.
  }
  
  // Note:  Only add the indicator device needed by the platform.
  
  //
  // System Bus
  //
  Scope(\_SB.PC00)
  {
  
    Method(PTMA)
    {
      Return(\_SB.BGMA)
    }
  
    Method(PTMS)
    {
      Return(\_SB.BGMS)
    }
  
    Method(PTIA)
    {
      Return(\_SB.BGIA)
    }
  
    Method(_INI,0, Serialized)
    {
      // Determine the OS and store the value, where:
      //
      //   OSYS = 1000 = Operating systems except the following list.
      //   OSYS = 2001 = WINXP, RTM or SP1.
      //   OSYS = 2002 = WINXP SP2.
      //   OSYS = 2006 = Vista.
      //   OSYS = 2009 = Windows 7 and Windows Server 2008 R2.
      //   OSYS = 2012 = Windows 8 and Windows Server 2012.
      //   OSYS = 2013 = Windows Blue.
      //
  
      // Set Default 1000 when OSI method does not find a matching OS.
      Store(1000,OSYS)
  
      // Check for a specific OS which supports _OSI.
  
      If(CondRefOf(\_OSI))
      {
        If(\_OSI("Windows 2001")) // Windows XP
        {
          Store(2001,OSYS)
        }
  
        If(\_OSI("Windows 2001 SP1")) //Windows XP SP1
        {
          Store(2001,OSYS)
        }
  
        If(\_OSI("Windows 2001 SP2")) //Windows XP SP2
        {
          Store(2002,OSYS)
        }
  
        If (\_OSI( "Windows 2001.1"))  //Windows Server 2003
        {
          Store(2003,OSYS)
        }
  
        If(\_OSI("Windows 2006")) //Windows Vista
        {
          Store(2006,OSYS)
        }
  
        If(\_OSI("Windows 2009")) //Windows 7 and Windows Server 2008 R2
        {
          Store(2009,OSYS)
        }
  
        If(\_OSI("Windows 2012")) //Windows 8 and Windows Server 2012
        {
          Store(2012,OSYS)
        }
  
        If(\_OSI("Windows 2013")) //Windows 8.1 and Windows Server 2012 R2
        {
          Store(2013,OSYS)
        }
  
        If(\_OSI("Windows 2015")) //Windows 10
        {
          Store(2015,OSYS)
        }
      }
    }
  }
  
  Scope (\)
  {
    //
    // Global Name, returns current Interrupt controller mode;
    // updated from _PIC control method
    //
    Name(PICM, 0)
  
    //
    // Procedure: GPRW
    //
    // Description: Generic Wake up Control Method ("Big brother")
    //              to detect the Max Sleep State available in ASL Name scope
    //              and Return the Package compatible with _PRW format.
    // Input: Arg0 =  bit offset within GPE register space device event will be triggered to.
    //        Arg1 =  Max Sleep state, device can resume the System from.
    //                If Arg1 = 0, Update Arg1 with Max _Sx state enabled in the System.
    // Output:  _PRW package
    //
    Name(PRWP, Package(){Zero, Zero})   // _PRW Package
  
    Method(GPRW, 2)
    {
      Store(Arg0, Index(PRWP, 0))             // copy GPE#
      //
      // SS1-SS4 - enabled in BIOS Setup Sleep states
      //
      Store(ShiftLeft(SS1,1),Local0)          // S1 ?
      Or(Local0,ShiftLeft(SS2,2),Local0)      // S2 ?
      Or(Local0,ShiftLeft(SS3,3),Local0)      // S3 ?
      Or(Local0,ShiftLeft(SS4,4),Local0)      // S4 ?
      //
      // Local0 has a bit mask of enabled Sx(1 based)
      // bit mask of enabled in BIOS Setup Sleep states(1 based)
      //
      If(And(ShiftLeft(1, Arg1), Local0))
      {
        //
        // Requested wake up value (Arg1) is present in Sx list of available Sleep states
        //
        Store(Arg1, Index(PRWP, 1))           // copy Sx#
      }
      Else
      {
        //
        // Not available -> match Wake up value to the higher Sx state
        //
        ShiftRight(Local0, 1, Local0)
        // If(LOr(LEqual(OSFL, 1), LEqual(OSFL, 2))) {  // ??? Win9x
        // FindSetLeftBit(Local0, Index(PRWP,1))  // Arg1 == Max Sx
        // } Else {           // ??? Win2k / XP
       FindSetLeftBit(Local0, Index(PRWP,1))  // Arg1 == Min Sx
        // }
      }
  
      Return(PRWP)
    }
  }
  
  Scope (\_SB)
  {
    Name (OSU4, 0)     // OS native USB4 support - 0: native USB4 is not supported, 1: native USB4 is supported
    Name (OSCM, 0xFF)  // CM mode applied for OS phase - 0 : FW CM, 1 - SW CM, 0xFF: uninitialied
  
    
  
    If (LEqual (U4SE, 1))
    {
      //
      // Operation region for CMOS access
      //
      OperationRegion (CSIO, SystemIO, 0x72, 2)
      Field (CSIO, ByteAcc, NoLock, Preserve)
      {
        IO72, 8,
        IO73, 8
      }
  
      //
      // Name: WCMP
      // Description: Write CM mode to the platform settings
      // Input: Arg0 - CM mode value
      //
      Method (WCMP, 1, Serialized)
      {
        Store (0xF2, IO72)
        Store (Arg0, IO73)
      }
    }
  
    
    
  
    //
    // Name: DOCM
    // Description: Apply OS requested CM mode to host routers on platform
    // Return : CM applied status (0 = Apply CM mode successfully, 0xFF = CM mode is not applied)
    //
    // Local0 - CM applied status (0 = CM mode is applied to host router, 0xFF = CM mode is not applied to any host router)
    //
    Method (DOCM, 0, Serialized)
    {
  
      If (LEqual (U4SE, 0))
      {
        Return (0xFF)
      }
  
  
      //
      // Initialize CM applied status to 0xFF
      //
      Store (0xFF, Local0)
  
      //
      // If CM mode is not applied to any host router, OSCM is set to FW CM
      //
      Store (0, OSCM)
  
      //
      // Enabled host router mask (Bit 0-3: iTBT0-iTBT3, Bit 4-7: dTBT0-dTBT3)
      //
      ADBG(Concatenate ("DOCM: Enabled host router mask on platform = 0x", ToHexString (CMSK)))
  
      If (Lequal (Local0, 0xFF))
      {
        ADBG("DOCM: CM mode is not applied to any host router, native USB4 capability is not supported")
      }
  
      //
      // Save the latest applied CM mode to the platform settings if OS Dependent option is selected in BIOS setup.
      // U4CM bit 6:4 = CM mode setup option
      // 0 = Firmware CM
      // 1 = Software CM
      // 2 = OS Dependent
      // 3 = CM Debug
      //
      If (LEqual (And (U4CM, 0x70), 0x20))
      {
        \_SB.WCMP (OSCM)
      }
  
      Return (Local0)
    }
  
    //
    // Name: U4FN
    // Description: Handle _OSC USB4 capability of platform-wide UUID
    // Arguments:
    // Arg0 - Status DWORD of _OSC Arg3
    // Arg1 - Capability DWORD of _OSC Arg3
    // Return : USB4 capability support status (0 = Accept _OSC USB4 request, 0xFF = USB4 capability bit should be cleared)
    //
    // Local0 - CM apply status (0 = CM mode is applied to host router, 0xFF = CM mode is not applied to any host router)
    // Local1 - DOCM method returned value
    // Local2 - CM mode setup option
    //
  
    Method (U4FN, 2, Serialized)
    {
      ADBG(Concatenate ("U4FN: _OSC STS = ", ToHexString (Arg0)))
      ADBG(Concatenate ("U4FN: _OSC CAP = ", ToHexString (Arg1)))
  
  
      If (LEqual (U4SE, 0))
      {
        Store (0, OSCM)
  
        //
        // Check OS natvie USB4 capability support
        //
        If (And (Arg1, 0x40000))
        {
          //
          // OS supports native USB4 capability, but platform doesn't support
          // Return 1 to indicate USB4 capability bit should be cleared
          //
          ADBG("U4FN: USB4 capability bit should be cleared since platform doesn't support")
          Return (0xFF)
        }
        Else
        {
          ADBG("U4FN: OS and platform doesn't support native USB4")
          Return (0)
        }
      } Else {
  
        Store (0, Local0)
  
        //
        // Check bit 18 for native USB4 support
        // If bit 18 is set, OS requests to apply SW CM
        // If bit 18 is not set, use FW CM
        // It's possible that bit 18 is set by OS in the beginning, but be cleared in the next call if bit 18 is cleared in _OSC.
        // For example:
        // 1. _OSC bit 18 set, query bit = 0  => OSU4 = 1, but FW CM is selected in BIOS setup, report bit 18 cleared in _OSC
        // 2. _OSC bit 18 cleared, query bit = 1 => OSU4 = 0
        //
        If (And (Arg1, 0x40000)) {
          //
          // OS supports native USB4
          //
          Store (1, OSU4)
        } Else {
          Store (0, OSU4)
        }
  
        //
        // CM mode has been FW CM in pre-boot if Firmware CM mode is selected in BIOS setup
        // CM mode switch will not be required in _OSC
        //
        // U4CM bit 6:4 = CM mode setup option
        // 0 = Firmware CM
        // 1 = Software CM
        // 2 = OS Dependent
        // 3 = CM Debug
        //
        If (LEqual (And (U4CM, 0x70), 0))
        {
          If (LEqual (OSU4, 1))
          {
            ADBG("U4FN: Platform doesn't support SW CM, clear USB4 capability bit")
            Store (0xFF, Local0)
          } Else {
            ADBG("U4FN: OS and platform only support FW CM")
            Store (0, Local0)
          }
  
          //
          // Return without CM mode switch since it's not required
          //
          Return (Local0)
        }
  
        //
        // Apply OS requested CM mode to host routers on platform if query bit is cleared
        //
        If (LEqual (And (Arg0, 0x01), 0))
        {
          Store (DOCM (), Local1)
          //
          // USB4 capability bit should be cleared if the bit is 1 but SW CM mode is not applied to host router successfully
          //
          If (LAnd (Lequal (OSU4, 1), Lequal (Local1, 0xFF)))
          {
            Store (0xFF, Local0)
          }
        } Else {
          //
          // Ideally, OS requested CM mode should be accepted
          // Except OS requests SW CM but no host router is enabled or CM switch failure happens
          //
          //
          // USB4 capability bit should be cleared if the latest applied CM mode for OS is FW CM
          //
          If (LAnd (Lequal (OSU4, 1), Lequal (OSCM, 0)))
          {
            ADBG("U4FN: Native USB4 capability bit should be cleared since FW CM is applied for OS")
            Store (0xFF, Local0)
          }
        }
  
        Return (Local0)
      }
    } // Method (U4FN, 2, Serialized)
  }   // Scope (\_SB)
  
  Scope (\_SB)
  {
    Name(OSCI, 0)  // \_SB._OSC DWORD2 input
    Name(OSCO, 0)  // \_SB._OSC DWORD2 output
    Name(OSCP, 0)  // \_SB._OSC CAPABILITIES
  
    // _OSC (Operating System Capabilities)
    //    _OSC under \_SB scope is used to convey platform wide OSPM capabilities.
    //    For a complete description of _OSC ACPI Control Method, refer to ACPI 5.0
    //    specification, section 6.2.10.
    // Arguments: (4)
    //    Arg0 - A Buffer containing the UUID "0811B06E-4A27-44F9-8D60-3CBBC22E7B48"
    //    Arg1 - An Integer containing the Revision ID of the buffer format
    //    Arg2 - An Integer containing a count of entries in Arg3
    //    Arg3 - A Buffer containing a list of DWORD capabilities
    // Return Value:
    //    A Buffer containing the list of capabilities
    //
    Method(_OSC,4,Serialized)
    {
      ADBG("_OSC")
  
      //
      // Point to Status DWORD in the Arg3 buffer (STATUS)
      //
      CreateDWordField(Arg3, 0, STS0)
      //
      // Point to Caps DWORDs of the Arg3 buffer (CAPABILITIES)
      //
      CreateDwordField(Arg3, 4, CAP0)
  
      //
      // Check UUID
      //
      If(LEqual(Arg0,ToUUID("0811B06E-4A27-44F9-8D60-3CBBC22E7B48")))
      {
        //
        // Check Revision
        //
        If(LEqual(Arg1,One))
        {
          Store(CAP0, OSCP)
          If(And(CAP0,0x04)) // Check _PR3 Support(BIT2)
          {
            Store(0x04, OSCO)
            If(LNotEqual(And(HGMD,0x0F),2)) // Check Hybrid graphics is not enabled in bios setup [HgModeMuxless]?
            {
              If(LEqual(RTD3,0)) // Is RTD3 support disabled in Bios Setup?
              {
                // RTD3 is disabled via BIOS Setup.
                And(CAP0, 0xFFFFFFFB, CAP0) // Clear _PR3 capability
                Or(STS0, 0x10, STS0) // Indicate capability bit is cleared
              }
            }
          }
  
          //
          // Process _OSC USB4 capability
          // Clear Native USB4 capability bit if 0xFF is returned
          //
          If (LEqual (U4FN (STS0, CAP0), 0xFF))
          {
            ADBG("_OSC: Native USB4 capability bit is cleared")
            And (CAP0, 0xFFFBFFFF, CAP0) // Clear Native USB4 capability
            Or (STS0, 0x10, STS0) // Indicate capability bit is cleared
          }
        } Else {
          And (STS0, 0xFFFFFF00, STS0)
          Or (STS0, 0xA, STS0) // Unrecognised Revision and report OSC failure
        }  // Check Revision
      } ElseIf (LEqual (Arg0, ToUUID ("23A0D13A-26AB-486C-9C5F-0FFA525A575A"))) {
        //
        // Support USB capability UUID only if SW CM mode is applied.
        // OSCM is set to 1 only if CM mode is switched to SW CM successfully when _OSC platform-wide uuid with query bit cleared is called.
        //
        If (LEqual (OSCM, 1))
        {
          //
          // Point to the third DWORD of the Arg3 buffer (OSPM Control field for USB4)
          //
          CreateDWordField (Arg3, 8, CTRL)  // USB4 Control capabilities
  
          //
          // Check Revision
          //
          If (LEqual (Arg1, One))
          {
  
            //
            // Supported USB4 control fields:
            //   bit 0 - USB Tunneling
            //   bit 1 - DisplayPort Tunneling
            //   bit 2 - PCIe Tunneling
            //   bit 3 - Inter-Domain USB4 Internet Protocol
            //   bit 31:4 - Reserved
            //
            If (And (CTRL, 0xFFFFFFF0))
            {
              And (CTRL, 0x0F, CTRL)     // Clear unsupported bits
              Or (STS0, 0x10, STS0)      // Indicate capability bit is cleared
            }
  
            If (LEqual (EPTU, 0))
            {
              And (CTRL, 0x0B, CTRL)       // disable PCI Express Tunneling over USB4
              Or (STS0, 0x10, STS0)      // Indicate capability bit is cleared
            }
          } Else {
            And (STS0, 0xFFFFFF00, STS0)
            Or (STS0, 0xA, STS0) // Unrecognised Revision and report OSC failure
          } // If (LEqual (Arg1, One))
        } Else {
          And (STS0, 0xFFFFFF00, STS0)
          Or (STS0, 0x6, STS0) // Unrecognised UUID and report OSC failure
        }  // If (LEqual (OSCM, 1))
      } Else {
        And (STS0, 0xFFFFFF00, STS0)
        Or (STS0, 0x6, STS0) // Unrecognised UUID and report OSC failure
      }
  
      Return (Arg3)
    } // End _OSC
  } // End of Scope(\_SB)
  
  //
  // CS Wake up event support
  //
  Scope (\_SB)
  {
    // Define Sleep button to put the system in sleep
    Device (SLPB)
    {
      Name (_HID, EISAID ("PNP0C0E"))
      Name (_STA, 0x0B)
      // Bit0 - the device is present: Yes.
      // Bit1 - the device is enabled and decoding its resources: Yes.
      // Bit2 - the device should be shown in the UI: No.
      // Bit3 - the device is functioning properly: Yes.
      // Bit4 - the battery is present: N/A
    }
  } // End of Scope(\_SB)
  
  //
  // xPCS (Physical Coding Sublayer) IP in TSN
  //
  Scope (\_SB)
  {
    Device (PCS0)
    {
      Name(_HID, "INTC1034")
      Name(_UID, 0x0)
      Method(_STA)
      {
        If (LEqual(TSD0, 1)) {
          Return (0x0F)
        } Else {
          Return (0x00)
        }
      }
  
      Method (_CRS, 0x0, NotSerialized) {
        Name(PCSR,ResourceTemplate(){
          Memory32Fixed (ReadWrite, 0x0,0x4, MDAL)
          Memory32Fixed (ReadWrite, 0x0,0x4, MDDL)
        })
  
        //
        // Access to Registers in PCS unit indirectly through MDIO Link
        //
        CreateDWordField(PCSR,MDAL._BAS, MAL0)
        Store( Add(\_SB.PC00.GTSN.TADL,0x200), MAL0) // MAC_MDIO_Address
        CreateDWordField(PCSR,MDDL._BAS, MDL0)
        Store( Add(\_SB.PC00.GTSN.TADL,0x204), MDL0) // MAC_MDIO_Data
        Return(PCSR)
      }
    }
  } // End of Scope(\_SB)
  OperationRegion (OCWD, SystemIO, (0x1800 + 0x54), 0x4)
  Field(OCWD, DWordAcc, NoLock, Preserve)
  {
      ,      8,
      ,      8,
      FWSC,  8,    // Over-Clocking WDT Scratchpad (OC_WDT_SCRATCH)
  }
  //
  // Platform specific FWU trigger method
  //
  Method(FWUC, 2)
  {
    If(LEqual(Arg0, Zero)) {
      // Read
      And(FWSC, 0x00FF, Local0)
    } Else {
      // Write
      And(ToInteger(Arg1), 0xFF, Local0)
      And(FWSC, 0xFF00, Local1)
      Or(Local0, Local1, FWSC)
    }
    Return (Local0)
  }
  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  




  
  Scope(\_SB)
  {
    Device(PR00){ Name(_HID, "ACPI0007") Name(_UID, 0) }
    Device(PR01){ Name(_HID, "ACPI0007") Name(_UID, 1) }
    Device(PR02){ Name(_HID, "ACPI0007") Name(_UID, 2) }
    Device(PR03){ Name(_HID, "ACPI0007") Name(_UID, 3) }
    Device(PR04){ Name(_HID, "ACPI0007") Name(_UID, 4) }
    Device(PR05){ Name(_HID, "ACPI0007") Name(_UID, 5) }
    Device(PR06){ Name(_HID, "ACPI0007") Name(_UID, 6) }
    Device(PR07){ Name(_HID, "ACPI0007") Name(_UID, 7) }
    Device(PR08){ Name(_HID, "ACPI0007") Name(_UID, 8) }
    Device(PR09){ Name(_HID, "ACPI0007") Name(_UID, 9) }
    Device(PR10){ Name(_HID, "ACPI0007") Name(_UID, 10) }
    Device(PR11){ Name(_HID, "ACPI0007") Name(_UID, 11) }
    Device(PR12){ Name(_HID, "ACPI0007") Name(_UID, 12) }
    Device(PR13){ Name(_HID, "ACPI0007") Name(_UID, 13) }
    Device(PR14){ Name(_HID, "ACPI0007") Name(_UID, 14) }
    Device(PR15){ Name(_HID, "ACPI0007") Name(_UID, 15) }
    Device(PR16){ Name(_HID, "ACPI0007") Name(_UID, 16) }
    Device(PR17){ Name(_HID, "ACPI0007") Name(_UID, 17) }
    Device(PR18){ Name(_HID, "ACPI0007") Name(_UID, 18) }
    Device(PR19){ Name(_HID, "ACPI0007") Name(_UID, 19) }
    Device(PR20){ Name(_HID, "ACPI0007") Name(_UID, 20) }
    Device(PR21){ Name(_HID, "ACPI0007") Name(_UID, 21) }
    Device(PR22){ Name(_HID, "ACPI0007") Name(_UID, 22) }
    Device(PR23){ Name(_HID, "ACPI0007") Name(_UID, 23) }
    Device(PR24){ Name(_HID, "ACPI0007") Name(_UID, 24) }
    Device(PR25){ Name(_HID, "ACPI0007") Name(_UID, 25) }
    Device(PR26){ Name(_HID, "ACPI0007") Name(_UID, 26) }
    Device(PR27){ Name(_HID, "ACPI0007") Name(_UID, 27) }
    Device(PR28){ Name(_HID, "ACPI0007") Name(_UID, 28) }
    Device(PR29){ Name(_HID, "ACPI0007") Name(_UID, 29) }
    Device(PR30){ Name(_HID, "ACPI0007") Name(_UID, 30) }
    Device(PR31){ Name(_HID, "ACPI0007") Name(_UID, 31) }
    Device(PR32){ Name(_HID, "ACPI0007") Name(_UID, 32) }
    Device(PR33){ Name(_HID, "ACPI0007") Name(_UID, 33) }
    Device(PR34){ Name(_HID, "ACPI0007") Name(_UID, 34) }
    Device(PR35){ Name(_HID, "ACPI0007") Name(_UID, 35) }
    Device(PR36){ Name(_HID, "ACPI0007") Name(_UID, 36) }
    Device(PR37){ Name(_HID, "ACPI0007") Name(_UID, 37) }
    Device(PR38){ Name(_HID, "ACPI0007") Name(_UID, 38) }
    Device(PR39){ Name(_HID, "ACPI0007") Name(_UID, 39) }
    Device(PR40){ Name(_HID, "ACPI0007") Name(_UID, 40) }
    Device(PR41){ Name(_HID, "ACPI0007") Name(_UID, 41) }
    Device(PR42){ Name(_HID, "ACPI0007") Name(_UID, 42) }
    Device(PR43){ Name(_HID, "ACPI0007") Name(_UID, 43) }
    Device(PR44){ Name(_HID, "ACPI0007") Name(_UID, 44) }
    Device(PR45){ Name(_HID, "ACPI0007") Name(_UID, 45) }
    Device(PR46){ Name(_HID, "ACPI0007") Name(_UID, 46) }
    Device(PR47){ Name(_HID, "ACPI0007") Name(_UID, 47) }
    Device(PR48){ Name(_HID, "ACPI0007") Name(_UID, 48) }
    Device(PR49){ Name(_HID, "ACPI0007") Name(_UID, 49) }
    Device(PR50){ Name(_HID, "ACPI0007") Name(_UID, 50) }
    Device(PR51){ Name(_HID, "ACPI0007") Name(_UID, 51) }
    Device(PR52){ Name(_HID, "ACPI0007") Name(_UID, 52) }
    Device(PR53){ Name(_HID, "ACPI0007") Name(_UID, 53) }
    Device(PR54){ Name(_HID, "ACPI0007") Name(_UID, 54) }
    Device(PR55){ Name(_HID, "ACPI0007") Name(_UID, 55) }
    Device(PR56){ Name(_HID, "ACPI0007") Name(_UID, 56) }
    Device(PR57){ Name(_HID, "ACPI0007") Name(_UID, 57) }
    Device(PR58){ Name(_HID, "ACPI0007") Name(_UID, 58) }
    Device(PR59){ Name(_HID, "ACPI0007") Name(_UID, 59) }
    Device(PR60){ Name(_HID, "ACPI0007") Name(_UID, 60) }
    Device(PR61){ Name(_HID, "ACPI0007") Name(_UID, 61) }
    Device(PR62){ Name(_HID, "ACPI0007") Name(_UID, 62) }
    Device(PR63){ Name(_HID, "ACPI0007") Name(_UID, 63) }
  } // End Scope(\_SB)
  
  
  
  
  
  Scope(\_SB)
  {
    // The Processor Aggregator Device provides a control point that enables the platform to perform
    // specific processor configuration and control that applies to all processors in the platform.
    Device (PAGD)
    {
      Name (_HID, "ACPI000C") // Processor Aggregator Device
  
      // _STA (Status)
      //
      // This object returns the current status of a device.
      //
      // Arguments: (0)
      //   None
      // Return Value:
      //   An Integer containing a device status bitmap:
      //    Bit 0 - Set if the device is present.
      //    Bit 1 - Set if the device is enabled and decoding its resources.
      //    Bit 2 - Set if the device should be shown in the UI.
      //    Bit 3 - Set if the device is functioning properly (cleared if device failed its diagnostics).
      //    Bit 4 - Set if the battery is present.
      //    Bits 5-31 - Reserved (must be cleared).
      //
      Method(_STA)
      {
        If(\_OSI("Processor Aggregator Device")){
          Return (0x0F) // Processor Aggregator Device is supported by this OS.
        } Else {
          Return (0)    // No support in this OS.
        }
      }
  
  
      // _PUR (Processor Utilization Request)
      //
      // The _PUR object is an optional object that may be declared under the Processor Aggregator Device
      // and provides a means for the platform to indicate to OSPM the number of logical processors
      // to be idled. OSPM evaluates the _PUR object as a result of the processing of a Notify event
      // on the Processor Aggregator device object of type 0x80.
      //
      // Arguments: (0)
      //   None
      // Return Value:
      //   Package
      //
      Name (_PUR, Package() // Requests a number of logical processors to be placed in an idle state.
      {
        1,                           // RevisionID, Integer: Current value is 1
        0                            // NumProcessors, Integer
      })
  
    } // end Device(PAGD)
  }// end Scope(\_SB)
  #line 32406 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  

  /** @file
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  Scope (\_SB.PC00){
  
    Device(PDRC)
    {
      //
      // PCI Device Resource Consumption
      //
      Name(_HID,EISAID("PNP0C02"))
  
      Name(_UID,1)
  
      Name(BUF0,ResourceTemplate()
      {
        //
        // MCH BAR _BAS will be updated in _CRS below according to B0:D0:F0:Reg.48h
        //
        Memory32Fixed(ReadWrite,0,0x08000,MCHB)
        //
        // DMI BAR _BAS will be updated in _CRS below according to B0:D0:F0:Reg.68h
        //
        Memory32Fixed(ReadWrite,0,0x01000,DMIB)
        //
        // EP BAR _BAS will be updated in _CRS below according to B0:D0:F0:Reg.40h
        //
        Memory32Fixed(ReadWrite,0,0x01000,EGPB)
        //
        // PCI Express BAR _BAS and _LEN will be updated in _CRS below according to B0:D0:F0:Reg.60h
        //
        Memory32Fixed(ReadWrite,0,0,PCIX)
  
        //
        // PCH TXT space (Private / Public / TPM / DbC TraceHub / other)
        // Check if the hard code meets the real configuration.
        // If not, dynamically update it like the _CRS method below.
        //
        Memory32Fixed(ReadWrite,0xFED20000,0x60000)
  
        //
        // VTD engine memory range. Check if the hard code meets the real configuration.
        // If not, dynamically update it like the _CRS method below.
        //
        Memory32Fixed(ReadOnly, 0xFED90000, 0x00004000)
  
        //
        // MISC ICH. Check if the hard code meets the real configuration.
        // If not, dynamically update it like the _CRS method below.
        //
        Memory32Fixed(ReadWrite,0xFED45000,0x4B000,TPMM)
  
        //
        // Local APIC range(0xFEE0_0000 to 0xFEEF_FFFF)
        //
        Memory32Fixed (ReadOnly, 0xFEE00000, 0x100000, LIOH)
  
        //
        // Sx handler reserved MMIO
        //
        Memory32Fixed (ReadWrite, 0, 0, SXRE)
  
        //
        // Reserve HPET address decode range
        //
        Memory32Fixed (ReadWrite, 0, 0, HPET)
      })
  
  
      Method(_CRS,0,Serialized)
      {
        CreateDwordField(BUF0,^MCHB._BAS,MBR0)
        Store(\_SB.PC00.GMHB(), MBR0)
  
        CreateDwordField(BUF0,^DMIB._BAS,DBR0)
        Store(\_SB.PC00.GDMB(), DBR0)
  
        CreateDwordField(BUF0,^EGPB._BAS,EBR0)
        Store(\_SB.PC00.GEPB(), EBR0)
  
        CreateDwordField(BUF0,^PCIX._BAS,XBR0)
        Store(\_SB.PC00.GPCB(), XBR0)
  
        CreateDwordField(BUF0,^PCIX._LEN,XSZ0)
        Store(\_SB.PC00.GPCL(), XSZ0)
  
        // HPET device claims the resource in LpcDev.asl.
        If(LNOT(HPTE)){
          CreateDwordField(BUF0,^HPET._BAS,HBAS)
          CreateDwordField(BUF0,^HPET._LEN,HLEN)
          Store(HPTB, HBAS)
          Store(0x400, HLEN)
        }
  
        Return(BUF0)
      }
    } //end of PDRC
  } // end of SB

  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  External(DIDX)
  External(DIDY)
  External(\_SB.PC00.GFX0.DD2F, DeviceObj)
  
  // Brightness Notification:
  //    Generate a brightness related notification
  //      to the LFP if its populated.
  //
  //  Arguments:
  //    Arg0: Notification value.
  //
  //  Return Value:
  //    None
  Method(BRTN,1,Serialized)
  {
      If(LEqual(And(DIDX,0x0F0F),0x400))
      {
          Notify(\_SB.PC00.GFX0.DD1F,Arg0)
      }
      If(LEqual(And(DIDY,0x0F0F),0x401))
      {
          Notify(\_SB.PC00.GFX0.DD2F,Arg0)
      }
  }

  /** @file
    ACPI DSDT table
  
    Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
    External(\_GPE.AL6F, MethodObj)
    External(P0WK)
    External(P1WK)
    External(P2WK)
    External(P3WK)
    External(\_SB.AWAC, DeviceObj)  // ACPI000E Wake Alarm Timer device
    External(\_SB.AWAC.WAST, IntObj)
    External(\_SB.PWRB, DeviceObj)
  
    External (\_GPE.SL69, MethodObj)
    External (\_GPE.SL61, MethodObj)
    External (\_GPE.SL62, MethodObj)
    External (\_GPE.SL66, MethodObj)
    External (\_GPE.SL6F, MethodObj)
    External (\_GPE.SL6D, MethodObj)
  
    External(SPNT, MethodObj)
    External(AL6D, FieldUnitObj)
  
    //
    // General Purpose Events.  This Scope handles the Run-time and
    // Wake-time SCIs.  The specific method called will be determined by
    // the _Lxx value, where xx equals the bit location in the General
    // Purpose Event register(s).
    //
  
    // Note:
    // Originally, the two GPE methods below are automatically generated, but, for ASL code restructuring,
    // disabled the automatic generation and declare the ASL code here.
    //
  Scope(\_GPE)
  {
  


#line 32588 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  
    If (LEqual(AL6D, 0x1)) {
      Method(_L6D) {
        If (CondRefOf (\_GPE.SL6D)) {
          SL6D ();
        }
      }
    }
  
    Method(_L69, 0, serialized) {
  
      SL69 ()
    }
  
    // PCI Express Hot-Plug caused the wake event.
  
    Method(_L61)
    {
      Add(L01C,1,L01C)  // Increment L01 Entry Count.
  
      P8XH(0,0x01)      // Output information to Port 80h.
      P8XH(1,L01C)
  
      SL61 ()
    }
  
    //
    // Software GPE caused the event.
    //
    Method(_L62)
    {
      // Clear GPE status bit.
      Store(0,GPEC)
    }
  
    //
    // IGD OpRegion SCI event (see IGD OpRegion/Software SCI BIOS SPEC).
    //
    Method(_L66)
    {
      SL66 ()
    }
  
    //
    // GPP_E_16 = EC WAKETIME SCI
    //
    Method(_L50)
    {
      // Do nothing if Desktop platform
      If (LEqual(\ECON,0))
      {
        Return ()
      }
  
      // If the wake event is not a Virtual Lid or Battery, then
      // it must be a Wake from either the Keyboard or Mouse. A
      // Power Button Event will be sent for both events such
      // that the video turns back on for these "attended wake"
      // events.
  
      // Check for Virtual Lid Event.
  


































#line 32685 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      Return ()
    }
  
    Name(PRES, 1) // keep last PCH PwrBtn status, 0=press, 1=release
    Method(_L6F) // 2-tier GPE event handler
    {
      If (CondRefOf(\_GPE.AL6F))
      {
         \_GPE.AL6F()        // call handler from RTD3 table
      } Else {
      }
      SL6F ()
    }
  
    //
    // AdvancedFeaturesBegin
    //
    //GPE 72h handler for Time And Alarm Device
    Method (_L72, 0, Serialized){
      If (CondRefOf(\_SB.AWAC)) {
        Store (1, \_SB.AWAC.WAST) // Indicates Wake Alarm expired.
        Notify (\_SB.AWAC, 0x02) // Notify the OSPM of Alarm Device Wake.
      }
    }
    //
    // AdvancedFeaturesEnd
    //
  }

  /** @file
    ACPI uPEP Support
  
    Copyright (c) 2021 - 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  External(\_SB.PC00.DPOF)
  External(\_SB.PC00.LPCB.H_EC.ECNT, MethodObj)
  External(\_SB.PC00.LPCB.HPET.TCN1)
  External(\_SB.PC00.SPIF.SPIS)
  External(SPCO,MethodObj)
  External(\_SB.PC00.RP08.DL23, MethodObj)
  External(\_SB.PC00.RP08.L23D, MethodObj)
  External (TMCS, IntObj)
  
  External(THCE) // TCSS XHCI Device Enable
  External(TDCE) // TCSS XDCI Device Enable
  External(TRE0) // TCSS ItbtPcie PCIE RP 0 Device Enable
  External(TRE1) // TCSS ItbtPcie PCIE RP 1 Device Enable
  External(TRE2) // TCSS ItbtPcie PCIE RP 2 Device Enable
  External(TRE3) // TCSS ItbtPcie PCIE RP 3 Device Enable
  External(DME0) // TCSS ITBT DMA0
  External(DME1) // TCSS ITBT DMA1
  External (\PSON) // Indicates if PS_ON is enabled
  External(\_SB.PC00.XHCI.PSLI, MethodObj) // PD PS_ON Low Power S0 idle Method
  
  External(\_SB.PC00.TCON, MethodObj)
  External(\_SB.PC00.TDM0.SCME)
  External(\_SB.PC00.TDM1.SCME)
  External(\_SB.PC00.TDM0._STA)
  External(\_SB.PC00.TDM1._STA)
  
  Scope (\_SB.PC00.RP01.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP02.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP03.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP04.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP05.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP06.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP07.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP08.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP09.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP10.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP11.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP12.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP13.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP14.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP15.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP16.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP17.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP18.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP19.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP20.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP21.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP22.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP23.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP24.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP25.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP26.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP27.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.RP28.PXSX)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.PEG0.PEGP)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.PEG1.PEGP)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  Scope (\_SB.PC00.PEG2.PEGP)
  {
    /** @file
      ACPI uPEP Support for PCIe RP Endpoint Type checking
    
      Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
      SPDX-License-Identifier: BSD-2-Clause-Patent
    
    **/
    
      External (BCCX)
      External (SCCX)
      External (PIXX)
      External (ISGX, MethodObj)
      External (PNVM, MethodObj)
      External (PAHC, MethodObj)
      External (PRES, MethodObj)
    
      //
      // Check if EP(End Point) is LAN
      // Arguments: (0)
      // Return:
      //     0->EP is not LAN; 1->EP is LAN
      //
      Method (ISLN, Zero, Serialized) // Check if PCIe LAN device
      {
        If (LEqual (BCCX, 0x02)){ // Check Sub Class Code and Base Class Code
          If (LEqual (SCCX, 0x00)){
            If (LEqual (PIXX, 0x00)){
              Return (0x01)
            }
          }
        }
        Return (0x00)
      }
    
      //
      // Get EP(End Point) device type
      // Arguments: (0)
      // Return:
      //         0->Other
      //         1->Storage
      //         2->LAN -  PCH
      //         3->WLAN - PCH
      //         4->GFX -  CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      //
      Method (GRPT, Zero, Serialized) {
        If (CondRefOf (^^PRMV)) {
          If (LEqual (^^PRMV, 1)) {
            Return (99);
          }
        }
    
        If (PRES ()) {
          If (LOr (PAHC (), PNVM ())) {
            Return (1);
          }
    
          If (ISGX ()) {
            Return (4);
          }
    
          If (LEqual (PRTP, 0x02)) { // Currently Only Following devices are supported by PCH PCIE RP
            If (ISLN ()) {
              Return (2);
            }
          }
          Return(0);
        }
        Return(99);
      }

  }
  
  
  
  Scope(\_SB)
  {
    Device (PEPD)
    {
      Name (_HID, "INT33A1")
      Name (_CID, EISAID ("PNP0D80"))
      Name (_UID, 0x1)
      Name (LBUF, Buffer(192) {})
  
      Name(PPD0, Package() {"\\_SB.PC00.SAT0",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}})
      Name(PPD3, Package() {"\\_SB.PC00.SAT0",               0x0, Package() {0, Package() {0xFF, 3}}})
      Name(WWD3, Package() {"\\_SB.PC00.RP04",               0x0, Package() {0, Package() {0xFF, 3}}})
      Name(PKD0, Package() {0, Package() {0xFF, 0, 0x81}})
      Name(PKD3, Package() {0, Package() {0xFF, 3}})
      Name(DEVY, Package() // uPEP Device List
      {
        //
        // 1: ACPI Device Descriptor: Fully Qualified name-string
        // 2: Enabled/Disabled Field
        //      0 = This device is disabled and applies no constraints
        //     1+ = This device is enabled and applies constraints
        // 3: Constraint Package: entry per LPI state in LPIT
        //     a. Associated LPI State UID
        //         ID == 0xFF: same constraints apply to all states in LPIT
        //     b: minimum Dx state as pre-condition
        //     c: (optional) OEM specific OEM may provide an additional encoding
        //         which further defines the D-state Constraint
        //            0x0-0x7F - Reserved
        //            0x80-0xFF - OEM defined
        //
        Package() {"\\_SB.PR00",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  0 - SB.PR00
        Package() {"\\_SB.PR01",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  1 - SB.PR01
        Package() {"\\_SB.PR02",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  2 - SB.PR02
        Package() {"\\_SB.PR03",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  3 - SB.PR03
        Package() {"\\_SB.PR04",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  4 - SB.PR04
        Package() {"\\_SB.PR05",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  5 - SB.PR05
        Package() {"\\_SB.PR06",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  6 - SB.PR06
        Package() {"\\_SB.PR07",                    0x0, Package() {0, Package() {0xFF, 0}}},                   //  7 - SB.PR07
        Package() {"\\_SB.PC00.GFX0",               0x1, Package() {0, Package() {0xFF, 3}}},                   //  8 - Gfx
        Package() {"\\_SB.PC00.SAT0",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             //  9 - SATA
        Package() {"\\_SB.PC00.UA00",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 10 - UART0
        Package() {"\\_SB.PC00.UA01",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 11 - UART1
        Package() {"\\_SB.PC00.I2C0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 12 - I2C0
        Package() {"\\_SB.PC00.I2C1",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 13 - I2C1
        Package() {"\\_SB.PC00.XHCI",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 14 - XHCI
        Package() {"\\_SB.PC00.HDAS",               0x1, Package() {0, Package() {0xFF, 0, 0x81}}},             // 15 - cAVS (HDAudio)
        Package() {"\\_SB.PC00.PEMC",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 16 - EMMC
        Package() {"\\_SB.PC00.PSDC",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 17 - SCS SD Card (PCI Mode)
        Package() {"\\_SB.PC00.I2C2",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 18 - I2C2
        Package() {"\\_SB.PC00.I2C3",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 19 - I2C3
        Package() {"\\_SB.PC00.I2C4",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 20 - I2C4
        Package() {"\\_SB.PC00.I2C5",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 21 - I2C5
        Package() {"\\_SB.PC00.UA02",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 22 - UART2
        Package() {"\\_SB.PC00.SPI0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 23 - SPI0
        Package() {"\\_SB.PC00.SPI1",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 24 - SPI1
        Package() {"\\_SB.PC00.RP01",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 25 - RP01
        Package() {"\\_SB.PC00.RP02",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 26 - RP02
        Package() {"\\_SB.PC00.RP03",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 27 - RP03
        Package() {"\\_SB.PC00.RP04",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 28 - RP04
        Package() {"\\_SB.PC00.RP05",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 29 - RP05
        Package() {"\\_SB.PC00.RP06",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 30 - RP06
        Package() {"\\_SB.PC00.RP07",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 31 - RP07
        Package() {"\\_SB.PC00.RP08",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 32 - RP08
        Package() {"\\_SB.PC00.RP09",               0x0, Package() {0, Package() {0xFF, 3}}},                   // 33 - RP09
        Package() {"\\_SB.PC00.RP10",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 34 - RP10
        Package() {"\\_SB.PC00.RP11",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 35 - RP11
        Package() {"\\_SB.PC00.RP12",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 36 - RP12
        Package() {"\\_SB.PC00.RP13",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 37 - RP13
        Package() {"\\_SB.PC00.RP14",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 38 - RP14
        Package() {"\\_SB.PC00.RP15",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 39 - RP15
        Package() {"\\_SB.PC00.RP16",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 40 - RP16
        Package() {"\\_SB.PC00.RP17",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 41 - RP17
        Package() {"\\_SB.PC00.RP18",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 42 - RP18
        Package() {"\\_SB.PC00.RP19",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 43 - RP19
        Package() {"\\_SB.PC00.RP20",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 44 - RP20
        Package() {"\\_SB.PC00.SAT0.VOL0",          0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 45 - RAID
        Package() {"\\_SB.PR08",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 46 - SB.PR08
        Package() {"\\_SB.PR09",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 47 - SB.PR09
        Package() {"\\_SB.PR10",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 48 - SB.PR10
        Package() {"\\_SB.PR11",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 49 - SB.PR11
        Package() {"\\_SB.PR12",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 50 - SB.PR12
        Package() {"\\_SB.PR13",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 51 - SB.PR13
        Package() {"\\_SB.PR14",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 52 - SB.PR14
        Package() {"\\_SB.PR15",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 53 - SB.PR15
        Package() {"\\_SB.PC00.SPI2",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 54 - SPI2
        Package() {"\\_SB.PC00.CNVW",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 55 - CNVi WiFi
        Package() {"\\_SB.PC00.IPU0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 56 - IPU0
        Package() {"\\_SB.PC00.HECI",               0x1, Package() {0, Package() {0xFF, 0, 0x81}}},             // 57 - CSME
        Package() {"\\_SB.PC00.GLAN",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 58 - LAN(GBE)
        Package() {"\\_SB.PC00.PEG0",               0x0, Package() {0, Package() {0xFF, 3}}},                   // 59 - PEG0
        Package() {"\\_SB.PC00.THC0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 60 - THC0
        Package() {"\\_SB.PC00.THC1",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 61 - THC1
        Package() {"Depreciate IDA",                0x0, Package() {0, Package() {0xFF, 3}}},                   // 62 - Reserved
        Package() {"USB\\VID_8087&PID_0AC9&MI*",    0x0, Package() {0, Package() {0xFF, 2}}},                   // 63 - CDC MBIM
        Package() {"\\_SB.PC00.I2C6",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 64 - I2C6
        Package() {"\\_SB.PC00.PEG1",               0x0, Package() {0, Package() {0xFF, 3}}},                   // 65 - PEG1
        Package() {"\\_SB.PR16",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 66 - SB.PR16
        Package() {"\\_SB.PR17",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 67 - SB.PR17
        Package() {"\\_SB.PR18",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 68 - SB.PR18
        Package() {"\\_SB.PR19",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 69 - SB.PR19
        Package() {"\\_SB.PR20",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 70 - SB.PR20
        Package() {"\\_SB.PR21",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 71 - SB.PR21
        Package() {"\\_SB.PR22",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 72 - SB.PR22
        Package() {"\\_SB.PR23",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 73 - SB.PR23
        Package() {"\\_SB.PC00.GNA0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 74 - GNA0
        Package() {"\\_SB.PC00.VMD0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 75 - VMD0
        Package() {"\\_SB.PC00.RP21",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 76 - RP21
        Package() {"\\_SB.PC00.RP22",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 77 - RP22
        Package() {"\\_SB.PC00.RP23",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 78 - RP23
        Package() {"\\_SB.PC00.RP24",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 79 - RP24
        Package() {"Reserved For DTBT RP0",         0x0, Package() {0, Package() {0xFF, 3}}},                   // 80 - DTBT RP 00
        Package() {"Reserved For DTBT RP1",         0x0, Package() {0, Package() {0xFF, 3}}},                   // 81 - DTBT RP 01
        Package() {"\\_SB.PC00.RP25",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 82 - RP25
        Package() {"\\_SB.PC00.RP26",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 83 - RP26
        Package() {"\\_SB.PC00.RP27",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 84 - RP27
        Package() {"\\_SB.PC00.RP28",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 85 - RP28
        Package() {"\\_SB.PC00.SAT0.PRT0",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 86 - PRT0
        Package() {"\\_SB.PC00.SAT0.PRT1",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 87 - PRT1
        Package() {"\\_SB.PC00.SAT0.PRT2",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 88 - PRT2
        Package() {"\\_SB.PC00.SAT0.PRT3",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 89 - PRT3
        Package() {"\\_SB.PC00.SAT0.PRT4",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 90 - PRT4
        Package() {"\\_SB.PC00.SAT0.PRT5",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 91 - PRT5
        Package() {"\\_SB.PC00.SAT0.PRT6",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 92 - PRT6
        Package() {"\\_SB.PC00.SAT0.PRT7",          0x0, Package() {0, Package() {0xFF, 3}}},                   // 93 - PRT7
        Package() {"\\_SB.PC00.HEC3",               0x0, Package() {0, Package() {0xFF, 0, 0x81}}},             // 94 - HEC3
        Package() {"\\_SB.PC00.PEG2",               0x0, Package() {0, Package() {0xFF, 3}}},                   // 95 - PEG2
        Package() {"\\_SB.PR24",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 96 - SB.PR24
        Package() {"\\_SB.PR25",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 97 - SB.PR25
        Package() {"\\_SB.PR26",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 98 - SB.PR26
        Package() {"\\_SB.PR27",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 99 - SB.PR27
        Package() {"\\_SB.PR28",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 100 - SB.PR28
        Package() {"\\_SB.PR29",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 101 - SB.PR29
        Package() {"\\_SB.PR30",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 102 - SB.PR30
        Package() {"\\_SB.PR31",                    0x0, Package() {0, Package() {0xFF, 0}}},                   // 103 - SB.PR31
        Package() {"\\_SB.PC00.PUF0",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 104 - UFS0
        Package() {"\\_SB.PC00.PUF1",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 105 - UFS1
        Package() {"\\_SB.PC00.I2C7",               0x1, Package() {0, Package() {0xFF, 3}}},                   // 106 - I2C7
        //
        // Important: Below are TCSS IPs list, please keep it always
        // at the bottom.
        // All new IPs must be added before the below list and modify
        // below indexs accordingly.
        //
        //
        // Important: Do not add any new IPs here.
        // Add any new IPs before the above TCSS IP list.
        //
      })
  
      //
      // Get User Configured PEP Constraint
      // Arguments: (2)
      //    Arg0 - low bit index in PEPC
      //    Arg1 - high bit index in PEPC
      // Returns: 0 ->no constraint; 1->D0 F1; 3->D3
      //
      Method(GUCP, 2, Serialized) {
        If (LEqual(And(PEPC, Arg0), Arg0)) {
          If (LEqual(And(PEPC, Or(Arg1, Arg0)), Or(Arg1, Arg0))) {
            Return(3)
          } Else {
            Return(1)
          }
        } Else {
          Return(0)
        }
      }
  
      //
      // Get PEP Constraints of PCH/CPU PCIe Root Port of specific EP type
      // Arguments: (1)
      //    Arg0 - PCIE EP Device type
      //         0->Other
      //         1->Storage
      //         2->LAN - PCH
      //         3->WLAN - PCH
      //         4->GFX - CPU, PCH
      //         5->DTBT - PCH
      //         6->WWAN - PCH
      //         99->Invalid (EP absent)
      // Returns: PeP constrant per EP type
      //         0 ->no constraint; 1->D0 F1; 3->D3
      //
      Method (GRPC, 1, Serialized) {
        If (LEqual (Arg0, 1)) {
          Return (GUCP (0x0000000200000000ULL, 0x0000000400000000ULL))
        }
  
        If (LEqual (Arg0, 2)) {
          Return (GUCP (0x0000000800000000ULL, 0x0000001000000000ULL))
        }
  
        If (LEqual (Arg0, 3)) {
          If (LGreaterEqual (OSYS,2015)){
            Return (GUCP (0x0000002000000000ULL, 0x0000004000000000ULL))
          }
          Return(0)
        }
  
        If (LEqual (Arg0, 4)) {
          Return (GUCP (0x0000008000000000ULL, 0x0000010000000000ULL))
        }
  
        If (LEqual (Arg0, 5)) {
          Return (GUCP (0x20000000, 0x20000000))
        }
  
        If (LEqual (Arg0, 6)) {
          If (LEqual (WRTO, 3)) {
            Return (3)
          } Else {
            If (LEqual (WRTO, 1)) { // if WRTO is 1, then Put D2 constraint on CDC MBIM
              DSDF (WRTO, 63) // 63 - CDC MBIM
            }
            Return (0) // if WRTO is not 3, then PCIR RP Constraint should be disable
          }
        }
  
        If(LEqual (Arg0, 0)) {
          Return(GUCP(0x0000020000000000ULL, 0x0000040000000000ULL))
        }
  
        Return(0)
      }
  
      //
      // Enable uPEP constraint and set a D-state Constraint for the specified offset DEVY entry
      //
      // Arguments: (2)
      //   Arg0 - Constraint to Apply(0->no constraint; 1->D0 F1 constraint; 3: D3 F0 constraint)
      //   Arg1 -  Index of entry in uPEP Device List
      // Return Value:
      //   None
      //
      Method(DSDF, 2, Serialized) {
        If (LNotEqual (Arg1, Ones)) {
          Store (Arg1, Local0)
  
          If (LEqual (Arg0, 0)) {
            Store (0x00, Index (DeRefOf(Index (\_SB.PEPD.DEVY, Local0)), 1)) // Disable the Entry PEP Constraint
          } Else {
            If (LEqual (Arg0, 3)) {
              Store (PKD3, Index (DeRefOf(Index (\_SB.PEPD.DEVY, Local0)), 2)) // PEP Constraint Set To D3
            }
  
            If (LEqual (Arg0, 1)) {
              Store (PKD0, Index (DeRefOf(Index (\_SB.PEPD.DEVY, Local0)), 2)) // PEP Constraint Set To D0/F1
            }
  
            Store (0x01, Index (DeRefOf(Index (\_SB.PEPD.DEVY, Local0)), 1)) // Enable the Entry PEP Constraint
          }
        }
      }
  
      //
      // Get the offset of the given object in package - \_SB.PEPD.DEVY
      //
      // Arguments: (1)
      //   Arg0 - The string looking for
      // Return: The offset of the Arg0 string object
      //            Ones return if Arg0 string not found
      //
      Method (PARS, 1, Serialized) {
        Store (SizeOf (\_SB.PEPD.DEVY), Local0)//how many entries to worry about?
        Store (0, Local1) //use this as index value
        While (LGreater(Local0, Local1)) {
          Store (Derefof(Index (\_SB.PEPD.DEVY, Local1)), Local2) //grab the first package
          Store (Derefof(Index (Local2, 0)), Local3) //grab the first object inside package
          If (LEqual(Local3, Arg0)) { //check to see if object matches string
            Return(Local1) //return the index of the object
          }
          Local1++
        }
        Return(Ones)
      }
  
      //
      // Configure pep Constraint of PCH RP01~RP28 and CPU PEG0~PEG2
      //
      // Arguments: (0)
      // Return Value:
      //   None
      //
      Method(RPPC, 0, Serialized) {
        DSDF(GRPC(\_SB.PC00.RP01.PXSX.GRPT()), PARS("\\_SB.PC00.RP01"))
        DSDF(GRPC(\_SB.PC00.RP02.PXSX.GRPT()), PARS("\\_SB.PC00.RP02"))
        DSDF(GRPC(\_SB.PC00.RP03.PXSX.GRPT()), PARS("\\_SB.PC00.RP03"))
        DSDF(GRPC(\_SB.PC00.RP04.PXSX.GRPT()), PARS("\\_SB.PC00.RP04"))
        DSDF(GRPC(\_SB.PC00.RP05.PXSX.GRPT()), PARS("\\_SB.PC00.RP05"))
        DSDF(GRPC(\_SB.PC00.RP06.PXSX.GRPT()), PARS("\\_SB.PC00.RP06"))
        DSDF(GRPC(\_SB.PC00.RP07.PXSX.GRPT()), PARS("\\_SB.PC00.RP07"))
        DSDF(GRPC(\_SB.PC00.RP08.PXSX.GRPT()), PARS("\\_SB.PC00.RP08"))
        DSDF(GRPC(\_SB.PC00.RP09.PXSX.GRPT()), PARS("\\_SB.PC00.RP09"))
        DSDF(GRPC(\_SB.PC00.RP10.PXSX.GRPT()), PARS("\\_SB.PC00.RP10"))
        DSDF(GRPC(\_SB.PC00.RP11.PXSX.GRPT()), PARS("\\_SB.PC00.RP11"))
        DSDF(GRPC(\_SB.PC00.RP12.PXSX.GRPT()), PARS("\\_SB.PC00.RP12"))
        DSDF(GRPC(\_SB.PC00.RP13.PXSX.GRPT()), PARS("\\_SB.PC00.RP13"))
        DSDF(GRPC(\_SB.PC00.RP14.PXSX.GRPT()), PARS("\\_SB.PC00.RP14"))
        DSDF(GRPC(\_SB.PC00.RP15.PXSX.GRPT()), PARS("\\_SB.PC00.RP15"))
        DSDF(GRPC(\_SB.PC00.RP16.PXSX.GRPT()), PARS("\\_SB.PC00.RP16"))
        DSDF(GRPC(\_SB.PC00.RP17.PXSX.GRPT()), PARS("\\_SB.PC00.RP17"))
        DSDF(GRPC(\_SB.PC00.RP18.PXSX.GRPT()), PARS("\\_SB.PC00.RP18"))
        DSDF(GRPC(\_SB.PC00.RP19.PXSX.GRPT()), PARS("\\_SB.PC00.RP19"))
        DSDF(GRPC(\_SB.PC00.RP20.PXSX.GRPT()), PARS("\\_SB.PC00.RP20"))
        DSDF(GRPC(\_SB.PC00.RP21.PXSX.GRPT()), PARS("\\_SB.PC00.RP21"))
        DSDF(GRPC(\_SB.PC00.RP22.PXSX.GRPT()), PARS("\\_SB.PC00.RP22"))
        DSDF(GRPC(\_SB.PC00.RP23.PXSX.GRPT()), PARS("\\_SB.PC00.RP23"))
        DSDF(GRPC(\_SB.PC00.RP24.PXSX.GRPT()), PARS("\\_SB.PC00.RP24"))
        DSDF(GRPC(\_SB.PC00.RP25.PXSX.GRPT()), PARS("\\_SB.PC00.RP25"))
        DSDF(GRPC(\_SB.PC00.RP26.PXSX.GRPT()), PARS("\\_SB.PC00.RP26"))
        DSDF(GRPC(\_SB.PC00.RP27.PXSX.GRPT()), PARS("\\_SB.PC00.RP27"))
        DSDF(GRPC(\_SB.PC00.RP28.PXSX.GRPT()), PARS("\\_SB.PC00.RP28"))
        DSDF(GRPC(\_SB.PC00.PEG0.PEGP.GRPT()), PARS("\\_SB.PC00.PEG0"))
        DSDF(GRPC(\_SB.PC00.PEG1.PEGP.GRPT()), PARS("\\_SB.PC00.PEG1"))
        DSDF(GRPC(\_SB.PC00.PEG2.PEGP.GRPT()), PARS("\\_SB.PC00.PEG2"))
      }
  
      Method(SPDE, 0, Serialized) {
        External (\ESPC) // Indicates if constraints should be enumerated
        //
        // Below methods check for drive presence in SATA port
        //
        External (\_SB.PC00.SAT0.PRT0.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT1.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT2.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT3.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT4.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT5.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT6.PRES, MethodObj)
        External (\_SB.PC00.SAT0.PRT7.PRES, MethodObj)
  
        If (LNot(\ESPC)) {
          Return ()
        }
  
        If (\_SB.PC00.SAT0.PRT0.PRES()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 86)), 1))
        }
        If (\_SB.PC00.SAT0.PRT1.PRES()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 87)), 1))
        }
        If (\_SB.PC00.SAT0.PRT2.PRES()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 88)), 1))
        }
        If (\_SB.PC00.SAT0.PRT3.PRES()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 89)), 1))
        }
        If (\_SB.PC00.SAT0.PRT4.PRES()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 90)), 1))
        }
        If (\_SB.PC00.SAT0.PRT5.PRES ()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 91)), 1))
        }
        If (\_SB.PC00.SAT0.PRT6.PRES()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 92)), 1))
        }
        If (\_SB.PC00.SAT0.PRT7.PRES ()) {
          Store (0x01, Index (DeRefOf(Index (DEVY, 93)), 1))
        }
      }
  
      Name(BCCD, Package() // Bugcheck Critical Device(s)
      {  })
  
      OperationRegion (LS0I, SystemMemory, LPMR, 192)
      Field (LS0I, ByteAcc, Lock, Preserve)
      {
        //
        // Low Power Mode Required Register
        //
        L0IX, 1536,
      }
  
      //
      // _DSD to notify OSPM about CEC PS_ON support.
      //
      Name (_DSD, Package (0x02) { // Using Name object to be compatible for different OSPM
        ToUUID ("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
        Package (0x01) {
          Package (0x02) {
            "intel-cec-pson-switching-enabled-in-s0",
            0 // to be updated in PSOP
          }
        }
      })
  
      Method (PSOP, 0, NotSerialized) { // PSON Pep Check
        //
        // Loop through _DSD object to find index for UUID of interest.
        // Stride length is 2 because list of properties comes right after the corresponding UUID.
        //
        For (Local0 = Zero, Local0 < SizeOf(_DSD), Local0 += 2) {
          If (LNotEqual(DerefOf(_DSD[Local0]), ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"))) {
            // skip if not the uuid of interest
            Continue
          }
          // get the package associated with this UUID
          Local1 = DerefOf (_DSD[Add(Local0, 1)])
          For (Local2 = Zero, Local2 < SizeOf(Local1), Increment(Local2)) {
            // get the key/value pair at the index
            Local3 = DerefOf(Local1[Local2])
            If (LAnd(LEqual("intel-cec-pson-switching-enabled-in-s0", DerefOf(Local3[Zero])), PSON)) {
              DerefOf(DerefOf(_DSD[Local0 + 1])[Local2])[One] = One
            }
          }
        }
        Return
      }
  
      Method(_STA, 0x0, NotSerialized)
      {
        If(LEqual(S0ID, 1))
        {
          PSOP () // Update _DSD
          Return(0xf)
        }
        Return(0)
      }
  
      Method(_DSM, 0x4, Serialized)
      {
  
        If(LEqual(Arg0,ToUUID("c4eb40a0-6cd2-11e2-bcfd-0800200c9a66")))
        {
          // Number of Functions (including this one)
          If(LEqual(Arg2, Zero))
          {
            Return(Buffer(One){0x7F})
          }
          // Device Constraints Enumeration
          If(LEqual(Arg2, One))
          {
            If (LEqual(S0ID, 0)) {
              Return(Package() {})
            }
  
            //
            // SATA port drive constraint enumeration
            //
            SPDE()
  
            // Update uPEP device list based on PEPC (Low Power S0 Constraint)
            // Bit[1:0] - Storage (0:None, 1:Storage Controller, 2:Raid)
            // Bit[2]   - En/Dis UART0
            // Bit[3]   - En/Dis UART1
            // Bit[4]   - En/Dis I2C0
            // Bit[5]   - En/Dis I2C1
            // Bit[6]   - En/Dis XHCI
            // Bit[8:7] - HD Audio (includes ADSP) (0:None, 1:D0F1, 3:D3)
            // Bit[9]   - En/Dis Gfx
            // Bit[10]  - En/Dis PR0
            // Bit[11]  - En/Dis EMMC
            // Bit[12]  - En/Dis SDXC
            // Bit[13]  - En/Dis I2C2
            // Bit[14]  - En/Dis I2C3
            // Bit[15]  - En/Dis I2C4
            // Bit[16]  - En/Dis I2C5
            // Bit[17]  - En/Dis UART2
            // Bit[18]  - En/Dis SPI0
            // Bit[19]  - En/Dis SPI1
            // Bit[20]  - En/Dis SPI2
            // Bit[21]  - En/Dis IPU0
            // Bit[22]  - En/Dis CSME
            // Bit[23]  - En/Dis LAN(GBE)
            // Bit[24]  - Reserved
            // Bit[25]  - En/Dis THC0
            // Bit[26]  - En/Dis THC1
            // Bit[27]  - Reserved
            // Bit[28]  - En/Dis I2C6
            // Bit[29]  - En/Dis TCSS IPs/DTBT
            // Bit[30]  - En/Dis GNA0
            // Bit[31]  - En/Dis VMD0
            // Bit[32]  - En/Dis HECI3
            // Bit[34:33] - PCIe Storage(0:None, 1:D0F1, 3:D3)
            // Bit[36:35] - PCIe Lan(0:None, 1:D0F1, 3:D3)
            // Bit[38:37] - PCIe Wlan(0:None, 1:D0F1, 3:D3)
            // Bit[40:39] - PCIe Gfx(0:None, 1:D0F1, 3:D3)
            // Bit[42:41] - PCIe Other(0:None, 1:D0F1, 3:D3)
            // Bit[43]  - En/Dis DG on x8 PEG port (PEG1)
            // BIT[44]  - En/Dis UFS0
            // BIT[45]  - En/Dis UFS1
            // Bit[46]  - En/Dis I2C7
  
            If(LEqual(And(PEPC, 0x00000001), 1)) // PEPC Bit[1:0] - Storage (1:Adapter D0/F1 or 3:Adapter D3)
            {
              // Constraint for SATA Controller (SAT0)
              If(LEqual(And(PEPC, Or(0x00000002, 0x00000001)), 1)) // PEPC Bit[1:0] - Storage (1:Adapter D0/F1)
              {
                Store (PPD0, Index (DEVY, 9)) // 9 - SATA Adapter D0
              } ElseIf(LEqual(And(PEPC, Or(0x00000002, 0x00000001)), 3)) // PEPC Bit[1:0] - Storage (3:Adapter D3)
              {
                Store (PPD3, Index (DEVY, 9)) // 9 - SATA Adapter D3
              }
              Store (0x01, Index (DeRefOf(Index (DEVY, 9)), 1)) // Set PEP enabled
            } ElseIf(LEqual(And(PEPC, Or(0x00000002, 0x00000001)), 2)) // PEPC Bit[1:0] - Storage (0:None, 1:Adapter D0/F1, 2:Raid, 3:Adapter D3)
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 45)), 1)) // 45 - RAID
            }
  
            //Apply all the PCIe root ports constraint based on user choice
            RPPC()
  
            If(LEqual(And(PEPC, 0x00000004), 0)) // PEPC Bit[2] - En/Dis UART0
            {
              // Disabled UA00
              Store (0x00, Index (DeRefOf(Index (DEVY, 10)), 1)) // 10 - UART0
            }
  
            If(LEqual(And(PEPC, 0x00000008), 0)) // PEPC Bit[3] - En/Dis UART1
            {
              // Disabled UA01
              Store (0x00, Index (DeRefOf(Index (DEVY, 11)), 1)) // 11 - UART1
            }
  
            If(LEqual(And(PEPC, 0x00000010), 0)) // PEPC Bit[4] - En/Dis I2C0
            {
              // Disabled I2C0
              Store (0x00, Index (DeRefOf(Index (DEVY, 12)), 1)) // 12 - I2C0
            }
  
            If(LEqual(And(PEPC, 0x00000020), 0))  // PEPC Bit[5] - En/Dis I2C1
            {
              // Disabled I2C1
              Store (0x00, Index (DeRefOf(Index (DEVY, 13)), 1)) // 13 - I2C1
            }
  
            If(LEqual(And(PEPC, 0x00000040), 0))  // PEPC Bit[6] - En/Dis XHCI
            {
              // Disabled XHCI
              Store (0x00, Index (DeRefOf(Index (DEVY, 14)), 1)) // 14 - XHCI
            }
  
            DSDF(GUCP(0x00000080, 0x00000100), PARS("\\_SB.PC00.HDAS")) //15 - HD Audio (includes ADSP)
  
            If(LEqual(And(PEPC, 0x00000200), 0)) // PEPC Bit[9] - En/Dis Gfx
            {
              // Disabled Gfx
              Store (0x00, Index (DeRefOf(Index (DEVY, 8)), 1)) // 8 - Gfx
            }
  
            // Apply PEP constraints for CPU,
            // Based on number of threads
            If (LGreaterEqual(TCNT, 1))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 0)), 1))  // 0 - PR00
            }
            If (LGreaterEqual(TCNT, 2))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 1)), 1))  // 1 - PR01
            }
            If (LGreaterEqual(TCNT, 3))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 2)), 1))  // 2 - PR02
            }
            If (LGreaterEqual(TCNT, 4))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 3)), 1))  // 3 - PR03
            }
            If (LGreaterEqual(TCNT, 5))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 4)), 1))  // 4 - PR04
            }
            If (LGreaterEqual(TCNT, 6))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 5)), 1))  // 5 - PR05
            }
            If (LGreaterEqual(TCNT, 7))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 6)), 1))  // 6 - PR06
            }
            If (LGreaterEqual(TCNT, 8))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 7)), 1))  // 7 - PR07
            }
            If (LGreaterEqual(TCNT, 9))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 46)), 1))  // 46 - PR08
            }
            If (LGreaterEqual(TCNT, 10))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 47)), 1))  // 47 - PR09
            }
            If (LGreaterEqual(TCNT, 11))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 48)), 1))  // 48 - PR10
            }
            If (LGreaterEqual(TCNT, 12))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 49)), 1))  // 49 - PR11
            }
            If (LGreaterEqual(TCNT, 13))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 50)), 1))  // 50 - PR12
            }
            If (LGreaterEqual(TCNT, 14))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 51)), 1))  // 51 - PR13
            }
            If (LGreaterEqual(TCNT, 15))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 52)), 1))  // 52 - PR14
            }
            If (LGreaterEqual(TCNT, 16))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 53)), 1))  // 53 - PR15
            }
            If (LGreaterEqual(TCNT, 17))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 66)), 1))  // 66 - PR16
            }
            If (LGreaterEqual(TCNT, 18))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 67)), 1))  // 67 - PR17
            }
            If (LGreaterEqual(TCNT, 19))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 68)), 1))  // 68 - PR18
            }
            If (LGreaterEqual(TCNT, 20))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 69)), 1))  // 69 - PR19
            }
            If (LGreaterEqual(TCNT, 21))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 70)), 1))  // 70 - PR20
            }
            If (LGreaterEqual(TCNT, 22))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 71)), 1))  // 71 - PR21
            }
            If (LGreaterEqual(TCNT, 23))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 72)), 1))  // 72 - PR22
            }
            If (LGreaterEqual(TCNT, 24))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 73)), 1))  // 73 - PR23
            }
            If (LGreaterEqual(TCNT, 25))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 96)), 1))  // 96 - PR24
            }
            If (LGreaterEqual(TCNT, 26))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 97)), 1))  // 97 - PR25
            }
            If (LGreaterEqual(TCNT, 27))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 98)), 1))  // 98 - PR26
            }
            If (LGreaterEqual(TCNT, 28))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 99)), 1))  // 99 - PR27
            }
            If (LGreaterEqual(TCNT, 29))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 100)), 1))  // 100 - PR28
            }
            If (LGreaterEqual(TCNT, 30))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 101)), 1))  // 101 - PR29
            }
            If (LGreaterEqual(TCNT, 31))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 102)), 1))  // 102 - PR30
            }
            If (LGreaterEqual(TCNT, 32))
            {
              Store (0x01, Index (DeRefOf(Index (DEVY, 103)), 1))  // 103 - PR31
            }
            If(LEqual(And(PEPC, 0x00000400), 0)) // PEPC Bit[10] - En/Dis CPU
            {
              // Disabled PEP PR0
              Store (0x00, Index (DeRefOf(Index (DEVY, 0)), 1))   // 0 -  PR00
              Store (0x00, Index (DeRefOf(Index (DEVY, 1)), 1))   // 1 -  PR01
              Store (0x00, Index (DeRefOf(Index (DEVY, 2)), 1))   // 2 -  PR02
              Store (0x00, Index (DeRefOf(Index (DEVY, 3)), 1))   // 3 -  PR03
              Store (0x00, Index (DeRefOf(Index (DEVY, 4)), 1))   // 4 -  PR04
              Store (0x00, Index (DeRefOf(Index (DEVY, 5)), 1))   // 5 -  PR05
              Store (0x00, Index (DeRefOf(Index (DEVY, 6)), 1))   // 6 -  PR06
              Store (0x00, Index (DeRefOf(Index (DEVY, 7)), 1))   // 7 -  PR07
              Store (0x00, Index (DeRefOf(Index (DEVY, 46)), 1))  // 46 - PR08
              Store (0x00, Index (DeRefOf(Index (DEVY, 47)), 1))  // 47 - PR09
              Store (0x00, Index (DeRefOf(Index (DEVY, 48)), 1))  // 48 - PR10
              Store (0x00, Index (DeRefOf(Index (DEVY, 49)), 1))  // 49 - PR11
              Store (0x00, Index (DeRefOf(Index (DEVY, 50)), 1))  // 50 - PR12
              Store (0x00, Index (DeRefOf(Index (DEVY, 51)), 1))  // 51 - PR13
              Store (0x00, Index (DeRefOf(Index (DEVY, 52)), 1))  // 52 - PR14
              Store (0x00, Index (DeRefOf(Index (DEVY, 53)), 1))  // 53 - PR15
              Store (0x00, Index (DeRefOf(Index (DEVY, 66)), 1))  // 66 - PR16
              Store (0x00, Index (DeRefOf(Index (DEVY, 67)), 1))  // 67 - PR17
              Store (0x00, Index (DeRefOf(Index (DEVY, 68)), 1))  // 68 - PR18
              Store (0x00, Index (DeRefOf(Index (DEVY, 69)), 1))  // 69 - PR19
              Store (0x00, Index (DeRefOf(Index (DEVY, 70)), 1))  // 70 - PR20
              Store (0x00, Index (DeRefOf(Index (DEVY, 71)), 1))  // 71 - PR21
              Store (0x00, Index (DeRefOf(Index (DEVY, 72)), 1))  // 72 - PR22
              Store (0x00, Index (DeRefOf(Index (DEVY, 73)), 1))  // 73 - PR23
              Store (0x00, Index (DeRefOf(Index (DEVY, 96)), 1))  // 96 - PR24
              Store (0x00, Index (DeRefOf(Index (DEVY, 97)), 1))  // 97 - PR25
              Store (0x00, Index (DeRefOf(Index (DEVY, 98)), 1))  // 98 - PR26
              Store (0x00, Index (DeRefOf(Index (DEVY, 99)), 1))  // 99 - PR27
              Store (0x00, Index (DeRefOf(Index (DEVY, 100)), 1)) // 100 - PR28
              Store (0x00, Index (DeRefOf(Index (DEVY, 101)), 1)) // 101 - PR29
              Store (0x00, Index (DeRefOf(Index (DEVY, 102)), 1)) // 102 - PR30
              Store (0x00, Index (DeRefOf(Index (DEVY, 103)), 1)) // 103 - PR31
            }
  
            If(LOr(LEqual(And(PEPC, 0x00000800), 0), LEqual(EMCE,0))) // PEPC Bit[11] - En/Dis eMMC
            {
              // Disabled eMMC
              Store (0x00, Index (DeRefOf(Index (DEVY, 16)), 1)) // 16 - EMMC
            }
  
            If(LOr(LEqual(And(PEPC, 0x00001000), 0), LEqual(SDCE,0))) // PEPC Bit[12] - En/Dis SDXC
            {
              // Disabled SDXC
              Store (0x00, Index (DeRefOf(Index (DEVY, 17)), 1)) // 17 - SCS SD Card (PCI Mode)
            }
  
            If(LEqual(And(PEPC, 0x00002000), 0)) { // PEPC Bit[13] - En/Dis I2C2
              Store (0x00, Index (DeRefOf(Index (DEVY, 18)), 1)) // 18 - I2C2
            }
  
            If(LEqual(And(PEPC, 0x00004000),0)) { // PEPC Bit[14] - En/Dis I2C3
              Store (0x00, Index (DeRefOf(Index (DEVY, 19)), 1)) // 19 - I2C3
            }
  
            If(LEqual(And(PEPC, 0x00008000), 0)) { // PEPC Bit[15] - En/Dis I2C4
              Store (0x00, Index (DeRefOf(Index (DEVY, 20)), 1)) // 20 - I2C4
            }
  
            If(LEqual(And(PEPC, 0x00010000), 0)) { // PEPC Bit[16] - En/Dis I2C5
              Store (0x00, Index (DeRefOf(Index (DEVY, 21)), 1)) // 21 - I2C5
            }
  
            If(LEqual(And(PEPC, 0x0000400000000000ULL), 0)) { // PEPC Bit[46] - En/Dis I2C7
              Store (0x00, Index (DeRefOf(Index (DEVY, 106)), 1)) // 106 - I2C7
            }
  
            If(LEqual(And(PEPC, 0x00020000), 0)) { // PEPC Bit[17] - En/Dis UART2
              Store (0x00, Index (DeRefOf(Index (DEVY, 22)), 1)) // 22 - UART2
            }
  
            If(LEqual(And(PEPC, 0x00040000), 0)) { // PEPC Bit[18] - En/Dis SPI0
              Store (0x00, Index (DeRefOf(Index (DEVY, 23)), 1)) // 23 - SPI0
            }
  
            If(LEqual(And(PEPC, 0x00080000), 0)) { // PEPC Bit[19] - En/Dis SPI1
              Store (0x00, Index (DeRefOf(Index (DEVY, 24)), 1)) // 24 - SPI1
            }
  
            If(LEqual(And(PEPC, 0x00100000), 0)) { // PEPC Bit[20] - En/Dis SPI2
              Store (0x00, Index (DeRefOf(Index (DEVY, 54)), 1)) // 54 - SPI2
            }
            If(LEqual(And(PEPC, 0x00200000), 0)) { // PEPC Bit[21] - En/Dis IPU0
              Store (0x00, Index (DeRefOf(Index (DEVY, 56)), 1)) // 56 - IPU0
            }
  
            If(LEqual(And(PEPC, 0x00400000), 0)) { // PEPC Bit[22] - En/Dis CSME
              Store (0x00, Index (DeRefOf(Index (DEVY, 57)), 1)) // 57 - CSME
            }
  
            If(LOr(LEqual(And(PEPC, 0x00800000), 0), LEqual(GBES,0))) { // PEPC Bit[23] - En/Dis LAN(GBE)
              Store (0x00, Index (DeRefOf(Index (DEVY, 58)), 1)) // 58 - LAN(GBE)
            }
  
            If(LEqual(And(PEPC, 0x02000000), 0)) { // PEPC Bit[25] - En/Dis THC0
              Store (0x00, Index (DeRefOf(Index (DEVY, 60)), 1)) // 60 - THC0
            }
  
            If(LEqual(And(PEPC, 0x04000000), 0)) { // PEPC Bit[26] - En/Dis THC1
              Store (0x00, Index (DeRefOf(Index (DEVY, 61)), 1)) // 61 - THC1
            }
  
            If(LEqual(And(PEPC, 0x10000000), 0)) { // PEPC Bit[28] - En/Dis I2C6
              Store (0x00, Index (DeRefOf(Index (DEVY, 64)), 1)) // 64 - I2C6
            }
  
            If(LNotEqual(And(PEPC, 0x0000080000000000ULL), 0)) { // PEPC Bit[43] - En/Dis DG on PEG1 (x8 PEG Port)
              Store (0x01, Index (DeRefOf(Index (DEVY, 65)), 1)) // 65 - DG
            }
            If(LEqual(And(PEPC, 0x0000100000000000ULL), 0)) { // PEPC Bit[44] - En/Dis UFS0
              Store (0x00, Index (DeRefOf(Index (DEVY, 104)), 1)) // 104 - UFS0
            }
            If(LEqual(And(PEPC, 0x0000200000000000ULL), 0)) { // PEPC Bit[45] - En/Dis UFS1
              Store (0x00, Index (DeRefOf(Index (DEVY, 105)), 1)) // 105 - UFS1
            }
            If(LEqual(And(PEPC, 0x40000000), 0)) { // PEPC Bit[30] - En/Dis GNA0
              Store (0x00, Index (DeRefOf(Index (DEVY, 74)), 1)) // 74 - GNA0
            }
  
            If(LEqual(And(PEPC, 0x80000000), 0)) { // PEPC Bit[31] - En/Dis VMD0
              Store (0x00, Index (DeRefOf(Index (DEVY, 75)), 1)) // 75 - VMD0
            }
  
            If (CondRefOf(\_SB.PC00.HEC3)) {
              If(LNotEqual(And(PEPC, 0x0000000100000000ULL), 0)) { // PEPC Bit[32] - En/Dis HECI3
                Store (0x01, Index (DeRefOf(Index (DEVY, 94)), 1)) // 94 - HECI3
              }
            }
            Return(DEVY)
          }
  
          // BCCD
          If(LEqual(Arg2, 2))
          {
            Return(BCCD)
          }
  
          // Screen off notification
          If(LEqual(Arg2, 0x3))
          {
            // no action for screen off
            If(LEqual(S0ID, 1)) { //S0ID: >=1: CS 0: non-CS
              D8XH (0, 0xC5)
              D8XH (1, 0)
            }
          }
  
          // Screen on notification
          If(LEqual(Arg2, 0x4))
          {
            // no action for screen on
            If(LEqual(S0ID, 1)) { //S0ID: >=1: CS 0: non-CS
              D8XH (0, 0xC5)
              D8XH (1, 0xAB)
            }
          }
  
          Name(RSTG, Package() {0, 0})
          Name(PWRG, Package() {0, 0})
  
          // resiliency phase entry (deep standby entry)
          Store (1, Local0) // Display All Monitor off flag
          ADBG(Concatenate ("All Monitor off flag(default): ", ToHexString (Local0)))
          If(LEqual(Arg2, 0x5))
          {
            If(LEqual(S0ID, 1)) { //S0ID: >=1: CS 0: non-CS
              // call method specific to CS platforms when the system is in a
              // standby state with very limited SW activities
              \_SB.PC00.SPIF.SPIS() // Clear SPI Synchronous SMI Status bit
              Store(0x0000000000000000, \_SB.PC00.LPCB.HPET.TCN1)
              \_SB.PC00.RP08.DL23()
              Store(0x90C000A, Index(RSTG, 0))
              Store(0x0, Index(RSTG, 1))
              Store(0x9020016, Index(PWRG, 0))
              Store(0x0, Index(PWRG, 1))
              \PIN.ON(RSTG)
              \_SB.PSD3 (1)
              If(CondRefOf(TMCS)) {
                SPCX(7, 0, TMCS)
              } Else {
                SPCO(7, 0)
              }
              \PIN.OFF (PWRG)
              \_SB.SHPO (0, 0)
              \GUAM(1) // 0x01 - Power State Standby (CS Resiliency Entry)
            }
  
            If (\ECON)
            {
              \_SB.PC00.LPCB.H_EC.ECNT(1) // 0x01 - Call method to notify EC of Idle Resiliency entry
            }
            If (CondRefOf(\_SB.PC00.TXHC)) {
              If (LEqual(\_SB.PC00.TDM0._STA, 0x0F)) {  // check DMA0
                If (LEqual (\_SB.PC00.TDM0.SCME, 1)) {
                  Store (0, Local0)
                  ADBG(Concatenate ("TDM0 set DPOF to  ", ToHexString (Local0)))
                }
              } ElseIf (LEqual(\_SB.PC00.TDM1._STA, 0x0F)) {  // check DMA1
                If (LEqual (\_SB.PC00.TDM1.SCME, 1)) {
                  Store (0, Local0)
                  ADBG(Concatenate ("TDM1 set DPOF to  ", ToHexString (Local0)))
                }
              }
              // Local0 = 1
              // Give indication to IOM that all the display is OFF
              // Local0 = 0
              // The system is running in SW CM mode
              // Skip DPOF setting
              ADBG(Concatenate ("All Monitor off flag: ", ToHexString (Local0)))
              If (LEqual (Local0, 1)) {
                Store (1, \_SB.PC00.DPOF)
              }
            }
            If (CondRefOf (\_SB.PC00.XHCI.PSLI)) {
              \_SB.PC00.XHCI.PSLI (5)
            } else {
            }
          }
  
          // resiliency phase exit (deep standby exit)
          If(LEqual(Arg2, 0x6))
          {
            If(LEqual(S0ID, 1)) { //S0ID: >=1: CS 0: non-CS
              // call method specific to CS platforms when the system is in a
              // standby state with very limited SW activities
              Store(0x90C000A, Index(RSTG, 0))
              Store(0x0, Index(RSTG, 1))
              Store(0x9020016, Index(PWRG, 0))
              Store(0x0, Index(PWRG, 1))
              \_SB.SHPO (0, 1)
              \_SB.CAGS (0)
              \_SB.PSD0 (1)
              \PIN.ON (PWRG)
              Sleep (PEP0)
              If(CondRefOf(TMCS)) {
                SPCX(7, 1, TMCS)
              } Else {
                SPCO(7, 1)
              }
              \PIN.OFF (RSTG)
              \_SB.PC00.RP08.L23D()
              \GUAM(0) // 0x00 - Power State On (CS Resiliency Exit)
            }
            If (\ECON) {
              \_SB.PC00.LPCB.H_EC.ECNT(0) // 0x00 - Call method to notify EC of Idle Resiliency exit
            }
  
            If (CondRefOf(\_SB.PC00.TXHC)) {
              Store(0, \_SB.PC00.DPOF) //Clear bit17 to indicate IOM that all the display is not OFF.
            }
  
            If (CondRefOf (\_SB.PC00.XHCI.PSLI)) {
              \_SB.PC00.XHCI.PSLI (6)
            } else {
            }
  
          }
        }// If(LEqual(Arg0,ToUUID("c4eb40a0-6cd2-11e2-bcfd-0800200c9a66")))
  
        If ((Arg0 == ToUUID ("57a6512e-3979-4e9d-9708-ff13b2508972")))
        {
          If ((Arg2 == Zero)) {
            Return (Buffer(One) { 0x03 })
          }
          If ((Arg2 == 0x01))
          {
            Store (L0IX, LBUF)
            Return (LBUF)
          }
        } // If(LEqual(Arg0,ToUUID("57a6512e-3979-4e9d-9708-ff13b2508972")))
  
        Return (Buffer() {0})
      } // Method(_DSM)
    } //device (PEPD)
  } // End Scope(\_SB)

  /** @file
    ACPI DSDT table
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  //
  // Since asl compiler update to 2018 version
  // Empty template will casuse warrning
  // using this Macro to replace empty ResourceTemplate with End Tag
  //
  


  
  //
  //  Define each SerialIO devices these item value must sync SetupVariable.h
  //
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Scope(\_SB.PC00) {
  
    Name (HIDG, ToUUID("3CDFF6F7-4267-4555-AD05-B30A3D8938DE")) //GUID for HID-over-I2C
    Name (TP7G, ToUUID("EF87EB82-F951-46DA-84EC-14871AC6F84B")) //GUID for Touch device support in Windows7
  
    Method(HIDD, 5, Serialized) {
      // Common _DSM method for HID I2C devices
      // Arg0..3 - original arguments to _DSM method, as passed by OS
      // Arg4 - HID descriptor address to be returned from Function1
      If(LEqual(Arg0, HIDG)) {
        If(LEqual(Arg2, Zero)) { // Function 0 : Query Function
          If(LEqual(Arg1, One)) { // Revision 1
            Return (Buffer(One) { 0x03 })
          }
        }
        If(LEqual(Arg2, One)) { // Function 1 : HID Function
          Return (Arg4) // HID Descriptor Address (IHV Specific)
        }
      }
      Return (Buffer(1){0})
    }
  
    Method(TP7D, 6, Serialized) {
      // Common _DSM method for touch devices support in Win7
      // Arg0..3 - original arguments to _DSM method, as passed by OS
      // Arg4..5 - buffers containing resources (such as I2c bus, interrupt) to be returned from Function1
      If (LEqual(Arg0, TP7G)) {
        If (LEqual(Arg2, Zero)) { // Function 0 : Query Function
          If (LEqual(Arg1, One)) { // Revision 1
            Return(Buffer(One) { 0x03 })
          }
        }
        If (LEqual(Arg2, One)) { // Function 1 : Report resources
          Return (ConcatenateResTemplate(Arg4, Arg5))
        }
      }
      Return (Buffer(1){0})
    }
  
    //
    // Create I2C Bus Resource Descriptor for _CRS Usage
    // Arg0 - I2C Controller Number (Resource Source)
    // Arg1 - I2C Bus Address of the Connection (Peripheral Address)
    // Arg2 - I2C Bus Speed of the Connection (Connection Speed)
    // Returns Buffer with 'I2cSerialBus' Resource Descriptor
    //
    Method (I2CM, 3, Serialized) {
      Switch (ToInteger(Arg0)) {
        Case(0x0) { Name (IIC0 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C0", 0x00, ResourceConsumer, DEV0,) })
          CreateWordField (IIC0, DEV0._ADR, DAD0)
          CreateDWordField(IIC0,DEV0._SPE,DSP0)
          Store (Arg1, DAD0)
          Store (Arg2, DSP0)
          Return (IIC0) }
        Case(0x1) { Name (IIC1 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C1", 0x00, ResourceConsumer, DEV1,) })
          CreateWordField (IIC1, DEV1._ADR, DAD1)
          CreateDWordField(IIC1,DEV1._SPE,DSP1)
          Store (Arg1, DAD1)
          Store (Arg2, DSP1)
          Return (IIC1) }
        Case(0x2) { Name (IIC2 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C2", 0x00, ResourceConsumer, DEV2,) })
          CreateWordField (IIC2, DEV2._ADR, DAD2)
          CreateDWordField(IIC2,DEV2._SPE,DSP2)
          Store (Arg1, DAD2)
          Store (Arg2, DSP2)
          Return (IIC2) }
        Case(0x3) { Name (IIC3 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C3", 0x00, ResourceConsumer, DEV3,) })
          CreateWordField (IIC3, DEV3._ADR, DAD3)
          CreateDWordField(IIC3,DEV3._SPE,DSP3)
          Store (Arg1, DAD3)
          Store (Arg2, DSP3)
          Return (IIC3) }
        Case(0x4) { Name (IIC4 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C4", 0x00, ResourceConsumer, DEV4,) })
          CreateWordField (IIC4, DEV4._ADR, DAD4)
          CreateDWordField(IIC4,DEV4._SPE,DSP4)
          Store (Arg1, DAD4)
          Store (Arg2, DSP4)
          Return (IIC4) }
        Case(0x5) { Name (IIC5 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C5", 0x00, ResourceConsumer, DEV5,) })
          CreateWordField (IIC5, DEV5._ADR, DAD5)
          CreateDWordField(IIC5,DEV5._SPE,DSP5)
          Store (Arg1, DAD5)
          Store (Arg2, DSP5)
          Return (IIC5) }
        Case(0xC) { Name (IIC6 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C6", 0x00, ResourceConsumer, DEV6,) })
          CreateWordField (IIC6, DEV6._ADR, DAD6)
          CreateDWordField(IIC6,DEV6._SPE,DSP6)
          Store (Arg1, DAD6)
          Store (Arg2, DSP6)
          Return (IIC6) }
        Case(0xD) { Name (IIC7 , ResourceTemplate () { I2cSerialBus (0, ControllerInitiated, 400000, AddressingMode7Bit,"\\_SB.PC00.I2C7", 0x00, ResourceConsumer, DEV7,) })
          CreateWordField (IIC7, DEV7._ADR, DAD7)
          CreateDWordField(IIC7,DEV7._SPE,DSP7)
          Store (Arg1, DAD7)
          Store (Arg2, DSP7)
          Return (IIC7) }
        Default {Return (0)}
      }
    } // Method I2CM
  
    //
    // Create SPI Bus Resource Descriptor for _CRS Usage
    // Arg0 - SPI Controller Number (Resource Source)
    // Arg1 - SPI Clock Phase Keyword of the Connection (Clock Phase)
    // Arg2 - SPI Bus Speed of the Connection (Connection Speed)
    // Returns Buffer with 'SPISerialBus' Resource Descriptor
    //
    Method (SPIM, 3, Serialized) {
      Switch (ToInteger(Arg0)) {
        Case(0x7) { Name (IIC7 , ResourceTemplate () { SPISerialBus(0,PolarityLow,FourWireMode,8,ControllerInitiated,10000000,ClockPolarityLow,ClockPhaseFirst,"\\_SB.PC00.SPI1",,,DEV7) })
          CreateByteField (IIC7, DEV7._PHA, DPH7)
          CreateDWordField(IIC7,DEV7._SPE,DSP7)
          Store (Arg1, DPH7)
          Store (Arg2, DSP7)
          Return (IIC7) }
        Case(0x8) { Name (IIC8 , ResourceTemplate () { SPISerialBus(0,PolarityLow,FourWireMode,8,ControllerInitiated,10000000,ClockPolarityLow,ClockPhaseFirst,"\\_SB.PC00.SPI2",,,DEV8) })
          CreateByteField (IIC8, DEV8._PHA, DPH8)
          CreateDWordField(IIC8,DEV8._SPE,DSP8)
          Store (Arg1, DPH8)
          Store (Arg2, DSP8)
          Return (IIC8) }
        Default {Return (Buffer(){0x79, 0x00})}
      }
    } // Method SPIM
  
    //
    // Create I2C Bus Resource of UCMC descriptor for _CRS usage
    // Arg0 - I2C controller number (Resource Source)
    // Returns buffer with 'I2cSerialBus' resource descriptor
    //
    Method (UCMM, 1, Serialized) {
      Switch (ToInteger(Arg0)) {
        Case(0x0) {
          Name (UCM0 , ResourceTemplate () {
          I2CSerialBus (0x38, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C0", 0, ResourceConsumer,,)
          I2CSerialBus (0x3F, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C0", 0, ResourceConsumer,,)
          I2CSerialBus (0x20, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C0", 0, ResourceConsumer,,)
          I2CSerialBus (0x27, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C0", 0, ResourceConsumer,,)
          })
          Return (UCM0) }
        Case(0x1) {
          Name (UCM1 , ResourceTemplate () {
          I2CSerialBus (0x38, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C1", 0, ResourceConsumer,,)
          I2CSerialBus (0x3F, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C1", 0, ResourceConsumer,,)
          I2CSerialBus (0x20, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C1", 0, ResourceConsumer,,)
          I2CSerialBus (0x27, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C1", 0, ResourceConsumer,,)
          })
          Return (UCM1) }
        Case(0x2) {
          Name (UCM2 , ResourceTemplate () {
          I2CSerialBus (0x21, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C2", 0, ResourceConsumer,,)
          I2CSerialBus (0x25, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C2", 0, ResourceConsumer,,)
          })
          Return (UCM2) }
        Case(0x3) {
          Name (UCM3 , ResourceTemplate () {
          I2CSerialBus (0x38, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C3", 0, ResourceConsumer,,)
          I2CSerialBus (0x3F, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C3", 0, ResourceConsumer,,)
          I2CSerialBus (0x20, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C3", 0, ResourceConsumer,,)
          I2CSerialBus (0x27, ControllerInitiated, 400000, AddressingMode7Bit, "\\_SB.PC00.I2C3", 0, ResourceConsumer,,)
          })
          Return (UCM3) }
        Default {Return (0)}
      }
    } // Method MCMM
  
    //
    // Check the I2CN supported UCMC or PD02
    // Arg0 - I2C SerialIo Devices for controller
    // Return: 1 Supported, 0 Not supported
    //
    Method (I2CS, 1) {
      Return (Or (And (Arg0, 0x4), And (Arg0, 0x8)))
    } // Method I2CS
  
  } // Scope SB.PC00
  
  
  //-----------------------------
  //  Serial IO I2C0 Controller
  //-----------------------------
  Scope(\_SB.PC00.I2C0) {
    Name(I2CN, 0)
    Name(I2CX, 0)
    Name(I2CI, 0)
    Method(_INI) {
      Store (SDS0, I2CN)
      Store (0x0, I2CX)
    }
  }
  
  //-----------------------------
  //  Serial IO I2C1 Controller
  //-----------------------------
  Scope(\_SB.PC00.I2C1) {
    Name(I2CN, 0)
    Name(I2CX, 0)
    Name(I2CI, 1)
    Method(_INI){
      Store (SDS1, I2CN)
      Store (0x1, I2CX)
    }
  }
  
  //-----------------------------
  //  Serial IO I2C2 Controller
  //-----------------------------
  Scope(\_SB.PC00.I2C2) {
    Name(I2CN, 0)
    Name(I2CX, 0)
    Name(I2CI, 2)
    Method(_INI) {
      Store (SDS2, I2CN)
      Store (0x2, I2CX)
    }
  }
  
  //-----------------------------
  //  Serial IO I2C3 Controller
  //-----------------------------
  Scope(\_SB.PC00.I2C3) {
    Name(I2CN, 0)
    Name(I2CX, 0)
    Name(I2CI, 3)
    Method(_INI) {
      Store (SDS3, I2CN)
      Store (0x3, I2CX)
    }
  }
  
  //-----------------------------
  //  Serial IO SPI1 Controller
  //-----------------------------
  Scope(\_SB.PC00.SPI1)
  {
    Name(SPIP, 0)
    Name(SPIX, 0)
    Method(_INI) {
      Store (SDS7, SPIP)
      Store (0x7, SPIX)
    }
  }
  
  //-----------------------------
  //  Serial IO SPI2 Controller
  //-----------------------------
  Scope(\_SB.PC00.SPI2)
  {
    Name(SPIP, 0)
    Name(SPIX, 0)
    Method(_INI) {
      Store (SDS8, SPIP)
      Store (0x8, SPIX)
    }
  }
  

  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  //
  // SoundWire Devices definition
  //
  // Address (_ADR) encoding:
  // Bits [63:52] - Reserved (0)
  // Bits [51:48]  - Link ID
  // Zero-based SoundWire Link number. For single-link controllers, this value shall be 0x0
  // Bits [47:0]  - Device ID
  // DeviceID Encoding as described in the SoundWire 1.0 specification, Table 80
  // For example:
  // SNDW.SWD0 (ALC701 on Link#0): _ADR(0x000010025d070100) - LinkID[51:48] = 0, DevID[47:0]: 0x10025D070100
  // SNDW.SWD6 (ALC700 on Link#2): _ADR(0x000210025d070000) - LinkID[51:48] = 2, DevID[47:0]: 0x10025D070000
  //
  
  
  
  
  
  
  
  
  
  
  // SoundWire Controller Scope
  Scope(\_SB.PC00.HDAS.SNDW)
  {
    // SoundWire Device 0..M
  
    // SoundWire Device #0 on Controller #0 (Realtek ALC701)
    // _ADR: 0x000010025d070100
    Device(SWD0)
    {
      Name (_ADR, ((0x0000 << 48) | 0x10025D070100))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #1 on Controller #1 (Realtek ALC701)
    // _ADR: 0x000110025d070100
    Device(SWD1)
    {
      Name (_ADR, ((0x0001 << 48) | 0x10025D070100))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #2 on Controller #2 (Realtek ALC701)
    // _ADR: 0x000210025d070100
    Device(SWD2)
    {
      Name (_ADR, ((0x0002 << 48) | 0x10025D070100))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #3 on Controller #3 (Realtek ALC701)
    // _ADR: 0x000310025d070100
    Device(SWD3)
    {
      Name (_ADR, ((0x0003 << 48) | 0x10025D070100))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #4 on Controller #0 (Realtek ALC700)
    // _ADR: 0x000010025d070000
    Device(SWD4)
    {
      Name (_ADR, ((0x0000 << 48) | 0x10025D070000))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #5 on Controller #1 (Realtek ALC700)
    // _ADR: 0x000110025d070000
    Device(SWD5)
    {
      Name (_ADR, ((0x0001 << 48) | 0x10025D070000))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #6 on Controller #2 (Realtek ALC700)
    // _ADR: 0x000210025d070000
    Device(SWD6)
    {
      Name (_ADR, ((0x0002 << 48) | 0x10025D070000))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  
    // SoundWire Device #7 on Controller #3 (Realtek ALC700)
    // _ADR: 0x000310025d070000
    Device(SWD7)
    {
      Name (_ADR, ((0x0003 << 48) | 0x10025D070000))
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      ///
      /// SoundWire Codec ACPI definition body
      ///
      
      //
      //Device(SWDC){
      //
        Name (_DSD, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"intel-endpoints-num", 2},
            Package (2) {"intel-autonomous-clock-stop", 0}, //SoundWire autonomous clock stop capability (0-Disabled, 1-Enabled)
            // Descriptors based on MIPI spec for SoundWire device
            Package (2) {"mipi-sdw-sw-interface-revision", 0x00010000}, // Integer
            Package (2) {"mipi-sdw-wake-up-unavailable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-test-mode-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clock-stop-mode1-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-clockstopprepare-sm-supported", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-clockstopprepare-hard-reset-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-highPHY-capable", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-paging-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bank-delay-support", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-port15-read-behavior", 1}, // Integer
            Package (2) {"mipi-sdw-master-count", 0x4}, // Integer
            Package (2) {"mipi-sdw-source-port-list", 4}, // Integer
            Package (2) {"mipi-sdw-sink-port-list", 4}, // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            // Intel defined properties for Slave
            Package (2) {"intel-endpoint-descriptor-0", "EPD0"},
            Package (2) {"intel-endpoint-descriptor-1", "EPD1"},
            //Package (2) {"intel-endpoint-descriptor-(N-1)", "EPD(N-1)"},
            // MIPI Defined properties for Slave
            Package (2) {"mipi-sdw-link-0-subproperties", "LNK0"}, // Link Descriptor 0
            Package (2) {"mipi-sdw-link-1-subproperties", "LNK1"}, // Link Descriptor 1
            Package (2) {"mipi-sdw-link-2-subproperties", "LNK2"}, // Link Descriptor 2
            Package (2) {"mipi-sdw-link-3-subproperties", "LNK3"}, // Link Descriptor 3
            Package (2) {"mipi-sdw-dp-0-subproperties", "DP0"},
            Package (2) {"mipi-sdw-dp-1-source-subproperties", "DPN"}, // DP1 ADC output
            Package (2) {"mipi-sdw-dp-2-sink-subproperties", "DPN"}, // DP2 DAC
            Package (2) {"mipi-sdw-dp-1-sink-subproperties", "DPN"}, // DP1 DAC
            Package (2) {"mipi-sdw-dp-2-source-subproperties", "DPN"}, // DP2 ADC output
            Package (2) {"mipi-sdw-dp-3-sink-subproperties", "DPN"}, // DP3 DAC
            Package (2) {"mipi-sdw-dp-4-source-subproperties", "DPN"}, // DP4 ADC output
            Package (2) {"mipi-sdw-dp-5-sink-subproperties", "DPN"}, // DP5 DAC
            Package (2) {"mipi-sdw-dp-6-source-subproperties", "DPN"}, // DP6 ADC output
            Package (2) {"mipi-sdw-dp-7-sink-subproperties", "DPN"}, // DP7 DAC
            Package (2) {"mipi-sdw-dp-8-source-subproperties", "DPN"} // DP8 ADC output
           }
        })
      
        // Endpoint Descriptor for EP 0 to N
        // Endpoint Descriptor #0
        Name(EPD0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 1}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN0"} // Reference to EPN0 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM0"},
            Package (2) {"intel-endpoint-config", "ECF0"}
          }
        })
      
        //Ch2_48kHz24bitFormat
        Name(WFX0, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz24bitFormat
        Name(WFX1, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            768000, // nAvgBytesPerSec
            8, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_48kHz16bitFormat
        Name(WFX2, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch2_96kHz16bitFormat
        Name(WFX3, Package() {
          Package () // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            2, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x3, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #0 Format
        Name(EFM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX0"},
          Package (2) {"wfx-1", "WFX1"},
          Package (2) {"wfx-2", "WFX2"},
          Package (2) {"wfx-3", "WFX3"}
          }
        })
      
        // Endpoint #0 Configuration
        Name(ECF0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #0 Pin Descriptor
        Name(EPN0, Buffer() {
                   // IntcPinDescription 2ch Headphones JackDetect
                   0xE2, 0x1C, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x03, 0x00, 0x00, 0x00, 0x8C, 0xC9, 0xB3,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // Endpoint Descriptor #1
        Name(EPD1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            // Type of the endpoint
            Package (2) {"intel-endpoint-type", 1}, // Byte, range 0-1: PDM or PCM
            //UUID for aggregated endpoints
            Package (2) {"intel-endpoint-group-id", ToUUID("00000000-0000-0000-0000-000000000000")},
            Package (2) {"intel-endpoint-group-mask", 0},
            //Position for aggregated endpoints
            Package (2) {"intel-endpoint-group-position", 0}, // Byte
            Package (2) {"intel-endpoint-direction", 0}, //0-In, 1-Out
            Package (2) {"intel-endpoint-pin-descr", "EPN1"} // Reference to EPN1 Buffer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"intel-endpoint-formats", "EFM1"},
            Package (2) {"intel-endpoint-config", "ECF1"}
          }
        })
      
        //Ch1_48kHz24bitFormat
        Name(WFX4, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz24bitFormat
        Name(WFX5, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            384000, // nAvgBytesPerSec
            4, // nBlockAlign
            32, // wBitsPerSample
            0x16 // cbSize
          },
          24, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_48kHz16bitFormat
        Name(WFX6, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            48000, // nSamplesPerSec
            96000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        //Ch1_96kHz16bitFormat
        Name(WFX7, Package() {
          Package() // WAVEFORMATEX
          {
            0xFFFE, // wFormatTag
            1, // nChannels
            96000, // nSamplesPerSec
            192000, // nAvgBytesPerSec
            2, // nBlockAlign
            16, // wBitsPerSample
            0x16 // cbSize
          },
          16, // Samples
          0x1, // dwChannelMask
          ToUUID("00000001-0000-0010-8000-00AA00389B71") // SubFormat
        })
      
        // Endpoint #1 Formats
        Name(EFM1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          Package (2) {"wfx-0", "WFX4"},
          Package (2) {"wfx-1", "WFX5"},
          Package (2) {"wfx-2", "WFX6"},
          Package (2) {"wfx-3", "WFX7"}
          }
        })
      
        // Endpoint #1 Configuration
        Name(ECF1, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
          }
        })
      
        // Endpoint #1 Pin Descriptor
        Name(EPN1, Buffer() {
                   // IntcPinDescription 1ch Microphone JackDetect
                   0xE1, 0x1B, 0xF2, 0xDF, 0x0F, 0xF7, 0xD0, 0x11,
                   0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x99, 0x8C, 0xE8,
                   0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                   0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00
                   })
      
        // DP0 Properties
        Name(DP0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-bra-flow-controlled", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-bra-imp-def-response-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dp0-interrupts-supported", 0}, // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-bpt-supported", 1} // Integer/Boolean
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-bra-mode", "BRA0"}
          }
        })
      
        // DP0 BRA mode properties (DP0MODE0)
        Name(BRA0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-bra-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"bra-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-bra-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-bra-mode-max-data-per-frame", 470}, // Integer
            Package (2) {"mipi-sdw-bra-mode-min-us-between-transactions", 0} // Integer
          }
        })
      
        // DPn properties
        Name(DPN, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-port-max-wordlength", 64}, // Integer
            Package (2) {"mipi-sdw-port-min-wordlength", 1},  // Integer
            Package (2) {"mipi-sdw-port-wordlength-configs", Package(){0}},  // Package
            Package (2) {"mipi-sdw-data-port-type", 0}, // Integer
            Package (2) {"mipi-sdw-max-grouping-supported", 0}, // Integer
            Package (2) {"mipi-sdw-simplified-channel-prepare-sm", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-imp-def-dpn-interrupts-supported", 0},  // Integer
            Package (2) {"mipi-sdw-min-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-max-channel-number", 2},  // Integer
            Package (2) {"mipi-sdw-channel-number-list", Package(){0}},  // Package
            Package (2) {"mipi-sdw-modes-supported", 1},  // Integer
            Package (2) {"mipi-sdw-block-packing-mode", 1},  // Integer/Boolean
            Package (2) {"mipi-sdw-port-encoding-type", 0}  // Integer
          },
          ToUUID("dbb8e3e6-5886-4ba6-8795-1319f52a966b"),
          Package () {
            Package (2) {"mipi-sdw-port-audio-mode-0", "AM0"}
          }
        })
      
        // Audio Mode properties (DPNMODE0)
        Name(AM0, Package() {
          ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
          Package () {
            Package (2) {"mipi-sdw-audio-mode-max-bus-frequency", 24000000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-bus-frequency", 2400000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-bus-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-max-sampling-frequency", 192000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-min-sampling-frequency", 8000}, // Integer
            Package (2) {"mipi-sdw-audio-mode-sampling-frequency-configs", Package(){0}}, // Package
            Package (2) {"mipi-sdw-audio-mode-prepare-channel-behavior", 0}, // Integer
            Package (2) {"mipi-sdw-audio-mode-glitchless-transitions", 0} // Integer
          }
        })
      //
      //} // END Device(SWDC)
      //

    }
  } // END SCOPE SNDW
  
  //
  // I2S Devices definition
  //
  If (I2SB == 0) {
    // I2C0 Controller Scope
    Scope(\_SB.PC00.I2C0) {
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      // HD Audio I2S codecs
      
      
      
      
      Device (HDAC)
      {
        Name (_HID, "INT00000")
        Name (_CID, "INT00000")
        Name (_DDN, "Intel(R) Smart Sound Technology Audio Codec")
        Name (_UID, 1)
        Name (CADR, 0) // Codec I2C address
        Name (CDIS, 0) // Codec Disabled state
      
        Method(_INI) {
          If (LEqual(I2SC, 1)) {
            Store ("INT34C2", _HID)
            Store ("INT34C2", _CID)
            Store (0x1C, CADR)
          } ElseIf (LEqual(I2SC, 2)) {
            Store ("10EC1308", _HID)
            Store ("10EC1308", _CID)
            Store (0x0010, CADR)
          }
        }
      
        Method (_CRS, 0, NotSerialized) {
      
          // IICB: Method generates 'I2cSerialBus' descriptor buffer
          // CADR: Device variable with codec address (set in _INI based on codec model)
          // I2SB: NVS variable with I2C controller connection
          // INTB: Method generates 'Interrupt' descriptor buffer
          // I2SI: NVS variable with codec jack detection pin
          Return (ConcatenateResTemplate(IICB(CADR, I2SB), INTB(I2SI, 0, 0)))
        }
      
        Method (_STA, 0, NotSerialized) {
          If (LAnd(LNotEqual(I2SC, 0), LNotEqual(CDIS, 1))) {
            Return (0xF)  // I2S Codec Enabled
          }
      
          If (LEqual (CDIS, 1)) {
            Return (0xD)  // Disabled from _DIS 1101b - Present/Disabled (via Device Manager)
          }
      
          Return (0x0)  // I2S Codec Dialed (via BIOS Policy/Setup)
        }
      
        Method (_SRS, 0x1, Serialized) {
          Store (0, CDIS) // Clear Disabled bit
        }
      
        Method (_DIS, 0x0, NotSerialized) {
          Store (1, CDIS) // Set Disabled bit
        }
      }  // Device (HDAC)

    } // END SCOPE I2C0
  }
  ElseIf (I2SB == 1) {
    // I2C1 Controller Scope
    Scope(\_SB.PC00.I2C1) {
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      // HD Audio I2S codecs
      
      
      
      
      Device (HDAC)
      {
        Name (_HID, "INT00000")
        Name (_CID, "INT00000")
        Name (_DDN, "Intel(R) Smart Sound Technology Audio Codec")
        Name (_UID, 1)
        Name (CADR, 0) // Codec I2C address
        Name (CDIS, 0) // Codec Disabled state
      
        Method(_INI) {
          If (LEqual(I2SC, 1)) {
            Store ("INT34C2", _HID)
            Store ("INT34C2", _CID)
            Store (0x1C, CADR)
          } ElseIf (LEqual(I2SC, 2)) {
            Store ("10EC1308", _HID)
            Store ("10EC1308", _CID)
            Store (0x0010, CADR)
          }
        }
      
        Method (_CRS, 0, NotSerialized) {
      
          // IICB: Method generates 'I2cSerialBus' descriptor buffer
          // CADR: Device variable with codec address (set in _INI based on codec model)
          // I2SB: NVS variable with I2C controller connection
          // INTB: Method generates 'Interrupt' descriptor buffer
          // I2SI: NVS variable with codec jack detection pin
          Return (ConcatenateResTemplate(IICB(CADR, I2SB), INTB(I2SI, 0, 0)))
        }
      
        Method (_STA, 0, NotSerialized) {
          If (LAnd(LNotEqual(I2SC, 0), LNotEqual(CDIS, 1))) {
            Return (0xF)  // I2S Codec Enabled
          }
      
          If (LEqual (CDIS, 1)) {
            Return (0xD)  // Disabled from _DIS 1101b - Present/Disabled (via Device Manager)
          }
      
          Return (0x0)  // I2S Codec Dialed (via BIOS Policy/Setup)
        }
      
        Method (_SRS, 0x1, Serialized) {
          Store (0, CDIS) // Clear Disabled bit
        }
      
        Method (_DIS, 0x0, NotSerialized) {
          Store (1, CDIS) // Set Disabled bit
        }
      }  // Device (HDAC)

    } // END SCOPE I2C1
  }
  ElseIf (I2SB == 2) {
    // I2C2 Controller Scope
    Scope(\_SB.PC00.I2C2) {
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      // HD Audio I2S codecs
      
      
      
      
      Device (HDAC)
      {
        Name (_HID, "INT00000")
        Name (_CID, "INT00000")
        Name (_DDN, "Intel(R) Smart Sound Technology Audio Codec")
        Name (_UID, 1)
        Name (CADR, 0) // Codec I2C address
        Name (CDIS, 0) // Codec Disabled state
      
        Method(_INI) {
          If (LEqual(I2SC, 1)) {
            Store ("INT34C2", _HID)
            Store ("INT34C2", _CID)
            Store (0x1C, CADR)
          } ElseIf (LEqual(I2SC, 2)) {
            Store ("10EC1308", _HID)
            Store ("10EC1308", _CID)
            Store (0x0010, CADR)
          }
        }
      
        Method (_CRS, 0, NotSerialized) {
      
          // IICB: Method generates 'I2cSerialBus' descriptor buffer
          // CADR: Device variable with codec address (set in _INI based on codec model)
          // I2SB: NVS variable with I2C controller connection
          // INTB: Method generates 'Interrupt' descriptor buffer
          // I2SI: NVS variable with codec jack detection pin
          Return (ConcatenateResTemplate(IICB(CADR, I2SB), INTB(I2SI, 0, 0)))
        }
      
        Method (_STA, 0, NotSerialized) {
          If (LAnd(LNotEqual(I2SC, 0), LNotEqual(CDIS, 1))) {
            Return (0xF)  // I2S Codec Enabled
          }
      
          If (LEqual (CDIS, 1)) {
            Return (0xD)  // Disabled from _DIS 1101b - Present/Disabled (via Device Manager)
          }
      
          Return (0x0)  // I2S Codec Dialed (via BIOS Policy/Setup)
        }
      
        Method (_SRS, 0x1, Serialized) {
          Store (0, CDIS) // Clear Disabled bit
        }
      
        Method (_DIS, 0x0, NotSerialized) {
          Store (1, CDIS) // Set Disabled bit
        }
      }  // Device (HDAC)

    } // END SCOPE I2C2
  }
  ElseIf (I2SB == 3) {
    // I2C3 Controller Scope
    Scope(\_SB.PC00.I2C3) {
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      // HD Audio I2S codecs
      
      
      
      
      Device (HDAC)
      {
        Name (_HID, "INT00000")
        Name (_CID, "INT00000")
        Name (_DDN, "Intel(R) Smart Sound Technology Audio Codec")
        Name (_UID, 1)
        Name (CADR, 0) // Codec I2C address
        Name (CDIS, 0) // Codec Disabled state
      
        Method(_INI) {
          If (LEqual(I2SC, 1)) {
            Store ("INT34C2", _HID)
            Store ("INT34C2", _CID)
            Store (0x1C, CADR)
          } ElseIf (LEqual(I2SC, 2)) {
            Store ("10EC1308", _HID)
            Store ("10EC1308", _CID)
            Store (0x0010, CADR)
          }
        }
      
        Method (_CRS, 0, NotSerialized) {
      
          // IICB: Method generates 'I2cSerialBus' descriptor buffer
          // CADR: Device variable with codec address (set in _INI based on codec model)
          // I2SB: NVS variable with I2C controller connection
          // INTB: Method generates 'Interrupt' descriptor buffer
          // I2SI: NVS variable with codec jack detection pin
          Return (ConcatenateResTemplate(IICB(CADR, I2SB), INTB(I2SI, 0, 0)))
        }
      
        Method (_STA, 0, NotSerialized) {
          If (LAnd(LNotEqual(I2SC, 0), LNotEqual(CDIS, 1))) {
            Return (0xF)  // I2S Codec Enabled
          }
      
          If (LEqual (CDIS, 1)) {
            Return (0xD)  // Disabled from _DIS 1101b - Present/Disabled (via Device Manager)
          }
      
          Return (0x0)  // I2S Codec Dialed (via BIOS Policy/Setup)
        }
      
        Method (_SRS, 0x1, Serialized) {
          Store (0, CDIS) // Clear Disabled bit
        }
      
        Method (_DIS, 0x0, NotSerialized) {
          Store (1, CDIS) // Set Disabled bit
        }
      }  // Device (HDAC)

    } // END SCOPE I2C3
  }
  ElseIf (I2SB == 4) {
    // I2C4 Controller Scope
    Scope(\_SB.PC00.I2C4) {
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      // HD Audio I2S codecs
      
      
      
      
      Device (HDAC)
      {
        Name (_HID, "INT00000")
        Name (_CID, "INT00000")
        Name (_DDN, "Intel(R) Smart Sound Technology Audio Codec")
        Name (_UID, 1)
        Name (CADR, 0) // Codec I2C address
        Name (CDIS, 0) // Codec Disabled state
      
        Method(_INI) {
          If (LEqual(I2SC, 1)) {
            Store ("INT34C2", _HID)
            Store ("INT34C2", _CID)
            Store (0x1C, CADR)
          } ElseIf (LEqual(I2SC, 2)) {
            Store ("10EC1308", _HID)
            Store ("10EC1308", _CID)
            Store (0x0010, CADR)
          }
        }
      
        Method (_CRS, 0, NotSerialized) {
      
          // IICB: Method generates 'I2cSerialBus' descriptor buffer
          // CADR: Device variable with codec address (set in _INI based on codec model)
          // I2SB: NVS variable with I2C controller connection
          // INTB: Method generates 'Interrupt' descriptor buffer
          // I2SI: NVS variable with codec jack detection pin
          Return (ConcatenateResTemplate(IICB(CADR, I2SB), INTB(I2SI, 0, 0)))
        }
      
        Method (_STA, 0, NotSerialized) {
          If (LAnd(LNotEqual(I2SC, 0), LNotEqual(CDIS, 1))) {
            Return (0xF)  // I2S Codec Enabled
          }
      
          If (LEqual (CDIS, 1)) {
            Return (0xD)  // Disabled from _DIS 1101b - Present/Disabled (via Device Manager)
          }
      
          Return (0x0)  // I2S Codec Dialed (via BIOS Policy/Setup)
        }
      
        Method (_SRS, 0x1, Serialized) {
          Store (0, CDIS) // Clear Disabled bit
        }
      
        Method (_DIS, 0x0, NotSerialized) {
          Store (1, CDIS) // Set Disabled bit
        }
      }  // Device (HDAC)

    } // END SCOPE I2C4
  }
  ElseIf (I2SB == 5) {
    // I2C5 Controller Scope
    Scope(\_SB.PC00.I2C5) {
      /** @file
      
        Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
        SPDX-License-Identifier: BSD-2-Clause-Patent
      
      **/
      
      // HD Audio I2S codecs
      
      
      
      
      Device (HDAC)
      {
        Name (_HID, "INT00000")
        Name (_CID, "INT00000")
        Name (_DDN, "Intel(R) Smart Sound Technology Audio Codec")
        Name (_UID, 1)
        Name (CADR, 0) // Codec I2C address
        Name (CDIS, 0) // Codec Disabled state
      
        Method(_INI) {
          If (LEqual(I2SC, 1)) {
            Store ("INT34C2", _HID)
            Store ("INT34C2", _CID)
            Store (0x1C, CADR)
          } ElseIf (LEqual(I2SC, 2)) {
            Store ("10EC1308", _HID)
            Store ("10EC1308", _CID)
            Store (0x0010, CADR)
          }
        }
      
        Method (_CRS, 0, NotSerialized) {
      
          // IICB: Method generates 'I2cSerialBus' descriptor buffer
          // CADR: Device variable with codec address (set in _INI based on codec model)
          // I2SB: NVS variable with I2C controller connection
          // INTB: Method generates 'Interrupt' descriptor buffer
          // I2SI: NVS variable with codec jack detection pin
          Return (ConcatenateResTemplate(IICB(CADR, I2SB), INTB(I2SI, 0, 0)))
        }
      
        Method (_STA, 0, NotSerialized) {
          If (LAnd(LNotEqual(I2SC, 0), LNotEqual(CDIS, 1))) {
            Return (0xF)  // I2S Codec Enabled
          }
      
          If (LEqual (CDIS, 1)) {
            Return (0xD)  // Disabled from _DIS 1101b - Present/Disabled (via Device Manager)
          }
      
          Return (0x0)  // I2S Codec Dialed (via BIOS Policy/Setup)
        }
      
        Method (_SRS, 0x1, Serialized) {
          Store (0, CDIS) // Clear Disabled bit
        }
      
        Method (_DIS, 0x0, NotSerialized) {
          Store (1, CDIS) // Set Disabled bit
        }
      }  // Device (HDAC)

    } // END SCOPE I2C5
  }
  
  //
  // Realtek codec definition
  //
  Scope(\_SB.PC00.HDAS)
  {
    //
    // Realtek codec
    //
    Device(RTKC) {
      Name (_ADR, 0x01)
      Method (_STA) {
        If (PXDC == 1) {
          Return (0x0)
        } else {
          Return (0xF)
        }
      }
    } // END Device(RTKC)
  } // END Scope(HDAS)

  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  


  
  Scope(\_SB.PC00.HDAS)
  {
    //
    // Pre/Post processing modules (3rd Party IP) support for Intel Smart Sound Technology
    //
    Method(PPMS, 1, Serialized)
    {
      // Helper platform method for HDAS._DSM Function 3 - Query Pre/Post Processing Module Support
      // Arg0 (equals Arg3 passed to _DSM) - UUID: Specifies the UUID of the 3rd Party IP module to check (Buffer)
      // Return - TRUE if PP Module supported, else FALSE.
  
      // ADPM - Platform NVS AudioDSP Post-Processing Module Bit Mask:
      //  [BIT0] - Waves; [BIT1] - DTS; [BIT2] - Intel SST Speech; [BIT3] - Dolby
      //  [BIT4] - Icepower; [BIT5] - Audyssey; [BIT6] - [Unused]
      //  [BIT7] - ForteMedia SAMSoft; [BIT8] - Intel WoV; [BIT9] - Sound Research IP
      //  [BIT10] - Conexant Pre-Process; [BIT11] - Conexant Smart Amp
      //  [BIT12] - Realtek Post-Process; [BIT13] - Realtek Smart Amp
      //  [BIT14] - PP Module Icepower IP MFX sub module; [BIT15] - PP Module Icepower IP EFX sub module
      //  [BIT16] - PP Module Voice Preprocessing; [BIT17] - PP Module Voice Preprocessing
      //  [BIT31:29] - Custom 3rd party IP modules (GUIDs provided from BIOS Setup)
  
      //
      // Example (to be updated with real GUIDs of supported 3rd party IP):
      //
      // 3rd Party DSP Processing Module placeholder
      // Check support for 3rd Party IP module with GUID AABBCCDD-EEFF-1122-3344-556677889900
      // If (LEqual(Arg0, ToUUID ("AABBCCDD-EEFF-1122-3344-556677889900"))){
      //   Return (1)) // GUID passed to _DSM Function 3 as Arg3 matches - module supported, return true.
      // }
      //
      // Implement for all supported PP modules
      //
  
      // PP Module Intel SST Speech
      If (LEqual(Arg0, ToUUID ("7C708106-3AFF-40FE-88BE-8C999B3F7445"))){
        Return(And(ADPM, 0x00000004)) // DSDT NVS ADPM[BIT2] set - supported (return true)
      }
  
      // PP Module Intel WoV
      If (LEqual(Arg0, ToUUID ("EC774FA9-28D3-424A-90E4-69F984F1EEB7"))){
        Return(And(ADPM, 0x00000100)) // ADPM[BIT8] set - supported (return true)
      }
  
      // PP Module 'Alpha' Custom GUID
      // Check PP module with GUID - entered in Setup menu
      If (LEqual(Arg0, ACCG(AG1L, AG1H))){
        Return(And(ADPM, 0x20000000)) // ADPM[BIT29] set - supported (return true)
      }
  
      // PP Module 'Beta' Custom GUID
      // Check PP module with GUID - entered in Setup menu
      If (LEqual(Arg0, ACCG(AG2L, AG2H))){
        Return(And(ADPM, 0x40000000)) // ADPM[BIT30] set - supported (return true)
      }
  
      // PP Module 'Gamma' Custom GUID
      // Check PP module with GUID - entered in Setup menu
      If (LEqual(Arg0, ACCG(AG3L, AG3H))){
        Return(And(ADPM, 0x80000000)) // ADPM[BIT31] set - supported (return true)
      }
  
      Return (0) // GUID not found - module not supported
    }
  
    Method (ACCG, 2, NotSerialized)
    {
      // ACCG - AudioDSP custom Pre/Post-Processing module GUID create
      // Auxiliary method to be used inside _DSM Function 3 / PPMS() (PP Module support)
      // Argument values passed from BIOS Setup as two 64bit variables
      // Arg0 - First half of GUID  - bits 0-63
      // Arg1 - Second half of GUID - bits 64-127
      // Return - 16 byte buffer containing GUID with the same byte order as ToUUID function
      Name(GBUF, Buffer(16) {})
      Concatenate(Arg0, Arg1, GBUF)
      Return (GBUF)
    }
  }

  /** @file
  
    Copyright (c) 2022, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
  
  Scope(\_SB)
  {
    Device(HIDD)                                       // HID Device.
    {
      Method (_HID) {                                  // Intel Ultrabook HID Platform Event Driver.
        Return("INTC1070")
      }
  
      Name (HBSY, 0)   // HID Busy
      Name (HIDX, 0)   // HID Index
      Name (HMDE, 0)   // HID Mode
      Name (HRDY, 0)   // HID Ready
      Name (BTLD, 0)   // Button Driver Loaded
      Name (BTS1, 0)   // Button Status
  
      Method(_STA,0,Serialized)                       // Status Method.
      {
        If (LAnd(LGreaterEqual(OSYS, 2013), LEqual(HEFE, 1))) { // If OS is Win8.1 or later AND HID event filter is enabled in Setup.
          Return(0x0F)                                // Show device.
        } Else {
          Return(0)                                   // Hide device for Win7/Win8.
        }
      }
  
      //
      // HID Driver Descriptor Method - Called by HID Driver during initialization
      // to obtain HID Descriptor information.
      //
      // Input: None
      //
      // Output:  Package containing a complete HID Descriptor information.
      //
      Method(HDDM,0,Serialized)
      {
         // Placeholder.
         Name(DPKG, Package(4) {0x11111111, 0x22222222, 0x33333333, 0x44444444})
         Return(DPKG)
      }
  
      //
      // HID Driver Event Method - Called by HID Driver to get the specific
      // platform event.
      //
      // Input: None
      //
      // Output: Platform HID Event.
      // Mode 0 = Index of HID Input Report, per pre-defined Table.
      // Mode 1 = Package containing a complete HID Input Report.
      //
      Method(HDEM,0,Serialized)
      {
         Store(0,HBSY)                          // Clear HID Busy.
         // Simple Mode is hardcoded for now.  Return Simple Mode HID Index Value.
         If (LEqual(HMDE,0))
         {
            Return(HIDX)
         }
         Return(HMDE)
      }
  
      //
      // HID Driver Mode Method - Called by HID Driver during initialization to get
      // the platform mode of operation.
      //
      // Input: None
      //
      // Output:  Mode the platform is running in.
      // 0 = Simple Mode.
      // 1 = Advanced Mode.
      //
      Method(HDMM,0,Serialized)
      {
         Return(HMDE)               // Return Mode of operation.
      }
  
      //
      // HID Driver Status Method - called by HID Driver to report platform readiness status.
      // Input: Driver Status.
      // 0 = Driver Unloaded.
      // 1 = Driver Loaded and Ready.
      //
      // Output: None
      //
      Method(HDSM,1,Serialized)
      {
        Store(Arg0,HRDY)              // Store HID Ready Status.
        // Eventually code will communicate to platform the Driver status (enabled/disabled).
      }
  
      //
      // HID Platform Event Method - called by Platform to communicate HID Event to Driver.
      // Input:
      // Mode 0 = Index of HID Event.
      // Mode 1 = Package containing a complete HID Report.
      //
      Method(HPEM,1,Serialized)                        // HID Platform Event Method.
      {
        Store(1,HBSY)                                 // Set HID Busy.
        // Simple Mode is hardcoded for now.  Simply store HID Index value.
        If (LEqual(HMDE,0))
        {
           Store(Arg0,HIDX)
        } Else {
           Store(Arg0,HIDX)
        }
        Notify(\_SB.HIDD,0xC0)                         // Notify Driver to get HID Event.
        Store(0,Local0)                                // Initialize Local0 as a timeout counter.
        While(LAnd(LLess(Local0,250),HBSY))            // Wait <= 1 second for Driver to ACK success.
        {
          Sleep(4)                                     // Delay 4 ms.
          Increment(Local0)                            // Increment Timeout.
        }
        If (LEqual(HBSY,1))                             // Failure?
        {
          Store(0,HBSY)                                // Yes.  Clear HID Busy Flag.
          Store(0,HIDX)                                // Set HID Simple Mode Index = 0 = Undefined.
          Return(1)                                    // Return Failure.
        } Else {
          Return(0)                                    // Return Success.
        }
      }
  
  If (LEqual(ECON,1)) {
      //
      // HID Button Load Method - called by Platform to say HID driver is capable of receiving 5-button array notifies.
      // Input: None
      //
      // Output: None
      //
      Method(BTNL,0,Serialized) // HID Button Enable/Disable Method
      {
        //
        // Clear PBST so that we can hide the default power button.
        //
  





#line 40196 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
        Store(One, \_SB.HIDD.BTLD)
  
        If(LEqual(\AEAB,1)) {
          //
          // Enable SCIs for HID driver in EC.
          //
          //   Bits[0]: Power Button
          //   Bits[1]: Windows Button
          //   Bits[2]: Volume Up Button
          //   Bits[3]: Volume Down Button
          //   Bits[4]: Rotation Lock Button
          //   Bits[5:31]: Reserved
          //
          If (LEqual(\S0ID,0)) {
            //
            // Disable the power button (QD5 and QD6 event) to make the slide to shutdown not pop up if the LowPowerS0Idle is disable
            //
            Store(0x1E, BTS1)
          } Else {
            //
            // Enable all buttons
            //
            Store(0x1F, BTS1)
          }
        } Else {
          //
          // Disable all buttons
          //
          Store(0, BTS1)
        }
  


#line 40230 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
      }
  
      //
      // HID Button Enable/Disable Method - called by Platform to disable/enable notification based on button press
      // Input:
      // Arg0 = Bit mask of buttons to Enable or Disable: 1- Button should be Enabled, 0- Button should be Disabled
      //   Bits[0]: Power Button N/A to disable
      //   Bits[1]: Windows Button
      //   Bits[2]: Volume Up Button
      //   Bits[3]: Volume Down Button
      //   Bits[4]: Rotation Lock Button
      //   Bits[5:31]: Reserved
      //
      // Output: None
      //
      Method(BTNE,1,Serialized) // HID Button Enable/Disable Method
      {
        If(LEqual(\AEAB,1)) {
          Store(Or(And(Arg0, 0x1E),0x01), BTS1) //Mask off PB Enable/Disable
  


#line 40253 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
        }
      }
  
      //
      // HID Button Status - called by Platform to get what buttons are enabled and disabled
      // Input: None
      //
      // Output: Bit mask of buttons' current status: 1- Button is Enabled, 0- Button is Disabled
      //   Bits[0]: Power Button N/A to disable
      //   Bits[1]: Windows Button
      //   Bits[2]: Volume Up Button
      //   Bits[3]: Volume Down Button
      //   Bits[4]: Rotation Lock Button
      //   Bits[5:31]: Reserved
      //
      Method(BTNS,0,Serialized)
      {
        If(LEqual(\AEAB,1)) {
  

#line 40274 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
        }
        Return(BTS1)
      }
  
      //
      // HID Button Capabilities Method - called by Platform to determine what buttons are supported
      // Input: None
      //
      // Output: Bit mask of buttons supported: 1- Button is Supported, 0- Button is not Supported
      //   Bits[0]: Power Button (Must be 1)
      //   Bits[1]: Windows Button
      //   Bits[2]: Volume Up Button
      //   Bits[3]: Volume Down Button
      //   Bits[4]: Rotation Lock Button
      //   Bits[5:31]: Reserved
      //
      Method(BTNC,0,Serialized) // HID Button Capabilities Method
      {
        If(LEqual(\AEAB,1)) {
          Return(0x1F)
        } Else {
          Return(0)
        }
      }
  
      //
      // HEBC: HID Event Base Capabilities [31:0]- To specify the base button capabilities supported on platform by returning a ULONG value with the following bit level definition
      // Input: None
      //
      // 0 = Button not supported
      // 1 = Button supported
      // Output:
      // Bits [0] - Windows Button (Windows 8.1 supported), Rotation Lock (Windows 8.1 supported), Num Lock, Home, End, Page Up, Page Down
      // Bits [1] - Wireless Radio Control
      // Bits [2] - System Power Down (Windows 8.1 supported)
      // Bits [3] - System Hibernate
      // Bits [4] - System Sleep/ System Wake
      // Bits [5] - Scan Next Track
      // Bits [6] - Scan Previous Track
      // Bits [7] - Stop
      // Bits [8] - Play/Pause
      // Bits [9] - Mute
      // Bits [10] - Volume Increment (Windows 8.1 supported)
      // Bits [11] - Volume Decrement (Windows 8.1 supported)
      // Bits [12] - Display Brightness Increment
      // Bits [13] - Display Brightness Decrement
      // Bits [14] - Lock Tablet
      // Bits [15] - Release Tablet
      // Bits [16] - Toggle Bezel
      // Bits [17] - 5 button array (Windows 10 supported - Power, Windows Home, Volume Up, Volume Down, Rotation Lock)
      // Bits [18] - Button 1
      // Bits [19] - Button 2
      // Bits [20] - Button 3
      // Bits [21] - Button 4
      // Bits [22] - Button 5
      // Bits [23-31] - reserved
      //
      //  Modify below table if the target platform has different capabilities. Each bit corresponding the above table definition.
      //
      Name (HEB2, 0)       // Extended 32bit capability definition for future enhancements.
  
      Method (HEBC,0,Serialized) {
        If(LEqual(\AHDB,1)) {
          Return (\HEB1)
        } Else {
          Return (0)
        }
      }
  
      Method (H2BC,0,Serialized) {
        If(LEqual(\AHDB,1)) {
          Return (\HEB1)
        } Else {
          Return (0)
        }
      }
  
      //
      // HEEC- Hid Event Extended Capabilities [32:63]
      //
      Method (HEEC,0,Serialized) {
        If(LEqual(\AHDB,1)) {
          Return(HEB2)
        } Else {
          Return(0)
        }
      }
  
      //
      // HIDD _DSM
      // _DSM : Device Specific Method for the Windows Compatible Button Array.
      //
      // Arg0: UUID Unique function identifier
      // Arg1: Integer Revision Level
      // Arg2: Integer Function Index
      // Arg3: Package Parameters
      //
      Method (_DSM, 4, Serialized, 0, UnknownObj, {BuffObj, IntObj, IntObj, PkgObj})
      {
        // Compare passed in UUID to supported UUID.
  
        If (LEqual(Arg0, ToUUID ("EEEC56B3-4442-408F-A792-4EDD4D758054")))
        {
          If (LEqual(1,ToInteger(Arg1)))        // Revision 1.
          {
            Switch (ToInteger(Arg2))            // Switch to Function Index.
            {
              //
              // Function 0, Query of supported functions.
              //
              Case (0)
              {
                Return (Buffer() {0xFF, 0x03}) // Total 9 function indices are supported including this.
              }
  
              //
              // Function 1, BTNL. Button Load Method. No Input/Output.
              //
              Case (1)
              {
                BTNL()
              }
  
              //
              // Function 2, HDMM. HID Driver Mode Method.
              // Input:None
              // Output:HDMM output. See HDMM
              //
              Case (2)
              {
                Return(HDMM())
              }
  
              //
              // Function 3, HDSM. HID Driver Status Method.
              // Input: 0 - The driver is not available. 1 - The driver is available.
              // Output: None
              //
              Case (3)
              {
                HDSM(DeRefOf(Index(Arg3, 0)))
              }
  
              //
              // Function 4, HDEM. HID Driver Event Method.
              // Input: None.
              // Output: Package contains Supported Keys (Mode 0)
              //
              Case (4)
              {
                Return(HDEM())
              }
  
              //
              // Function 5 BTNS. Button Status Method.
              // Input: None.
              // Output: Int32 which contains a bit map of Buttons' enable/disable states
              //
              Case (5)
              {
                Return(BTNS())
              }
  
              //
              // Function 6 BTNE. Button Enable/Disable Method.
              // Input: Int32 Bit mask of buttons enable/disable control. 1- Button should be Enabled, 0- Button should be Disabled
              // Output: None.
              //
              Case (6)
              {
                BTNE(DeRefOf(Index(Arg3, 0)))
              }
  
              //
              // Function 7 HEBC. Button implemented state.
              // Input: None
              // Output: Int32 Bit map which shows what buttons are implemented on this system.
              //
              Case (7)
              {
                Return(HEBC())
              }
  
              //
              // Function 8 VGBS. Virtual GPIO Button Status.
              // Input: None
              // Output: Intger Bit map which shows what Virtual GPIO Button status. Currently only Dock/Slate modes are supported.
              //
              Case (8)
              {
  

#line 40467 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
                Return(0)
  #line 40469 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
              }
              //
              // Function 9 H2BC. Button implemented state.
              // Input: None
              // Output: Int32 Bit map which shows what buttons are implemented on this system.
              //
              Case (9)
              {
                Return(H2BC())
              }
            } // End Switch statement
          }  // End Revision check
        }  // End UUID check
  
        // If the code falls through to this point, just return a buffer of 0.
  
        Return (Buffer() {0x00})
  
      }  // End _DSM Method
    }
    }
  }//end scope _SB

  /** @file
    ACPI DSDT table
  
    Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  **/
    Method (ISAR, 4)
    {
      Name (BUF1, Buffer(2) {0,0})
      //--------------------------------------------
      //  Intel Proprietary Dynamic SAR solution
      //
      //  Method(_DSM, 0x4, Serialized, 0, {IntObj, BuffObj}, {BuffObj, IntObj, IntObj, PkgObj})
      //
      //--------------------------------------------
      If (LEqual(Arg0, ToUUID("1730E71D-E5DD-4A34-BE57-4D76B6A2FE37")))
      {
          Return(0) // Function number mismatch but normal return.
      }
      Else
      {
        Return(Buffer(One) { 0x00 }) // Guid mismatch
      }
    } // End Method (ISAR)





























































































#line 40610 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"
  /** @file
  
    Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  
  
  
  //
  // This library provides functions that configure pin states.
  //
  // GPIO package definition:
  // Package() {
  //   GpioPad : IntObj
  //   GpioActiveStatePolarity : IntObj
  //   }
  //
  
  //
  // GPIO library imports
  //
  
  Scope(\) {
  
    //
    // Note this is not a real power resource we simply use this to declare new named scope
    //
    PowerResource(PIN, 0, 0) {
      //
      // Check pin status function
      // @param[in]  Arg0  Pin descriptor package
      //
      // @return GPIO pin status relative to GpioActiveStatePolarity value
      //
      Method(STA, 1, Serialized) {
        If(LEqual(\_SB.GGOV(DeRefOf(Index(Arg0, 0))), DeRefOf(Index(Arg0, 1)))) {
          Return(1)
        } Else {
          Return(0)
        }
      }
  
      //
      // Drive pin to active state function.
      // @param[in]  Arg0  Pin descriptor package
      //
      Method(ON, 1, Serialized) {
        \_SB.SGOV(DeRefOf(Index(Arg0, 0)), DeRefOf(Index(Arg0, 1)))
      }
  
      //
      // Drive pin to inactive state.
      // @param[in]  Arg0  Pin descriptor package
      //
      Method(OFF, 1, Serialized) {
        \_SB.SGOV(DeRefOf(Index(Arg0, 0)), Not(DeRefOf(Index(Arg0, 1))))
      }
  
      // Dummy standard methods for OSPM.
      // PowerResource is required to implement those.
      Method(_STA) {Return(0)}
      Method(_ON) {}
      Method(_OFF) {}
    }
  }
  

  /**@file
  
    Copyright (c) 2017, Intel Corporation. All rights reserved.<BR>
    SPDX-License-Identifier: BSD-2-Clause-Patent
  
  **/
  
  Device(DWMI)
  {
    // PNP0C14 is PNP ID assigned to WMI mapper
    Name(_HID, EISAID("PNP0C14"))
    Name(_UID, 0x0)
  
    Name(_WDG, Buffer(){
      // {44FADEB1-B204-40F2-8581-394BBDC1B651}
      // This user defined GUID for providing interfaces for WQ00/WS00
      0xb1, 0xde, 0xfa, 0x44, 0x04, 0xb2, 0xf2, 0x40, 0x85, 0x81, 0x39, 0x4b, 0xbd, 0xc1, 0xb6, 0x51,
      0x30, 0x30,   // Object Id (00), need to match WQ00/WS00 below.
      0x01,         // Instance Count
      0x01,         // Flags (WMIACPI_REGFLAG_EXPENSIVE)
  
      // {05901221-D566-11D1-B2F0-00A0C9062910}
      // This GUID for returning the MOF data, do not change
      0x21, 0x12, 0x90, 0x05, 0x66, 0xd5, 0xd1, 0x11, 0xb2, 0xf0, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10, //
      0x5A, 0x5A,   // Object ID (ZZ), need to match WQZZ below.
      0x01,         // Instance Count
      0x00          // Flags
    })
  
    Method(WQ00, 1)
    {
      Return (FWUC(0, 0))
    }
  
    Method(WS00, 2)
    {
      FWUC (1, Arg1)
    }
  
    Name(WQZZ, Buffer() {
      //
      // Embed BMF binary file generated from MOF file using:
      //   mofcomp  -B:test.bmf test.mof
      //
      // Below is the file content for test.mof:
      //
      //  #pragma namespace("\\\\.\\root\\wmi")
      //  #pragma classflags("forceupdate")
      //  #pragma autorecover
      //
      //  class WMIEvent : __ExtrinsicEvent
      //  {
      //  };
      //
      //  [WMI,
      //   Dynamic,
      //   Provider("WmiProv"),
      //   Locale("MS\\0x409"),
      //   Description("Class to write firmware command"),
      //   guid("{44FADEB1-B204-40F2-8581-394BBDC1B651}")
      //  ]
      //  class AcpiFirmwareCommunication
      //  {
      //      [key, read]
      //       string InstanceName;
      //      [read] boolean Active;
      //
      //      [WmiDataId(1),
      //       read, write,
      //       Description("description")
      //      ] uint32 Command;
      //  };
      //
      0x46, 0x4F, 0x4D, 0x42, 0x01, 0x00, 0x00, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x14, 0x06, 0x00, 0x00,
      0x44, 0x53, 0x00, 0x01, 0x1A, 0x7D, 0xDA, 0x54, 0x18, 0xDA, 0x82, 0x00, 0x01, 0x06, 0x18, 0x42,
      0x10, 0x05, 0x10, 0x92, 0x46, 0x62, 0x02, 0x89, 0x80, 0x90, 0x18, 0x18, 0x14, 0x81, 0x85, 0x00,
      0x49, 0x02, 0x88, 0xC4, 0x41, 0xE1, 0x20, 0xD4, 0x9F, 0x40, 0x7E, 0x05, 0x20, 0x74, 0x28, 0x40,
      0xA6, 0x00, 0x83, 0x02, 0x9C, 0x22, 0x88, 0xA0, 0x57, 0x01, 0x36, 0x05, 0x98, 0x14, 0x60, 0x51,
      0x80, 0x76, 0x01, 0x96, 0x05, 0xE8, 0x16, 0x20, 0x1D, 0x96, 0x88, 0x04, 0x47, 0x89, 0x01, 0x47,
      0xE9, 0xC4, 0x16, 0x6E, 0xD8, 0xE0, 0x85, 0xA2, 0x68, 0x06, 0x51, 0x12, 0x94, 0x8B, 0x20, 0x5D,
      0x10, 0x52, 0x2E, 0xC0, 0x37, 0x82, 0x06, 0x10, 0xA5, 0x77, 0x01, 0xB6, 0x05, 0x98, 0x86, 0x27,
      0xD2, 0x20, 0xE4, 0x60, 0x08, 0x54, 0xCE, 0x80, 0x20, 0x69, 0x44, 0x21, 0x1E, 0xA7, 0x44, 0x08,
      0x0A, 0x84, 0x90, 0xD4, 0xF1, 0xA0, 0xA0, 0x71, 0x88, 0xAD, 0xCE, 0x46, 0x93, 0xA9, 0x74, 0x7E,
      0x48, 0x82, 0x70, 0xC6, 0x2A, 0x7E, 0x3A, 0x9A, 0xD0, 0xD9, 0x9C, 0x60, 0xE7, 0x18, 0x72, 0x3C,
      0x48, 0xF4, 0x20, 0x78, 0xA0, 0x55, 0x9B, 0x40, 0x11, 0x06, 0xAE, 0x08, 0x30, 0x28, 0x0D, 0x63,
      0xA1, 0x2E, 0x40, 0x29, 0xB0, 0x87, 0xCD, 0x06, 0x64, 0x88, 0x92, 0xE0, 0x50, 0x47, 0x00, 0x4B,
      0x14, 0x60, 0x7E, 0x1C, 0x32, 0x3C, 0x54, 0x32, 0x96, 0x90, 0x6C, 0xAC, 0x1E, 0x0A, 0x97, 0x02,
      0xA1, 0xB1, 0x9D, 0xB4, 0x67, 0x14, 0xB1, 0xE4, 0x29, 0x09, 0x26, 0x81, 0x47, 0x11, 0xD9, 0x68,
      0x1C, 0x1A, 0x3B, 0x0C, 0x0F, 0x33, 0xD8, 0x41, 0x1C, 0x46, 0xD9, 0xC8, 0x22, 0xF0, 0x84, 0x8E,
      0xF4, 0x21, 0xA0, 0x30, 0x01, 0xFF, 0xFF, 0x79, 0x46, 0x8D, 0xD1, 0x1C, 0x14, 0x11, 0x7D, 0x2E,
      0x40, 0x8F, 0x29, 0xEC, 0xD1, 0xC6, 0x3E, 0x5F, 0x0B, 0x1F, 0xAC, 0x30, 0x8E, 0xE0, 0xB8, 0x12,
      0x9C, 0xF9, 0x19, 0x9C, 0x42, 0xB4, 0x08, 0x05, 0x61, 0x09, 0x2A, 0xC6, 0x63, 0x41, 0x48, 0xC3,
      0x04, 0x0E, 0x53, 0x33, 0x8A, 0x70, 0xCE, 0x29, 0x54, 0xC8, 0x20, 0x91, 0x3C, 0x81, 0x90, 0x81,
      0x22, 0x04, 0x8A, 0x7F, 0x72, 0x09, 0xE2, 0x1F, 0x0A, 0x46, 0x06, 0x84, 0x3C, 0x0B, 0xB0, 0x3E,
      0x46, 0x42, 0x60, 0xF7, 0x83, 0x12, 0xC2, 0xF3, 0xC1, 0x1B, 0xC1, 0xF9, 0xBC, 0x0A, 0x54, 0x28,
      0xC0, 0x98, 0x00, 0x5B, 0x18, 0x52, 0x36, 0x32, 0x61, 0x45, 0x39, 0x36, 0xC3, 0xC5, 0x89, 0xF2,
      0x40, 0xD1, 0x1A, 0x84, 0xF0, 0xEC, 0x6C, 0x7E, 0x02, 0x0B, 0x19, 0x21, 0xF2, 0x69, 0x45, 0x0A,
      0x52, 0x1B, 0x9C, 0x40, 0xDA, 0x5F, 0x08, 0x7B, 0x39, 0xE8, 0x44, 0xE0, 0x48, 0xA3, 0x41, 0x1D,
      0x17, 0x7C, 0x2A, 0xF0, 0x89, 0xE0, 0x29, 0xC1, 0xB3, 0x3B, 0x2C, 0x8F, 0xEC, 0xD4, 0x9E, 0x28,
      0x1E, 0x07, 0x3C, 0x70, 0x76, 0x4F, 0xF0, 0x41, 0xC2, 0xE7, 0x03, 0xBC, 0x6B, 0x40, 0x5D, 0x0C,
      0x1E, 0x0B, 0xD8, 0x34, 0xC3, 0x61, 0x86, 0xE8, 0xB9, 0x7A, 0x02, 0x87, 0xC8, 0x00, 0x3D, 0xB6,
      0x27, 0x02, 0xEC, 0xBC, 0x4E, 0xE6, 0x71, 0xE0, 0x8D, 0xA2, 0xD9, 0xBB, 0x04, 0x21, 0x38, 0x1E,
      0x5F, 0x23, 0xD8, 0x84, 0x13, 0x58, 0xFE, 0x20, 0x50, 0x23, 0x33, 0xB4, 0x87, 0x7C, 0x5A, 0xAF,
      0x03, 0x3E, 0x4D, 0x98, 0xC0, 0x62, 0x4F, 0x26, 0x74, 0x3C, 0xE0, 0x57, 0x7C, 0x0A, 0x21, 0x57,
      0x82, 0xFF, 0x7F, 0x6C, 0x9F, 0x12, 0x2C, 0xE1, 0x6C, 0x21, 0x27, 0xE3, 0x41, 0x43, 0x3F, 0x1E,
      0x60, 0x03, 0x43, 0xE8, 0xEB, 0x22, 0x01, 0xA2, 0xCE, 0x23, 0xA8, 0x43, 0x85, 0xCF, 0x13, 0xEC,
      0x3E, 0x10, 0xF4, 0x19, 0xC0, 0x43, 0x09, 0xEB, 0xDF, 0x8B, 0x47, 0x06, 0x1F, 0x10, 0x7F, 0x83,
      0xC0, 0x00, 0xB2, 0xD3, 0x89, 0x0F, 0x15, 0xE0, 0xB8, 0x71, 0x18, 0x0C, 0xCE, 0x88, 0xE1, 0xDF,
      0x26, 0x7C, 0x44, 0xF1, 0x05, 0xE2, 0x25, 0xE2, 0x39, 0x80, 0x9F, 0x72, 0xE0, 0x1F, 0x0A, 0x3C,
      0x92, 0xE0, 0x6F, 0x14, 0x6F, 0x1A, 0xD8, 0xB1, 0xF3, 0x51, 0x9C, 0xC4, 0xEB, 0x89, 0xC7, 0xEC,
      0x21, 0xF1, 0xD3, 0x0E, 0x70, 0x1F, 0x0E, 0x57, 0x68, 0xD3, 0xA7, 0x46, 0xA3, 0x56, 0x0D, 0xCA,
      0xD4, 0x28, 0xD3, 0xA0, 0x56, 0x9F, 0x4A, 0x8D, 0x19, 0x1B, 0x82, 0xE5, 0x52, 0xE8, 0xFF, 0x0F,
      0xE2, 0xB0, 0x20, 0x34, 0xEE, 0xF1, 0x46, 0x20, 0xFE, 0xFF, 0x03
    })
  }


  Scope(\_SB.PC00.RP01) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(PSW3, 0), LEqual(RPN3, 0x01))) {
        Return (GPRW (GGPE (PSW3), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP02) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(WWKP, 0), LEqual(WWRP, 0x02))) {
        Return (GPRW (GGPE (WWKP), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP03) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(WWKP, 0), LEqual(WWRP, 0x03))) {
        Return (GPRW (GGPE (WWKP), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP04) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(WLWK, 0), LEqual(WLRP, 0x04))) {
        Return (GPRW (GGPE (WLWK), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP05) {
    Method(_PRW, 0) {
      If (LOr((LAnd(LNotEqual(PSW3, 0), LEqual(RPN3, 0x05))) ,(LAnd(LNotEqual(WLWK, 0), LEqual(WLRP, 0x05))))) {
        If (LAnd(LNotEqual(PSW3, 0), LEqual(RPN3, 0x05))) {
          Return (GPRW (GGPE (PSW3), 4))
        } ElseIf (LAnd(LNotEqual(WLWK, 0), LEqual(WLRP, 0x05))) {
          Return (GPRW (GGPE (WLWK), 4))
        } Else {
          Return (GPRW (0x69, 4))
        }
      } ElseIf (LAnd(LNotEqual(PSW2, 0), LEqual(RPN2, 0x05))) {
          Return (GPRW (GGPE (PSW2), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP06) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(WWKP, 0), LEqual(WWRP, 0x06))) {
        Return (GPRW (GGPE (WWKP), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP07) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(PSWP, 0), LEqual(RPNB, 0x07))) {
        Return (GPRW (0x6D, 4))
      } ElseIf (LAND(LEqual(FVSP,1), LAnd(LNotEqual(FVWP, 0), LEqual(RPFV, 0x07)))) {
        Return (GPRW (GGPE (FVWP), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP08) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(WLWK, 0), LEqual(WLRP, 0x08))) {
        Return (GPRW (GGPE (WLWK), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP09) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(PSW2, 0), LEqual(RPN2, 0x09))) {
        Return (GPRW (GGPE (PSW2), 4))
      } ElseIf (LAnd(LNotEqual(PSW3, 0), LEqual(RPN3, 0x09))) {
          Return (GPRW (GGPE (PSW3), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP10) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP11) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP12) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP13) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP14) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP15) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP16) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP17) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP18) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP19) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP20) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP21) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(PSWP, 0), LEqual(RPNB, 0x15))) {
        Return (GPRW (GGPE (PSWP), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP22) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP23) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP24) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP25) {
    Method(_PRW, 0) {
      If (LAnd(LNotEqual(PSW2, 0), LEqual(RPN2, 0x19))) {
        Return (GPRW (GGPE (PSW2), 4))
      } Else {
        Return (GPRW (0x69, 4))
      }
    }
  }
  Scope(\_SB.PC00.RP26) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP27) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }
  Scope(\_SB.PC00.RP28) {
    Method(_PRW, 0) {
      Return (GPRW (0x69, 4))
    }
  }












#line 41005 "e:\\code\\adl_n100_code\\sblplatform\\Build\\BootloaderCorePkg\\DEBUG_VS2019\\IA32\\Platform\\AlderlakeBoardPkg\\AcpiTables\\AcpiTablesN\\OUTPUT\\Dsdt\\Dsdt.i"

  Name(\_S0, Package(4){0x0,0x0,0,0}) // mandatory System state
  if(SS1) { Name(\_S1, Package(4){0x1,0x0,0,0})}
  if(SS3) { Name(\_S3, Package(4){0x5,0x0,0,0})}
  if(SS4) { Name(\_S4, Package(4){0x6,0x0,0,0})}
  Name(\_S5, Package(4){0x7,0x0,0,0}) // mandatory System state

  Method(PTS, 1) {        // METHOD CALLED FROM _PTS PRIOR TO ENTER ANY SLEEP STATE
    If(Arg0)              // entering any sleep state
      {
      }
    }
    Method(WAK, 1) {      // METHOD CALLED FROM _WAK RIGHT AFTER WAKE UP
  }

  Scope(\_SB.PC00.SAT0) {
    //
    // Check for platform defined _DSM method support
    //
    // Arg0 - _DSM GUID
    //
    Method(SATC, 1, Serialized) {
      If(LEqual(Arg0, ToUUID("E4DB149B-FCFE-425b-A6D8-92357D78FC7F"))) {
        Return (1)
      } Else {
        Return (0)
      }
    }

    //
    // Execute platform defined _DSM method
    //
    // Arg0 - _DSM GUID
    // Arg1 - _DSM revision
    // Arg2 - Function index
    // Arg3 - Package with parameters
    //
    Method(SATD, 4, Serialized) {
      Switch (ToInteger(Arg2)) {
        Case (0) {
          ///Case 0: Standard query - A bitmask of functions supported
          Return(Buffer() {0x3})
        }
        Default {
          Return (0)
        }
      }
      Return(Buffer() {0x0})
    }

    //
    // ACPI Method to support PUIS capability for each Sata port
    //
    If (LAnd(LEqual(\S0ID,1), LEqual(\PUIS,1))) {
      Scope(PRT0) {
        /** @file
          ACPI Sata PUIS Enablement
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
        
        //
        // Set Device Data Method
        // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
        //
        Method (_SDD, 0x1, NotSerialized) {
          CreateByteField(GTF0, 0x0, FEAT)
          CreateByteField(GTF0, 0x6, CMMD)
          CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
          CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
        
          If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
            // Check if PUIS feature is supported (Word 83 Bit5)
            If (LEqual (And (W083, 0x0020), 0x0020)) {
              // Check enable state (Word 86 Bit5)
              If (LEqual (And (W086, 0x0020), 0)) {
                // Issue Set Feature EFh, subcommand 06h to enable PUIS
                Store (0x06, FEAT)
                Store (0xEF, CMMD)
              }
            }
          }
        }
        
        //
        // Get Task File Method
        //
        // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
        //
        Method(_GTF, 0, NotSerialized) {
          return (GTF0)
        
        }

      }

      Scope(PRT1) {
        /** @file
          ACPI Sata PUIS Enablement
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
        
        //
        // Set Device Data Method
        // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
        //
        Method (_SDD, 0x1, NotSerialized) {
          CreateByteField(GTF0, 0x0, FEAT)
          CreateByteField(GTF0, 0x6, CMMD)
          CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
          CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
        
          If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
            // Check if PUIS feature is supported (Word 83 Bit5)
            If (LEqual (And (W083, 0x0020), 0x0020)) {
              // Check enable state (Word 86 Bit5)
              If (LEqual (And (W086, 0x0020), 0)) {
                // Issue Set Feature EFh, subcommand 06h to enable PUIS
                Store (0x06, FEAT)
                Store (0xEF, CMMD)
              }
            }
          }
        }
        
        //
        // Get Task File Method
        //
        // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
        //
        Method(_GTF, 0, NotSerialized) {
          return (GTF0)
        
        }

      }

      Scope(PRT2) {
        /** @file
          ACPI Sata PUIS Enablement
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
        
        //
        // Set Device Data Method
        // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
        //
        Method (_SDD, 0x1, NotSerialized) {
          CreateByteField(GTF0, 0x0, FEAT)
          CreateByteField(GTF0, 0x6, CMMD)
          CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
          CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
        
          If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
            // Check if PUIS feature is supported (Word 83 Bit5)
            If (LEqual (And (W083, 0x0020), 0x0020)) {
              // Check enable state (Word 86 Bit5)
              If (LEqual (And (W086, 0x0020), 0)) {
                // Issue Set Feature EFh, subcommand 06h to enable PUIS
                Store (0x06, FEAT)
                Store (0xEF, CMMD)
              }
            }
          }
        }
        
        //
        // Get Task File Method
        //
        // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
        //
        Method(_GTF, 0, NotSerialized) {
          return (GTF0)
        
        }

      }

      Scope(PRT3) {
        /** @file
          ACPI Sata PUIS Enablement
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
        
        //
        // Set Device Data Method
        // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
        //
        Method (_SDD, 0x1, NotSerialized) {
          CreateByteField(GTF0, 0x0, FEAT)
          CreateByteField(GTF0, 0x6, CMMD)
          CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
          CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
        
          If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
            // Check if PUIS feature is supported (Word 83 Bit5)
            If (LEqual (And (W083, 0x0020), 0x0020)) {
              // Check enable state (Word 86 Bit5)
              If (LEqual (And (W086, 0x0020), 0)) {
                // Issue Set Feature EFh, subcommand 06h to enable PUIS
                Store (0x06, FEAT)
                Store (0xEF, CMMD)
              }
            }
          }
        }
        
        //
        // Get Task File Method
        //
        // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
        //
        Method(_GTF, 0, NotSerialized) {
          return (GTF0)
        
        }

      }

      Scope(PRT4) {
        /** @file
          ACPI Sata PUIS Enablement
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
        
        //
        // Set Device Data Method
        // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
        //
        Method (_SDD, 0x1, NotSerialized) {
          CreateByteField(GTF0, 0x0, FEAT)
          CreateByteField(GTF0, 0x6, CMMD)
          CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
          CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
        
          If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
            // Check if PUIS feature is supported (Word 83 Bit5)
            If (LEqual (And (W083, 0x0020), 0x0020)) {
              // Check enable state (Word 86 Bit5)
              If (LEqual (And (W086, 0x0020), 0)) {
                // Issue Set Feature EFh, subcommand 06h to enable PUIS
                Store (0x06, FEAT)
                Store (0xEF, CMMD)
              }
            }
          }
        }
        
        //
        // Get Task File Method
        //
        // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
        //
        Method(_GTF, 0, NotSerialized) {
          return (GTF0)
        
        }

      }

      Scope(PRT5) {
        /** @file
          ACPI Sata PUIS Enablement
        
          Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
          SPDX-License-Identifier: BSD-2-Clause-Patent
        **/
        
        Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
        
        //
        // Set Device Data Method
        // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
        //
        Method (_SDD, 0x1, NotSerialized) {
          CreateByteField(GTF0, 0x0, FEAT)
          CreateByteField(GTF0, 0x6, CMMD)
          CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
          CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
        
          If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
            // Check if PUIS feature is supported (Word 83 Bit5)
            If (LEqual (And (W083, 0x0020), 0x0020)) {
              // Check enable state (Word 86 Bit5)
              If (LEqual (And (W086, 0x0020), 0)) {
                // Issue Set Feature EFh, subcommand 06h to enable PUIS
                Store (0x06, FEAT)
                Store (0xEF, CMMD)
              }
            }
          }
        }
        
        //
        // Get Task File Method
        //
        // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
        //
        Method(_GTF, 0, NotSerialized) {
          return (GTF0)
        
        }

      }

      If(CondRefOf(PRT6)) {
        Scope(PRT6) {
          /** @file
            ACPI Sata PUIS Enablement
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
          Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
          
          //
          // Set Device Data Method
          // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
          //
          Method (_SDD, 0x1, NotSerialized) {
            CreateByteField(GTF0, 0x0, FEAT)
            CreateByteField(GTF0, 0x6, CMMD)
            CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
            CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
          
            If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
              // Check if PUIS feature is supported (Word 83 Bit5)
              If (LEqual (And (W083, 0x0020), 0x0020)) {
                // Check enable state (Word 86 Bit5)
                If (LEqual (And (W086, 0x0020), 0)) {
                  // Issue Set Feature EFh, subcommand 06h to enable PUIS
                  Store (0x06, FEAT)
                  Store (0xEF, CMMD)
                }
              }
            }
          }
          
          //
          // Get Task File Method
          //
          // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
          //
          Method(_GTF, 0, NotSerialized) {
            return (GTF0)
          
          }

        }
      }

      If(CondRefOf(PRT7)) {
        Scope(PRT7) {
          /** @file
            ACPI Sata PUIS Enablement
          
            Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
            SPDX-License-Identifier: BSD-2-Clause-Patent
          **/
          
          Name (GTF0, Buffer (0x7) {0x00,0x00,0x00,0x00,0x00,0xA0,0x00})
          
          //
          // Set Device Data Method
          // Arg0 - A Buffer containing an ATA drive identify block, contents described by the ATA
          //
          Method (_SDD, 0x1, NotSerialized) {
            CreateByteField(GTF0, 0x0, FEAT)
            CreateByteField(GTF0, 0x6, CMMD)
            CreateWordField(Arg0, 0xA6, W083)  // Identify Device Data Word 83
            CreateWordField(Arg0, 0xAC, W086)  // Identify Device Data Word 86
          
            If (LEqual(SizeOf(Arg0), 0x200)) {  // 256 WORD Data Block by OSPM to send 0xEC Command to Device
              // Check if PUIS feature is supported (Word 83 Bit5)
              If (LEqual (And (W083, 0x0020), 0x0020)) {
                // Check enable state (Word 86 Bit5)
                If (LEqual (And (W086, 0x0020), 0)) {
                  // Issue Set Feature EFh, subcommand 06h to enable PUIS
                  Store (0x06, FEAT)
                  Store (0xEF, CMMD)
                }
              }
            }
          }
          
          //
          // Get Task File Method
          //
          // @return 0 - A Buffer containing a byte stream of ATA commands for the drive
          //
          Method(_GTF, 0, NotSerialized) {
            return (GTF0)
          
          }

        }
      }
    }
  }
}// End of ASL File
